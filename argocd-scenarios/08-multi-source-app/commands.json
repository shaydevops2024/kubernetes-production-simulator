{
  "scenario_id": "08-multi-source-app",
  "difficulty": "hard",
  "duration": "20 min",
  "commands": [
    {
      "name": "Step 1: Understand Multi-Source Pattern",
      "command": "echo '=== Multi-Source Application Pattern ===\n\nIn production, teams often split configs across repos:\n- Repo A: Deployment, Service (infra team)\n- Repo B: ConfigMaps, Secrets (app team)\n\nArgoCD can combine multiple sources into one Application.\nThis scenario simulates that pattern.' && cat argocd-scenarios/08-multi-source-app/manifests/deployment.yaml",
      "description": "Learn why multi-source applications are used in production",
      "explanation": "Multi-source applications let different teams own different parts of the deployment. The infra team manages deployments/services while the app team manages configs. ArgoCD combines them into a single application.",
      "what_it_does": "Explains the multi-source pattern and shows the deployment manifest.",
      "next_step": "Review the secondary source (ConfigMap)."
    },
    {
      "name": "Step 2: Review ConfigMap (Secondary Source)",
      "command": "cat argocd-scenarios/08-multi-source-app/manifests/configmap.yaml",
      "description": "Review the ConfigMap that represents a secondary source",
      "explanation": "In a real multi-source setup, this ConfigMap would come from a different Git repository. It provides the content that the deployment's pods mount. Changes to either source trigger a sync.",
      "what_it_does": "Shows the ConfigMap manifest (secondary source).",
      "next_step": "Create the namespace and deploy both sources."
    },
    {
      "name": "Step 3: Create Namespace",
      "command": "kubectl create namespace argocd-sc-08 --dry-run=client -o yaml | kubectl apply -f -",
      "description": "Create the namespace for this scenario",
      "explanation": "Creates the argocd-sc-08 namespace where all resources will be deployed.",
      "what_it_does": "Creates the namespace if it doesn't exist.",
      "next_step": "Deploy the application via ArgoCD."
    },
    {
      "name": "Step 4: Deploy via ArgoCD",
      "command": "kubectl apply -f argocd-scenarios/08-multi-source-app/application.yaml && echo 'Waiting for sync...' && sleep 10 && kubectl get application sc08-multi-source -n argocd",
      "description": "Create the ArgoCD Application",
      "explanation": "ArgoCD deploys all manifests from the source path. In a real multi-source setup, you'd configure multiple sources in the Application spec. Here we simulate it with manifests labeled by source.",
      "what_it_does": "Creates the ArgoCD Application and begins syncing.",
      "next_step": "Verify all resources are deployed."
    },
    {
      "name": "Step 5: Verify Resources from Both Sources",
      "command": "echo '=== Primary Source (Deployment + Service) ===' && kubectl get deployment,service -n argocd-sc-08 -l app=multi-source-app && echo '' && echo '=== Secondary Source (ConfigMap) ===' && kubectl get configmap -n argocd-sc-08 -l source=secondary && echo '' && echo '>>> Open ArgoCD UI to see all resources in the tree <<<'",
      "description": "Verify resources from both primary and secondary sources",
      "explanation": "The deployment and service come from the 'primary' source, while the ConfigMap comes from the 'secondary' source. In ArgoCD UI, you can see all resources in the application tree regardless of their origin.",
      "what_it_does": "Lists resources grouped by their source label.",
      "next_step": "Update the secondary source to see how changes propagate."
    },
    {
      "name": "Step 6: Update Secondary Source (ConfigMap)",
      "command": "kubectl patch configmap multi-source-content -n argocd-sc-08 --type merge -p '{\"data\":{\"index.html\":\"<html><body><h1>Updated Content v2</h1><p>This content was updated from the secondary source.</p></body></html>\"}}' && echo 'ConfigMap updated! Check ArgoCD for OutOfSync status.'",
      "description": "Simulate a change in the secondary source repo",
      "explanation": "In production, a git push to the secondary repo would trigger this. ArgoCD detects the drift between desired state (Git) and live state (cluster). The application shows as OutOfSync.",
      "what_it_does": "Updates the ConfigMap to simulate a secondary source change.",
      "next_step": "Check ArgoCD sync status."
    },
    {
      "name": "Step 7: Check Sync Status",
      "command": "echo '>>> Open ArgoCD UI at http://localhost:30800 <<<\n>>> sc08-multi-source may show OutOfSync <<<' && kubectl get application sc08-multi-source -n argocd -o jsonpath='Sync: {.status.sync.status}, Health: {.status.health.status}'",
      "description": "Observe how ArgoCD detects changes from either source",
      "explanation": "ArgoCD monitors all resources regardless of which source they came from. Any drift triggers OutOfSync status. This ensures consistency across all sources.",
      "what_it_does": "Shows the application sync and health status.",
      "next_step": "Verify the updated content is served."
    },
    {
      "name": "Step 8: Verify Updated Content",
      "command": "kubectl exec -n argocd-sc-08 $(kubectl get pods -n argocd-sc-08 -l app=multi-source-app -o jsonpath='{.items[0].metadata.name}') -- cat /usr/share/nginx/html/index.html",
      "description": "Verify the updated content from secondary source is live",
      "explanation": "The pods mount the ConfigMap as a volume. After the ConfigMap update, the content served by nginx reflects the change from the secondary source. In production, both sources are reconciled.",
      "what_it_does": "Shows the updated content being served by the application.",
      "next_step": "Scenario complete! Clean up when ready."
    },
    {
      "name": "Cleanup: Delete Application",
      "command": "kubectl delete application sc08-multi-source -n argocd 2>/dev/null; kubectl delete namespace argocd-sc-08 --ignore-not-found",
      "description": "Remove all resources from this scenario",
      "explanation": "Removes the ArgoCD Application and the namespace with all resources.",
      "what_it_does": "Cleans up all multi-source scenario resources.",
      "next_step": "Cleanup complete!",
      "cleanup": true
    }
  ]
}
