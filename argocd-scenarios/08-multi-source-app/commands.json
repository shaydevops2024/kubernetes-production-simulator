{
  "scenario_id": "08-multi-source-app",
  "difficulty": "hard",
  "duration": "20 min",
  "commands": [
    {
      "name": "Step 1: Understand Multi-Source Pattern",
      "command": "cat argocd-scenarios/08-multi-source-app/manifests/deployment.yaml",
      "description": "Learn why multi-source applications are used in production",
      "explanation": "Multi-source applications let different teams own different parts of the deployment. The infra team manages deployments/services while the app team manages configs. ArgoCD combines them into a single application.",
      "what_it_does": "Explains the multi-source pattern and shows the deployment manifest.",
      "next_step": "Review the secondary source (ConfigMap)."
    },
    {
      "name": "Step 2: Review ConfigMap (Secondary Source)",
      "command": "cat argocd-scenarios/08-multi-source-app/manifests/configmap.yaml",
      "description": "Review the ConfigMap that represents a secondary source",
      "explanation": "In a real multi-source setup, this ConfigMap would come from a different Git repository. It provides the content that the deployment's pods mount. Changes to either source trigger a sync.",
      "what_it_does": "Shows the ConfigMap manifest (secondary source).",
      "next_step": "Create the namespace and deploy both sources."
    },
    {
      "name": "Step 3: Create Namespace",
      "command": "kubectl create namespace argocd-sc-08 --dry-run=client -o yaml | kubectl apply -f -",
      "description": "Create the namespace for this scenario",
      "explanation": "Creates the argocd-sc-08 namespace where all resources will be deployed.",
      "what_it_does": "Creates the namespace if it doesn't exist.",
      "next_step": "Deploy the application via ArgoCD."
    },
    {
      "name": "Step 4: Deploy Manifests Directly (Simulating Multi-Source Sync)",
      "command": "kubectl apply -f argocd-scenarios/08-multi-source-app/manifests/ && kubectl get all -n argocd-sc-08",
      "description": "Apply all manifests directly, simulating what ArgoCD would pull from multiple Git sources",
      "explanation": "In a real multi-source setup, ArgoCD pulls from two separate Git repos and combines them into one Application. Here we apply the manifests directly since this is a local Kind cluster without a real Git remote. The application.yaml in this scenario is reference material showing how you would configure a real multi-source Application pointing to your own Git repos.",
      "what_it_does": "Deploys the deployment (primary source), service (primary source), and configmap (secondary source) to argocd-sc-08.",
      "next_step": "Verify all resources are deployed."
    },
    {
      "name": "Step 5: Verify Resources from Both Sources",
      "command": "kubectl get deployment,service -n argocd-sc-08 -l app=multi-source-app && kubectl get configmap -n argocd-sc-08 -l source=secondary",
      "description": "Verify resources from both primary and secondary sources",
      "explanation": "The deployment and service come from the 'primary' source, while the ConfigMap comes from the 'secondary' source. In ArgoCD UI, you can see all resources in the application tree regardless of their origin.",
      "what_it_does": "Lists resources grouped by their source label.",
      "next_step": "Update the secondary source to see how changes propagate."
    },
    {
      "name": "Step 6: Update Secondary Source (ConfigMap)",
      "command": "kubectl patch configmap multi-source-content -n argocd-sc-08 --type merge -p '{\"data\":{\"index.html\":\"<html><body><h1>Updated Content v2</h1><p>This content was updated from the secondary source.</p></body></html>\"}}'",
      "description": "Simulate a change in the secondary source repo",
      "explanation": "In production, a git push to the secondary repo would trigger this. ArgoCD detects the drift between desired state (Git) and live state (cluster). The application shows as OutOfSync.",
      "what_it_does": "Updates the ConfigMap to simulate a secondary source change.",
      "next_step": "Check ArgoCD sync status."
    },
    {
      "name": "Step 7: Check Live ConfigMap State",
      "command": "kubectl get configmap multi-source-content -n argocd-sc-08 -o jsonpath='{.data.index\\.html}'",
      "description": "Observe the live state of the secondary source ConfigMap after the patch",
      "explanation": "In a real ArgoCD multi-source setup, patching a resource directly like this creates drift â€” ArgoCD would detect the live state no longer matches Git and mark the app OutOfSync. It would then revert the change on the next sync. This is how GitOps enforces the Git repo as the single source of truth across all sources.",
      "what_it_does": "Shows the current content of the ConfigMap to confirm the patch from Step 6 took effect.",
      "next_step": "Verify the updated content is served by the pod."
    },
    {
      "name": "Step 8: Verify Updated Content",
      "command": "kubectl exec -n argocd-sc-08 $(kubectl get pods -n argocd-sc-08 -l app=multi-source-app -o jsonpath='{.items[0].metadata.name}') -- cat /usr/share/nginx/html/index.html",
      "description": "Verify the updated content from secondary source is live",
      "explanation": "The pods mount the ConfigMap as a volume. After the ConfigMap update, the content served by nginx reflects the change from the secondary source. In production, both sources are reconciled.",
      "what_it_does": "Shows the updated content being served by the application.",
      "next_step": "Scenario complete! Clean up when ready."
    },
    {
      "name": "Cleanup: Delete Application",
      "command": "kubectl delete namespace argocd-sc-08 --ignore-not-found",
      "description": "Remove all resources from this scenario",
      "explanation": "Removes the ArgoCD Application and the namespace with all resources.",
      "what_it_does": "Cleans up all multi-source scenario resources.",
      "next_step": "Cleanup complete!",
      "cleanup": true
    }
  ]
}
