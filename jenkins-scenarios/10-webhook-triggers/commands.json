{
  "scenario_id": "10-webhook-triggers",
  "difficulty": "medium",
  "duration": "15 min",
  "commands": [
    {
      "name": "Step 1: Understand Trigger Types",
      "command": "echo '=== Jenkins Build Trigger Types ===' && echo '' && echo '1. Webhook Triggers (Push-based - Recommended)' && echo '   - GitHub Webhook          → Instant build on push/PR' && echo '   - GitLab Webhook           → Instant build on push/MR' && echo '   - Bitbucket Webhook         → Instant build on push/PR' && echo '   - Generic Webhook Trigger   → Custom payload from any source' && echo '' && echo '2. SCM Polling (Pull-based - Fallback)' && echo '   - Periodically checks repo for changes' && echo '   - Higher latency (polling interval)' && echo '   - More load on SCM server' && echo '' && echo '3. Scheduled (Cron-based)' && echo '   - Build at fixed times (nightly, weekly)' && echo '   - Uses Jenkins cron syntax: H/15 * * * *' && echo '' && echo '4. Manual / Upstream' && echo '   - Triggered by user or another job' && echo '' && echo 'Best Practice: Use webhooks for instant feedback, SCM polling' && echo 'as fallback when webhooks are unreliable or behind firewalls.'",
      "description": "Overview of Jenkins build trigger mechanisms",
      "explanation": "Jenkins supports multiple ways to trigger builds. Webhooks are push-based - the SCM server notifies Jenkins immediately when changes occur, providing instant feedback. SCM polling is pull-based - Jenkins periodically checks the repository, introducing latency equal to the polling interval. Scheduled triggers use cron syntax for time-based builds. Understanding these options helps you design responsive CI/CD pipelines while balancing server load and network constraints.",
      "what_it_does": "Displays a categorized overview of all Jenkins build trigger types with recommendations for when to use each approach.",
      "next_step": "Review webhook configuration in a Jenkinsfile.",
      "type": "info"
    },
    {
      "name": "Step 2: Review Webhook Configuration",
      "command": "cat << 'JENKINSFILE'\n// === Declarative Pipeline with GitHub Webhook ===\npipeline {\n    agent any\n\n    triggers {\n        // GitHub push events trigger this pipeline automatically\n        githubPush()\n    }\n\n    stages {\n        stage('Build') {\n            steps {\n                echo \"Triggered by: ${env.GIT_BRANCH}\"\n                echo \"Commit: ${env.GIT_COMMIT}\"\n                echo \"Author: ${env.CHANGE_AUTHOR ?: 'N/A'}\"\n                sh 'make build'\n            }\n        }\n    }\n}\nJENKINSFILE\n\necho ''\necho '=== Jenkins Webhook Setup Steps ==='\necho ''\necho '1. Jenkins Side:'\necho '   - Install GitHub/GitLab plugin'\necho '   - Job Config > Build Triggers > \"GitHub hook trigger for GITScm polling\"'\necho '   - Or use triggers { githubPush() } in Jenkinsfile'\necho ''\necho '2. GitHub Side:'\necho '   - Repo Settings > Webhooks > Add webhook'\necho '   - Payload URL: https://jenkins.example.com/github-webhook/'\necho '   - Content type: application/json'\necho '   - Events: Push, Pull Request (select individually)'\necho '   - Secret: (shared secret for HMAC verification)'\necho ''\necho '3. Verify:'\necho '   - Push a commit and check Recent Deliveries tab in GitHub'\necho '   - Response should be 200 OK'",
      "description": "Examine webhook configuration for GitHub integration",
      "explanation": "Setting up webhooks requires configuration on both sides. In Jenkins, the GitHub plugin provides the 'githubPush()' trigger that listens for incoming webhook payloads. On GitHub, you create a webhook pointing to Jenkins' /github-webhook/ endpoint. The shared secret enables HMAC signature verification, ensuring that only legitimate GitHub payloads trigger builds. Environment variables like GIT_BRANCH, GIT_COMMIT, and CHANGE_AUTHOR are automatically populated from the webhook payload, providing context about what triggered the build.",
      "what_it_does": "Displays a Jenkinsfile with GitHub webhook trigger and step-by-step setup instructions for both Jenkins and GitHub sides.",
      "next_step": "Examine a GitHub webhook payload."
    },
    {
      "name": "Step 3: Show GitHub Webhook Payload",
      "command": "cat << 'PAYLOAD'\n{\n  \"ref\": \"refs/heads/main\",\n  \"before\": \"a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2\",\n  \"after\": \"f6e5d4c3b2a1f6e5d4c3b2a1f6e5d4c3b2a1f6e5\",\n  \"repository\": {\n    \"full_name\": \"myorg/myapp\",\n    \"clone_url\": \"https://github.com/myorg/myapp.git\"\n  },\n  \"pusher\": {\n    \"name\": \"developer1\",\n    \"email\": \"dev1@example.com\"\n  },\n  \"head_commit\": {\n    \"id\": \"f6e5d4c3b2a1f6e5d4c3b2a1f6e5d4c3b2a1f6e5\",\n    \"message\": \"feat: add user authentication endpoint\",\n    \"timestamp\": \"2025-01-15T14:30:00Z\",\n    \"author\": { \"name\": \"developer1\" },\n    \"added\": [\"src/auth/handler.go\"],\n    \"modified\": [\"src/main.go\", \"go.mod\"],\n    \"removed\": []\n  },\n  \"commits\": [\n    { \"id\": \"f6e5d4...\", \"message\": \"feat: add user authentication endpoint\" }\n  ]\n}\nPAYLOAD\n\necho ''\necho '=== Key Fields Jenkins Extracts ==='\necho 'ref          → Branch that was pushed to (triggers branch filtering)'\necho 'after        → New HEAD commit SHA (set as GIT_COMMIT)'\necho 'repository   → Clone URL for checkout'\necho 'head_commit  → Latest commit details for changelog'\necho 'pusher       → Who triggered the build (audit trail)'",
      "description": "Examine a GitHub push webhook payload structure",
      "explanation": "When GitHub sends a webhook, it delivers a JSON payload containing everything Jenkins needs to process the build. The 'ref' field determines which branch was pushed to - Jenkins uses this for branch filtering in multibranch pipelines. The 'after' field becomes the GIT_COMMIT environment variable. The 'head_commit' provides the commit message for changelogs. Understanding this payload structure helps you debug webhook issues and configure advanced filtering based on branches, files changed, or commit messages.",
      "what_it_does": "Displays a sample GitHub push webhook JSON payload with annotations explaining which fields Jenkins uses and why.",
      "next_step": "Configure SCM polling as a fallback."
    },
    {
      "name": "Step 4: Configure SCM Polling as Fallback",
      "command": "cat << 'JENKINSFILE'\npipeline {\n    agent any\n\n    triggers {\n        // Primary: GitHub webhook\n        githubPush()\n\n        // Fallback: Poll SCM every 5 minutes\n        // H = hash-based offset to spread load across Jenkins\n        pollSCM('H/5 * * * *')\n    }\n\n    stages {\n        stage('Build') {\n            steps {\n                checkout scm\n                sh 'make build'\n            }\n        }\n    }\n}\nJENKINSFILE\n\necho ''\necho '=== Jenkins Cron Syntax ==='\necho 'MINUTE HOUR DOM MONTH DOW'\necho ''\necho 'Examples:'\necho '  H/5 * * * *     → Every 5 min (H spreads load)'\necho '  H/15 * * * *    → Every 15 min'\necho '  H 2 * * 1-5     → ~2 AM on weekdays'\necho '  @midnight        → Once per day'\necho ''\necho '=== Why Use H Instead of * ==='\necho 'H (hash) distributes jobs across the interval.'\necho '\"H/5\" means every 5 min but offset by a hash of the job name.'\necho 'This prevents all jobs from polling simultaneously at :00, :05, etc.'\necho 'Without H, 50 jobs polling at \"*/5\" all hit SCM at the same second.'",
      "description": "Set up SCM polling as a webhook fallback with Jenkins cron syntax",
      "explanation": "SCM polling is a reliable fallback when webhooks cannot reach Jenkins (firewalls, NAT, VPN). Jenkins' cron uses 'H' (hash) instead of '*' to distribute load - if 50 jobs all poll at '*/5', they all hit the SCM server simultaneously every 5 minutes. Using 'H/5' offsets each job by a hash of its name, spreading the load evenly. The tradeoff is latency: a 5-minute polling interval means up to 5 minutes delay between push and build. Combining both webhooks and polling provides instant feedback with guaranteed eventual consistency.",
      "what_it_does": "Displays a Jenkinsfile with both webhook and SCM polling triggers, plus an explanation of Jenkins cron syntax and the H hash symbol.",
      "next_step": "Explore the Generic Webhook Trigger plugin."
    },
    {
      "name": "Step 5: Show Generic Webhook Trigger Plugin",
      "command": "cat << 'JENKINSFILE'\n// === Generic Webhook Trigger - Works with ANY source ===\npipeline {\n    agent any\n\n    triggers {\n        GenericTrigger(\n            // Extract values from incoming JSON payload\n            genericVariables: [\n                [key: 'DEPLOY_ENV', value: '$.environment'],\n                [key: 'IMAGE_TAG', value: '$.image.tag'],\n                [key: 'REQUESTER', value: '$.triggered_by']\n            ],\n\n            // Only trigger if payload matches these conditions\n            regexpFilterText: '$DEPLOY_ENV',\n            regexpFilterExpression: '^(staging|production)$',\n\n            // Unique token to identify this job\n            token: 'deploy-myapp-token',\n\n            // Print debug info in build log\n            printContributedVariables: true,\n            printPostContent: true,\n\n            causeString: 'Triggered by $REQUESTER for $DEPLOY_ENV'\n        )\n    }\n\n    stages {\n        stage('Deploy') {\n            steps {\n                echo \"Deploying ${IMAGE_TAG} to ${DEPLOY_ENV}\"\n                echo \"Requested by: ${REQUESTER}\"\n            }\n        }\n    }\n}\nJENKINSFILE\n\necho ''\necho '=== Triggering with curl ==='\necho 'curl -X POST \"https://jenkins.example.com/generic-webhook-trigger/invoke?token=deploy-myapp-token\" \\'\necho '  -H \"Content-Type: application/json\" \\'\necho '  -d \\'{ \"environment\": \"staging\", \"image\": { \"tag\": \"v1.2.3\" }, \"triggered_by\": \"deploy-bot\" }\\''\necho ''\necho 'Use Cases: Slack bots, monitoring alerts, custom deploy tools,'\necho 'cross-system integration, ChatOps, scheduled external triggers'",
      "description": "Explore the Generic Webhook Trigger plugin for custom integrations",
      "explanation": "The Generic Webhook Trigger plugin accepts webhooks from any HTTP source, not just SCM providers. It uses JSONPath expressions to extract variables from the payload, regex filters to conditionally trigger builds, and tokens to route payloads to the correct job. This enables powerful integrations: a Slack bot can trigger deployments, a monitoring system can trigger rollbacks, or a custom UI can trigger builds with specific parameters. The token in the URL acts as both routing and basic authentication.",
      "what_it_does": "Displays a Jenkinsfile using the Generic Webhook Trigger plugin with JSONPath extraction, regex filtering, and a curl example for triggering builds.",
      "next_step": "Simulate a webhook-triggered build."
    },
    {
      "name": "Step 6: Simulate Webhook-Triggered Build",
      "command": "kubectl create namespace jenkins-scenarios --dry-run=client -o yaml | kubectl apply -f - && kubectl run webhook-receiver --image=busybox -n jenkins-scenarios --restart=Never -- sh -c '\necho \"=== Webhook Received ===\"\necho \"Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\necho \"Source: GitHub (push event)\"\necho \"Repository: myorg/myapp\"\necho \"Branch: refs/heads/main\"\necho \"Commit: f6e5d4c3b2a1\"\necho \"Author: developer1\"\necho \"Message: feat: add user authentication endpoint\"\necho \"\"\necho \"=== Build Pipeline Triggered ===\"\necho \"[Pipeline] Checkout SCM\"\necho \"  > git fetch --tags --force origin +refs/heads/main\"\necho \"  > git checkout -f f6e5d4c3b2a1\"\necho \"[Pipeline] Stage: Build\"\necho \"  > make build\"\necho \"  BUILD SUCCESSFUL in 45s\"\necho \"[Pipeline] Stage: Test\"\necho \"  > make test\"\necho \"  Tests: 142 passed, 0 failed\"\necho \"[Pipeline] Stage: Deploy to Staging\"\necho \"  > kubectl set image deployment/myapp app=myapp:f6e5d4c\"\necho \"  deployment.apps/myapp image updated\"\necho \"\"\necho \"=== Build Result ===\"\necho \"Status: SUCCESS\"\necho \"Duration: 3m 22s\"\necho \"Trigger: GitHub push by developer1\"\nsleep 300' && sleep 3 && kubectl logs webhook-receiver -n jenkins-scenarios",
      "description": "Simulate a complete webhook-triggered build pipeline execution",
      "explanation": "This simulation shows the full lifecycle of a webhook-triggered build: receiving the webhook payload, checking out the specific commit, running the build and test stages, and deploying to staging. In production, the entire flow from git push to deployment can complete in under 5 minutes, providing rapid feedback to developers. The build log captures the trigger source (GitHub push by developer1), enabling full audit trail of who triggered what and when.",
      "what_it_does": "Creates a pod that simulates receiving a GitHub webhook and executing a full CI/CD pipeline with checkout, build, test, and deploy stages.",
      "next_step": "Deploy a triggered build representation."
    },
    {
      "name": "Step 7: Deploy Triggered Build",
      "command": "kubectl run webhook-demo --image=nginx:alpine -n jenkins-scenarios --restart=Never --labels='app=webhook-demo,trigger=github-push,commit=f6e5d4c' -- sh -c 'echo \"Webhook-triggered deployment running\" && nginx -g \"daemon off;\"' && echo '' && echo '=== Deployment Details ===' && echo 'Pod: webhook-demo' && echo 'Image: nginx:alpine' && echo 'Trigger: github-push' && echo 'Commit: f6e5d4c' && echo '' && echo 'Labels applied for traceability:' && echo '  app=webhook-demo' && echo '  trigger=github-push' && echo '  commit=f6e5d4c' && echo '' && kubectl get pod webhook-demo -n jenkins-scenarios --show-labels",
      "description": "Deploy a pod representing a webhook-triggered build output",
      "explanation": "In a real CI/CD pipeline, the webhook trigger initiates a chain that ends with a deployment. Labels on the deployed pod provide traceability back to the trigger source and commit. This pattern - webhook trigger, build, test, deploy with metadata - forms the core of continuous delivery. The labels enable queries like 'which commit is running in production?' and 'was this deployment triggered automatically or manually?'",
      "what_it_does": "Creates an nginx pod with labels indicating it was deployed via a GitHub webhook trigger for a specific commit.",
      "next_step": "Verify all resources and review the summary."
    },
    {
      "name": "Step 8: Verify and Summary",
      "command": "echo '=== Scenario Resources ===' && kubectl get pods -n jenkins-scenarios -o wide && echo '' && echo '=== Webhook Triggers Summary ===' && echo '' && echo 'Trigger Types:' && echo '  githubPush()              → GitHub webhook integration' && echo '  GitLabPushTrigger()       → GitLab webhook integration' && echo '  pollSCM(\"H/5 * * * *\")   → SCM polling fallback' && echo '  GenericTrigger(...)       → Custom webhook from any source' && echo '' && echo 'Setup Checklist:' && echo '  [ ] Install SCM plugin (GitHub, GitLab, Bitbucket)' && echo '  [ ] Configure webhook URL in SCM provider' && echo '  [ ] Set shared secret for HMAC verification' && echo '  [ ] Add trigger block to Jenkinsfile' && echo '  [ ] Configure SCM polling as fallback' && echo '  [ ] Test with a push and verify delivery' && echo '' && echo 'Security:' && echo '  - Always use HMAC secret verification' && echo '  - Restrict webhook endpoints with IP allowlists' && echo '  - Use tokens for Generic Webhook Trigger' && echo '  - Audit webhook deliveries in SCM provider' && echo '' && echo 'Scenario complete! Proceed to cleanup.'",
      "description": "Verify resources and summarize webhook trigger concepts",
      "explanation": "This step confirms all demonstration resources are running and consolidates the key learnings. Webhook triggers are the backbone of modern CI/CD - they provide instant feedback, reduce SCM server load compared to polling, and enable integration with any system that can send HTTP requests. The security checklist is critical: without HMAC verification, anyone who discovers your Jenkins webhook URL could trigger arbitrary builds.",
      "what_it_does": "Lists all pods in the jenkins-scenarios namespace and displays a comprehensive summary of webhook trigger types, setup checklist, and security considerations.",
      "next_step": "Clean up all scenario resources."
    },
    {
      "name": "Cleanup: Remove All Resources",
      "command": "kubectl delete pod webhook-receiver webhook-demo -n jenkins-scenarios --ignore-not-found && echo '' && echo 'Cleanup complete. All webhook trigger demo resources removed.'",
      "description": "Remove all pods created during this scenario",
      "explanation": "Deletes the webhook-receiver and webhook-demo pods from the jenkins-scenarios namespace. The --ignore-not-found flag ensures the command succeeds even if pods were already deleted or failed to create.",
      "what_it_does": "Removes all demonstration pods from the jenkins-scenarios namespace.",
      "next_step": "Cleanup complete! Cleanup complete!",
      "cleanup": true
    }
  ]
}
