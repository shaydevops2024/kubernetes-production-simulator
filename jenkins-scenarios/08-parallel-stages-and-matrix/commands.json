{
  "scenario_id": "08-parallel-stages-and-matrix",
  "difficulty": "medium",
  "duration": "12 min",
  "commands": [
    {
      "name": "Step 1: Review Parallel Stage Syntax",
      "command": "echo '=== Jenkins Parallel Stages ==='\necho ''\necho 'Parallel stages run multiple branches of work simultaneously,'\necho 'reducing total pipeline time.'\necho ''\ncat << 'JENKINSFILE'\npipeline {\n    agent any\n\n    stages {\n        stage('Build') {\n            steps {\n                sh 'npm ci && npm run build'\n            }\n        }\n\n        stage('Tests') {\n            parallel {\n                stage('Unit Tests') {\n                    steps {\n                        sh 'npm run test:unit'\n                    }\n                }\n                stage('Integration Tests') {\n                    steps {\n                        sh 'npm run test:integration'\n                    }\n                }\n                stage('Lint & Security') {\n                    steps {\n                        sh 'npm run lint'\n                        sh 'npm audit --audit-level=high'\n                    }\n                }\n            }\n        }\n\n        stage('Deploy') {\n            steps {\n                sh 'kubectl apply -f k8s/ -n production'\n            }\n        }\n    }\n}\nJENKINSFILE\necho ''\necho 'The \"parallel\" block runs all nested stages at the same time.'\necho 'The pipeline only proceeds to Deploy when ALL parallel stages complete.'\necho 'If any parallel stage fails, the entire parallel block fails.'",
      "description": "Learn the syntax for running Jenkins pipeline stages in parallel",
      "explanation": "Parallel stages are defined inside a 'parallel' block within a parent stage. Each nested stage runs concurrently on available executors. The parent stage waits for all parallel branches to complete before the pipeline continues. This is ideal for independent tasks like running different test suites simultaneously.",
      "what_it_does": "Displays a complete Jenkinsfile showing parallel stage syntax where unit tests, integration tests, and linting run simultaneously after the build stage, with deployment only proceeding after all parallel stages pass.",
      "next_step": "Review the matrix directive for testing across multiple environments.",
      "cleanup": false
    },
    {
      "name": "Step 2: Review Matrix Directive",
      "command": "echo '=== Jenkins Matrix Directive ==='\necho ''\necho 'Matrix creates a combination of axes and runs stages for each combination.'\necho 'Think of it as a \"for each\" across multiple dimensions.'\necho ''\ncat << 'JENKINSFILE'\npipeline {\n    agent none\n\n    stages {\n        stage('Test Matrix') {\n            matrix {\n                axes {\n                    axis {\n                        name 'NODE_VERSION'\n                        values '16', '18', '20'\n                    }\n                    axis {\n                        name 'OS'\n                        values 'linux', 'windows'\n                    }\n                }\n                excludes {\n                    exclude {\n                        axis {\n                            name 'NODE_VERSION'\n                            values '16'\n                        }\n                        axis {\n                            name 'OS'\n                            values 'windows'\n                        }\n                    }\n                }\n                stages {\n                    stage('Test') {\n                        agent { label \"${OS}\" }\n                        steps {\n                            sh \"\"\"\n                                nvm use ${NODE_VERSION}\n                                npm ci\n                                npm test\n                            \"\"\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nJENKINSFILE\necho ''\necho 'This matrix generates 5 combinations (3x2 minus 1 exclusion):'\necho '  - Node 16 + Linux'\necho '  - Node 18 + Linux'\necho '  - Node 18 + Windows'\necho '  - Node 20 + Linux'\necho '  - Node 20 + Windows'\necho ''\necho '  (Node 16 + Windows is excluded)'\necho ''\necho 'All 5 combinations run in parallel by default.'",
      "description": "Learn the matrix directive for testing across multiple dimensions",
      "explanation": "The matrix directive is a powerful feature introduced in Jenkins Pipeline. It creates a Cartesian product of axis values and runs the defined stages for each combination. The 'excludes' block lets you skip specific combinations. This is invaluable for cross-platform testing, multi-version compatibility, and multi-browser testing.",
      "what_it_does": "Displays a Jenkinsfile using the matrix directive to test across 3 Node.js versions and 2 operating systems, with an exclusion rule, showing how 5 parallel test combinations are generated automatically.",
      "next_step": "Simulate parallel test execution to see the timing benefits.",
      "cleanup": false
    },
    {
      "name": "Step 3: Simulate Parallel Test Execution",
      "command": "kubectl create namespace jenkins-scenarios --dry-run=client -o yaml | kubectl apply -f - && \\\necho '=== Simulating Parallel Test Execution ===' && \\\necho '' && \\\necho 'Starting parallel stages at: '$(date '+%H:%M:%S') && \\\necho '' && \\\necho '  [Unit Tests]        Started  ......' && \\\necho '  [Integration Tests]  Started  ......' && \\\necho '  [Lint & Security]    Started  ......' && \\\necho '' && \\\nsleep 1 && \\\necho '  [Lint & Security]    PASSED   (12s)  -> 0 lint errors, 0 vulnerabilities' && \\\nsleep 1 && \\\necho '  [Unit Tests]         PASSED   (28s)  -> 234 tests, 0 failures, 2 skipped' && \\\nsleep 1 && \\\necho '  [Integration Tests]  PASSED   (45s)  -> 48 tests, 0 failures' && \\\necho '' && \\\necho 'All parallel stages completed at: '$(date '+%H:%M:%S') && \\\necho '' && \\\necho 'Results:' && \\\necho '  Unit Tests:        234 passed, 2 skipped, 0 failed' && \\\necho '  Integration Tests:  48 passed, 0 skipped, 0 failed' && \\\necho '  Lint:               0 errors, 3 warnings' && \\\necho '  Security Audit:     0 high/critical vulnerabilities' && \\\necho '' && \\\necho 'Total test time (parallel): 45 seconds (limited by slowest stage)' && \\\nkubectl create configmap parallel-test-results \\\n  --from-literal=unit-tests='234 passed, 0 failed' \\\n  --from-literal=integration-tests='48 passed, 0 failed' \\\n  --from-literal=lint='0 errors, 3 warnings' \\\n  --from-literal=security='0 vulnerabilities' \\\n  --from-literal=total-time='45s' \\\n  --from-literal=execution-mode='parallel' \\\n  -n jenkins-scenarios \\\n  --dry-run=client -o yaml | kubectl apply -f -",
      "description": "Simulate three test suites running in parallel and observe timing",
      "explanation": "In parallel execution, all three test suites start at the same time. The total wall-clock time equals the duration of the slowest stage (integration tests at 45s), not the sum of all stages. The faster stages (lint at 12s, unit tests at 28s) finish earlier and wait. This is the key benefit of parallel execution.",
      "what_it_does": "Simulates parallel execution of unit tests, integration tests, and lint/security stages, showing each completing at different times. Creates a ConfigMap recording the test results and total execution time.",
      "next_step": "Compare sequential vs parallel timing to see the time savings.",
      "cleanup": false
    },
    {
      "name": "Step 4: Show Timing Comparison (Sequential vs Parallel)",
      "command": "echo '=== Sequential vs Parallel: Timing Comparison ==='\necho ''\necho '--- Sequential Execution (traditional) ---'\necho ''\necho '  Unit Tests        |████████████████████████████|  28s'\necho '  Integration Tests  |                             ████████████████████████████████████████████████|  45s'\necho '  Lint & Security    |                                                                             ████████████|  12s'\necho '  ───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────'\necho '                     0s                                                                              Total: 85s'\necho ''\necho ''\necho '--- Parallel Execution (with parallel block) ---'\necho ''\necho '  Unit Tests        |████████████████████████████|  28s'\necho '  Integration Tests  |████████████████████████████████████████████████|  45s'\necho '  Lint & Security    |████████████|  12s'\necho '  ───────────────────┼─────────────────────────────────────────────────'\necho '                     0s                                    Total: 45s'\necho ''\necho ''\necho '=== Time Savings ==='\necho '  Sequential: 28 + 45 + 12 = 85 seconds'\necho '  Parallel:   max(28, 45, 12) = 45 seconds'\necho '  Savings:    40 seconds (47% faster!)'\necho ''\necho ''\necho '--- Matrix Execution (5 combinations) ---'\necho ''\necho '  Node16+Linux      |████████████████████████████████|  32s'\necho '  Node18+Linux      |██████████████████████████████████████|  38s'\necho '  Node18+Windows    |████████████████████████████████████████████████|  48s'\necho '  Node20+Linux      |██████████████████████████████|  30s'\necho '  Node20+Windows    |████████████████████████████████████████████|  43s'\necho '  ───────────────────┼─────────────────────────────────────────────────'\necho '                     0s                                    Total: 48s'\necho ''\necho '  Sequential total would be: 32+38+48+30+43 = 191 seconds'\necho '  Parallel total:  max(32,38,48,30,43) = 48 seconds'\necho '  Savings: 143 seconds (75% faster!)'",
      "description": "Visualize the timing difference between sequential and parallel execution",
      "explanation": "Sequential execution runs tests one after another, so total time is the sum of all durations. Parallel execution runs everything simultaneously, so total time equals the longest single stage. The more independent stages you have, the greater the time savings. Matrix builds benefit even more because they can have many combinations that would take extremely long sequentially.",
      "what_it_does": "Displays ASCII timeline charts comparing sequential execution (85s total), parallel execution (45s total), and matrix execution (48s vs 191s sequential), showing the percentage time savings for each approach.",
      "next_step": "Learn about the failFast option for early failure detection.",
      "cleanup": false
    },
    {
      "name": "Step 5: Demonstrate failFast Option",
      "command": "echo '=== failFast: Early Failure Detection ==='\necho ''\necho 'By default, parallel stages run to completion even if one fails.'\necho 'failFast stops all parallel branches when any one fails.'\necho ''\necho '--- Jenkinsfile with failFast ---'\ncat << 'EOF'\nstage('Tests') {\n    failFast true    // <-- Stop all branches on first failure\n    parallel {\n        stage('Unit Tests') {\n            steps { sh 'npm run test:unit' }\n        }\n        stage('Integration Tests') {\n            steps { sh 'npm run test:integration' }\n        }\n        stage('E2E Tests') {\n            steps { sh 'npm run test:e2e' }\n        }\n    }\n}\nEOF\necho ''\necho '--- Without failFast (default behavior) ---'\necho ''\necho '  [Unit Tests]         FAILED at 15s  (assertion error)'\necho '  [Integration Tests]  Still running... completed at 45s  PASSED'\necho '  [E2E Tests]          Still running... completed at 90s  PASSED'\necho '  Total time: 90s (wasted 75s after known failure)'\necho ''\necho '--- With failFast true ---'\necho ''\necho '  [Unit Tests]         FAILED at 15s  (assertion error)'\necho '  [Integration Tests]  ABORTED at 15s (failFast triggered)'\necho '  [E2E Tests]          ABORTED at 15s (failFast triggered)'\necho '  Total time: 15s (saved 75s!)'\necho ''\necho ''\necho 'For matrix builds, use failFast in the matrix block:'\ncat << 'EOF'\nstage('Cross-Platform Tests') {\n    matrix {\n        axes {\n            axis { name 'PLATFORM'; values 'linux', 'macos', 'windows' }\n        }\n        // Stop all matrix cells if any fail\n        failFast true\n        stages {\n            stage('Test') {\n                steps { sh './run-tests.sh' }\n            }\n        }\n    }\n}\nEOF\necho ''\necho 'Use failFast when: fast feedback is more important than'\necho 'knowing which other stages also fail.'\necho 'Skip failFast when: you want a complete test report.'",
      "description": "Learn how failFast aborts remaining parallel stages on first failure",
      "explanation": "The failFast option is crucial for pipeline efficiency. Without it, if unit tests fail at 15 seconds, integration and E2E tests continue running for another 75 seconds even though the pipeline will ultimately fail. With failFast, all branches abort immediately when one fails, saving time and compute resources. The tradeoff is that you only learn about the first failure, not all failures.",
      "what_it_does": "Explains the failFast option with Jenkinsfile syntax, then shows a side-by-side comparison of pipeline behavior with and without failFast, demonstrating 75 seconds saved on a failed pipeline.",
      "next_step": "Deploy an application after parallel tests pass.",
      "cleanup": false
    },
    {
      "name": "Step 6: Deploy After Parallel Tests Pass",
      "command": "echo '=== Post-Parallel Deploy Simulation ===' && \\\necho '' && \\\necho '[Stage: Build]' && \\\necho '  -> npm ci && npm run build' && \\\necho '  -> Build complete (8s)' && \\\necho '' && \\\necho '[Stage: Tests (parallel)]' && \\\necho '  -> Unit Tests:        234 passed  (28s)' && \\\necho '  -> Integration Tests:  48 passed  (45s)' && \\\necho '  -> Lint & Security:    Clean     (12s)' && \\\necho '  -> All parallel stages PASSED (45s total)' && \\\necho '' && \\\necho '[Stage: Deploy]' && \\\necho '  -> All tests passed, proceeding to deployment...' && \\\nkubectl create configmap parallel-deploy-info \\\n  --from-literal=app-name='my-app' \\\n  --from-literal=test-status='all-passed' \\\n  --from-literal=parallel-stages='unit,integration,lint' \\\n  --from-literal=deploy-status='success' \\\n  --from-literal=total-pipeline-time='58s' \\\n  --from-literal=time-saved-vs-sequential='40s' \\\n  -n jenkins-scenarios \\\n  --dry-run=client -o yaml | kubectl apply -f - && \\\necho '  -> Deployment updated: my-app:42 -> production' && \\\necho '  -> Rollout: 3/3 replicas ready' && \\\necho '' && \\\necho '[Pipeline Complete]' && \\\necho '  Total time: 58s (Build: 8s + Tests: 45s + Deploy: 5s)' && \\\necho '  Without parallel: 98s (Build: 8s + Tests: 85s + Deploy: 5s)' && \\\necho '  Time saved: 40 seconds per pipeline run' && \\\necho '' && \\\necho '  At 20 builds/day = 800 seconds saved = 13+ minutes/day'",
      "description": "Simulate a complete pipeline with parallel tests followed by deployment",
      "explanation": "This simulation shows the full pipeline flow: build, then parallel tests, then deploy. The deploy stage only runs after ALL parallel test stages pass. The time savings compound significantly when you consider how many times a day the pipeline runs. At 20 builds per day, 40 seconds saved per build means over 13 minutes of developer wait time saved daily.",
      "what_it_does": "Simulates the complete pipeline execution with parallel tests followed by deployment, creates a ConfigMap with pipeline metrics, and calculates daily time savings based on typical build frequency.",
      "next_step": "Verify all the pipeline resources.",
      "cleanup": false
    },
    {
      "name": "Step 7: Verify Pipeline Resources",
      "command": "echo '=== Parallel Stages Pipeline Verification ==='\necho ''\necho 'Test Results:'\nkubectl get configmap parallel-test-results -n jenkins-scenarios -o jsonpath='{.data}' | tr ',' '\\n' | tr -d '{}\"'\necho ''\necho ''\necho 'Deployment Info:'\nkubectl get configmap parallel-deploy-info -n jenkins-scenarios -o jsonpath='{.data}' | tr ',' '\\n' | tr -d '{}\"'\necho ''\necho ''\necho 'All ConfigMaps in jenkins-scenarios:'\nkubectl get configmaps -n jenkins-scenarios --no-headers\necho ''\necho 'Pipeline efficiency metrics:'\necho '  Parallel execution:   45s (3 stages)'\necho '  Sequential equivalent: 85s (3 stages)'\necho '  Efficiency gain:       47%'\necho '  Matrix (5 combos):     48s parallel vs 191s sequential'\necho '  Matrix efficiency:     75%'",
      "description": "Verify all pipeline resources and review efficiency metrics",
      "explanation": "Verification confirms that all pipeline stages completed successfully and the deployment metadata is recorded correctly. The efficiency metrics show the concrete time savings from parallel execution, both for simple parallel stages and more complex matrix builds.",
      "what_it_does": "Displays test results and deployment info from ConfigMaps, lists all resources in the namespace, and summarizes pipeline efficiency metrics comparing parallel and sequential execution.",
      "next_step": "Review the scenario summary.",
      "cleanup": false
    },
    {
      "name": "Step 8: Scenario Summary",
      "command": "echo '╔══════════════════════════════════════════════════════════════╗'\necho '║      Parallel Stages & Matrix - Key Takeaways               ║'\necho '╠══════════════════════════════════════════════════════════════╣'\necho '║                                                            ║'\necho '║  1. Parallel Stages:                                       ║'\necho '║     -> Wrap independent stages in parallel { }             ║'\necho '║     -> Total time = slowest stage (not sum of all)         ║'\necho '║     -> Pipeline waits for all branches before continuing   ║'\necho '║                                                            ║'\necho '║  2. Matrix Directive:                                      ║'\necho '║     -> Define axes (versions, OSes, browsers, etc.)        ║'\necho '║     -> Automatically generates all combinations            ║'\necho '║     -> Use excludes {} to skip specific combos             ║'\necho '║     -> All combinations run in parallel by default         ║'\necho '║                                                            ║'\necho '║  3. failFast:                                              ║'\necho '║     -> Abort all branches on first failure                 ║'\necho '║     -> Saves time but hides other failures                 ║'\necho '║     -> Use for fast feedback; skip for full reports         ║'\necho '║                                                            ║'\necho '║  4. When to Use Parallel:                                  ║'\necho '║     -> Independent test suites (unit, integration, e2e)    ║'\necho '║     -> Multi-platform/multi-version testing                ║'\necho '║     -> Static analysis alongside test execution            ║'\necho '║     -> NOT for stages that depend on each other            ║'\necho '║                                                            ║'\necho '║  5. Resource Consideration:                                ║'\necho '║     -> Each parallel branch needs an executor              ║'\necho '║     -> Too many parallels can starve other pipelines       ║'\necho '║     -> Balance parallelism with available agents           ║'\necho '║                                                            ║'\necho '╚══════════════════════════════════════════════════════════════╝'",
      "description": "Review the key concepts learned about parallel stages and matrix builds",
      "explanation": "Parallel stages and matrix builds are essential for efficient CI/CD pipelines. They dramatically reduce pipeline duration by running independent work concurrently. However, they require careful resource planning -- each parallel branch consumes an executor. The matrix directive is particularly powerful for cross-platform and multi-version testing.",
      "what_it_does": "Displays a formatted summary of all key concepts including parallel stage syntax, matrix directive usage, failFast behavior, appropriate use cases, and resource considerations.",
      "next_step": "Clean up all resources created during this scenario.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo 'Cleaning up Parallel Stages & Matrix scenario resources...'\nkubectl delete configmap parallel-test-results parallel-deploy-info -n jenkins-scenarios --ignore-not-found\necho ''\necho 'All Parallel Stages & Matrix scenario resources have been removed.'\necho 'The jenkins-scenarios namespace is preserved for other scenarios.'",
      "description": "Remove all resources created during this scenario",
      "explanation": "Cleanup removes the ConfigMaps created during the scenario. The jenkins-scenarios namespace is preserved since other Jenkins scenarios may use it.",
      "what_it_does": "Deletes the parallel-test-results and parallel-deploy-info ConfigMaps from the jenkins-scenarios namespace.",
      "next_step": "Scenario complete! You now understand how to use parallel stages and matrix builds to optimize Jenkins pipeline performance.",
      "cleanup": true
    }
  ]
}
