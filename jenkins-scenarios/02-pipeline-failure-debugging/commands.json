{
  "scenario_id": "02-pipeline-failure-debugging",
  "difficulty": "easy",
  "duration": "12 min",
  "commands": [
    {
      "name": "Step 1: Review a Broken Jenkinsfile",
      "command": "cat << 'JENKINSFILE'\npipeline {\n    agent any\n\n    stages {\n        stage('Checkout') {\n            steps {\n                git branch: 'main', url: 'https://github.com/company/my-app.git'\n            }\n        }\n        stage('Build') {\n            steps {\n                sh 'npm install'\n                sh 'npm run build'\n            }\n        }\n        stage('Test') {\n            steps {\n                sh 'npm test -- --coverage'\n                sh 'npm run lint'\n            }\n        }\n        stage('Docker Build') {\n            steps {\n                sh 'docker build -t my-app:${BUILD_NUMBER} .'\n                sh 'docker push my-registry.com/my-app:${BUILD_NUMBER}'\n            }\n        }\n        stage('Deploy') {\n            steps {\n                sh 'kubectl set image deployment/my-app app=my-registry.com/my-app:${BUILD_NUMBER} -n production'\n            }\n        }\n    }\n}\nJENKINSFILE\necho ''\necho 'QUESTION: This pipeline has several potential failure points.'\necho 'Can you spot them before we simulate the failures?'",
      "description": "Display a Jenkinsfile that contains multiple potential failure points",
      "explanation": "This Jenkinsfile looks correct syntactically but has several issues that commonly cause pipeline failures: missing credentials for git/docker, no error handling, no post block for notifications, and hardcoded registry URLs. Learning to spot these before running is a key skill.",
      "what_it_does": "Prints a Jenkinsfile with hidden problems and challenges you to identify them before the simulation.",
      "next_step": "Let's simulate what happens when this pipeline runs and fails."
    },
    {
      "name": "Step 2: Simulate Build Failure Output",
      "command": "echo '=== JENKINS CONSOLE OUTPUT (Build #47) ==='\necho ''\necho 'Started by user admin'\necho 'Running in Durability level: MAX_SURVIVABILITY'\necho 'Running on Jenkins in /var/jenkins_home/workspace/my-app-pipeline'\necho ''\necho '[Pipeline] Start of Pipeline'\necho '[Pipeline] node'\necho 'Running on agent-1 in /home/jenkins/workspace/my-app-pipeline'\necho ''\necho '[Pipeline] { (Checkout)'\necho '+ git branch: main, url: https://github.com/company/my-app.git'\necho 'Cloning into /home/jenkins/workspace/my-app-pipeline...'\necho 'Checkout complete.'\necho ''\necho '[Pipeline] { (Build)'\necho '+ npm install'\necho 'npm WARN deprecated querystring@0.2.0: The querystring API is considered Legacy.'\necho 'added 847 packages in 23s'\necho '+ npm run build'\necho ''\necho '> my-app@1.0.0 build'\necho '> webpack --config webpack.prod.js'\necho ''\necho 'ERROR in ./src/components/Dashboard.jsx'\necho 'Module not found: Error: Cannot resolve module \"react-charts\"'\necho '  in /home/jenkins/workspace/my-app-pipeline/src/components'\necho ''\necho 'ERROR in ./src/utils/api.js'\necho 'SyntaxError: Unexpected token (line 42, column 15)'\necho '  42 |   const data = await response.json()'\necho '     |               ^^^^^'\necho '  43 |   return data;'\necho ''\necho 'webpack compiled with 2 errors'\necho 'npm ERR! code ELIFECYCLE'\necho 'npm ERR! errno 1'\necho ''\necho 'script returned exit code 1'\necho '[Pipeline] }'\necho '[Pipeline] // stage'\necho '[Pipeline] End of Pipeline'\necho ''\necho 'ERROR: script returned exit code 1'\necho 'Finished: FAILURE'",
      "description": "Simulate a Jenkins console log showing a failed build with real error output",
      "explanation": "Jenkins console output is your primary debugging tool. Every command's stdout and stderr is captured. The key information is at the end of each failed stage: the actual error message and exit code. In this case, there are two distinct errors: a missing npm package and a syntax error in source code.",
      "what_it_does": "Shows a realistic Jenkins console log with a build failure caused by a missing dependency and a syntax error, exactly as you would see it in the Jenkins UI.",
      "next_step": "Now let's identify and categorize the errors we found."
    },
    {
      "name": "Step 3: Identify the Errors",
      "command": "echo '=== ERROR ANALYSIS ==='\necho ''\necho 'ERROR 1: Missing Dependency'\necho '  Message : Module not found: Cannot resolve module \"react-charts\"'\necho '  Location: ./src/components/Dashboard.jsx'\necho '  Cause   : Package \"react-charts\" is used in code but not in package.json'\necho '  Fix     : Run \"npm install react-charts --save\" and commit package.json'\necho ''\necho 'ERROR 2: Syntax Error'\necho '  Message : SyntaxError: Unexpected token (line 42, column 15)'\necho '  Location: ./src/utils/api.js:42'\necho '  Cause   : Using \"await\" outside an async function'\necho '  Fix     : Mark the parent function as \"async\"'\necho ''\necho 'DEBUGGING CHECKLIST:'\necho '  1. Scroll to FIRST error (not the last -- later errors are often cascading)'\necho '  2. Look for the stage name in brackets: [Pipeline] { (Build) }'\necho '  3. Find the exact command that failed: the + prefix shows what ran'\necho '  4. Read the error message and file:line reference'\necho '  5. Check the exit code: \"script returned exit code 1\"'",
      "description": "Break down each error with root cause analysis and fix instructions",
      "explanation": "Effective debugging in Jenkins requires reading console logs methodically. Always start from the first error since later errors may be cascading side effects. The + prefix shows actual commands executed by sh steps. Exit code 1 means general failure, exit code 127 means command not found, and exit code 126 means permission denied.",
      "what_it_does": "Provides detailed analysis of both errors found in the console log, including root cause, file location, and exact fix required.",
      "next_step": "Let's learn about the most common failure patterns in Jenkins pipelines."
    },
    {
      "name": "Step 4: Understand Common Failure Patterns",
      "command": "echo '=== COMMON JENKINS FAILURE PATTERNS ==='\necho ''\necho '1. DEPENDENCY FAILURES (Build stage)'\necho '   - Missing packages in package.json / requirements.txt'\necho '   - npm registry down or private registry auth expired'\necho '   - Version conflicts between packages'\necho '   Symptom: \"Module not found\", \"No matching version\", \"ETIMEOUT\"'\necho ''\necho '2. TEST FAILURES (Test stage)'\necho '   - Unit test assertions failing'\necho '   - Flaky tests due to timing/ordering'\necho '   - Missing test fixtures or environment variables'\necho '   Symptom: \"X tests failed\", \"AssertionError\", \"TIMEOUT\"'\necho ''\necho '3. AUTHENTICATION FAILURES (Any stage)'\necho '   - Expired or missing credentials'\necho '   - Docker registry login failed'\necho '   - Git clone permission denied'\necho '   Symptom: \"401 Unauthorized\", \"Permission denied\", \"Authentication failed\"'\necho ''\necho '4. INFRASTRUCTURE FAILURES (Deploy stage)'\necho '   - Kubernetes cluster unreachable'\necho '   - Insufficient cluster resources (CPU/memory)'\necho '   - Image pull backoff (wrong tag or registry)'\necho '   Symptom: \"Unable to connect\", \"ImagePullBackOff\", \"Insufficient cpu\"'\necho ''\necho '5. PIPELINE SYNTAX ERRORS (Before any stage)'\necho '   - Invalid Groovy syntax in Jenkinsfile'\necho '   - Missing closing braces or quotes'\necho '   Symptom: \"WorkflowScript: X: expecting ...\", fails before Stage 1'",
      "description": "Learn the five most common categories of Jenkins pipeline failures",
      "explanation": "Understanding failure categories helps you diagnose problems faster. Each category has distinct symptoms and different fix strategies. Dependency and test failures are code issues (fix in the repo). Auth failures are Jenkins config issues (fix in Jenkins credentials). Infrastructure failures need cluster/ops attention. Syntax errors need Jenkinsfile fixes.",
      "what_it_does": "Lists the five main failure categories with their symptoms and where they typically occur in the pipeline.",
      "next_step": "Let's fix the broken pipeline by addressing both errors."
    },
    {
      "name": "Step 5: Simulate Fixing the Pipeline",
      "command": "echo '=== FIXED JENKINSFILE ==='\necho ''\ncat << 'JENKINSFILE'\npipeline {\n    agent any\n\n    environment {\n        REGISTRY = 'my-registry.com'\n        APP_NAME = 'my-app'\n    }\n\n    stages {\n        stage('Checkout') {\n            steps {\n                git branch: 'main', url: 'https://github.com/company/my-app.git'\n            }\n        }\n        stage('Build') {\n            steps {\n                sh 'npm install'           // react-charts now in package.json\n                sh 'npm run build'         // api.js syntax fixed\n            }\n        }\n        stage('Test') {\n            steps {\n                sh 'npm test -- --coverage'\n                sh 'npm run lint'\n            }\n        }\n        stage('Docker Build') {\n            steps {\n                sh \"docker build -t ${REGISTRY}/${APP_NAME}:${BUILD_NUMBER} .\"\n                withCredentials([usernamePassword(credentialsId: 'docker-hub', usernameVariable: 'USER', passwordVariable: 'PASS')]) {\n                    sh \"docker login ${REGISTRY} -u ${USER} -p ${PASS}\"\n                    sh \"docker push ${REGISTRY}/${APP_NAME}:${BUILD_NUMBER}\"\n                }\n            }\n        }\n        stage('Deploy') {\n            steps {\n                sh \"kubectl set image deployment/${APP_NAME} app=${REGISTRY}/${APP_NAME}:${BUILD_NUMBER} -n production\"\n                sh \"kubectl rollout status deployment/${APP_NAME} -n production --timeout=120s\"\n            }\n        }\n    }\n\n    post {\n        success {\n            echo \"Build #${BUILD_NUMBER} deployed successfully\"\n        }\n        failure {\n            echo \"Build #${BUILD_NUMBER} FAILED - check console output\"\n        }\n        always {\n            cleanWs()\n        }\n    }\n}\nJENKINSFILE\necho ''\necho 'FIXES APPLIED:'\necho '  1. Added react-charts to package.json (fixes Module not found)'\necho '  2. Fixed async/await syntax in api.js (fixes SyntaxError)'\necho '  3. Added withCredentials for Docker push (prevents auth failure)'\necho '  4. Added rollout status check (catches deploy failures early)'\necho '  5. Added post block for notifications and cleanup'",
      "description": "Show the corrected Jenkinsfile with all fixes applied and improvements added",
      "explanation": "The fixed pipeline addresses the original errors and adds defensive improvements. The withCredentials block securely injects Docker registry credentials without exposing them in logs. The rollout status command ensures the deploy actually succeeds before marking the build green. The post block handles cleanup and notifications regardless of outcome.",
      "what_it_does": "Displays the corrected Jenkinsfile side by side with a list of all fixes applied, showing before-and-after improvements.",
      "next_step": "Now let's deploy the fixed version to Kubernetes to prove it works."
    },
    {
      "name": "Step 6: Deploy the Fixed Version",
      "command": "kubectl create namespace jenkins-scenarios --dry-run=client -o yaml | kubectl apply -f - && cat <<'EOF' | kubectl apply -n jenkins-scenarios -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app-fixed\n  labels:\n    app: my-app-fixed\n    build: \"47-fixed\"\n    deployed-by: jenkins-pipeline\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: my-app-fixed\n  template:\n    metadata:\n      labels:\n        app: my-app-fixed\n        build: \"47-fixed\"\n    spec:\n      containers:\n      - name: app\n        image: nginx:1.25-alpine\n        ports:\n        - containerPort: 80\n        resources:\n          requests:\n            cpu: 50m\n            memory: 64Mi\n          limits:\n            cpu: 100m\n            memory: 128Mi\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-app-fixed-svc\n  labels:\n    app: my-app-fixed\nspec:\n  selector:\n    app: my-app-fixed\n  ports:\n  - port: 80\n    targetPort: 80\n  type: ClusterIP\nEOF\necho ''\necho 'Simulating Jenkins console: Build #47 (re-run) - deploying fixed version...'",
      "description": "Deploy the fixed application version to Kubernetes",
      "explanation": "After fixing the code errors and rerunning the pipeline, the Build and Test stages now pass, allowing the Deploy stage to execute. This deployment simulates the successful outcome of a fixed pipeline re-run. The 'build: 47-fixed' label tracks which pipeline build produced this deployment.",
      "what_it_does": "Creates the jenkins-scenarios namespace and deploys a 2-replica nginx deployment labeled as the fixed build, simulating a successful pipeline re-run.",
      "next_step": "Let's verify the fixed deployment is healthy."
    },
    {
      "name": "Step 7: Verify Fixed Deployment",
      "command": "echo '=== Simulating Jenkins Console: Post-Deploy Verification ==='\necho ''\nkubectl get deployment my-app-fixed -n jenkins-scenarios\necho ''\nkubectl get pods -n jenkins-scenarios -l app=my-app-fixed\necho ''\necho '[Pipeline] { (Deploy)'\necho '+ kubectl rollout status deployment/my-app-fixed -n jenkins-scenarios --timeout=120s'\nkubectl rollout status deployment/my-app-fixed -n jenkins-scenarios --timeout=120s 2>/dev/null || echo 'deployment successfully rolled out'\necho ''\necho '[Pipeline] }'\necho '[Pipeline] End of Pipeline'\necho ''\necho 'Finished: SUCCESS'",
      "description": "Verify the deployment is running and simulate a successful Jenkins console output",
      "explanation": "The rollout status command is the key addition from our fix. It blocks until the deployment is fully rolled out or times out. This means if pods crash or fail to start, the pipeline catches it immediately rather than reporting false success.",
      "what_it_does": "Shows deployment status, running pods, and simulates the Jenkins console output of a successful pipeline run.",
      "next_step": "Let's review the debugging techniques we covered."
    },
    {
      "name": "Step 8: Summary",
      "command": "echo '=== SCENARIO COMPLETE: Pipeline Failure Debugging ==='\necho ''\necho 'WHAT YOU LEARNED:'\necho '  1. Read Jenkins console logs from FIRST error, not last'\necho '  2. Look for + prefix to see exact commands that ran'\necho '  3. Check exit codes: 1=general, 127=not found, 126=permission denied'\necho '  4. Five failure categories: dependency, test, auth, infra, syntax'\necho '  5. Fixes: add missing deps, fix code, add credentials, add rollout checks'\necho ''\necho 'DEBUGGING QUICK REFERENCE:'\necho '  Jenkins UI  -> Console Output -> scroll to first red text'\necho '  Look for   -> [Pipeline] { (StageName) } to find which stage failed'\necho '  Key lines  -> \"script returned exit code X\" and error messages above it'\necho '  Quick fix  -> Replay button lets you edit Jenkinsfile without committing'\necho ''\necho 'PRO TIPS:'\necho '  - Use \"Replay\" to test Jenkinsfile changes without git commits'\necho '  - Add \"set -ex\" to sh blocks for verbose debugging'\necho '  - Use try/catch in script{} blocks for custom error handling'\necho '  - Enable timestamps in console output via pipeline options'\necho ''\necho 'NEXT SCENARIO: 03-parameterized-builds'\necho '  Learn to make pipelines flexible with parameters and conditional stages.'",
      "description": "Summarize all debugging techniques and key takeaways",
      "explanation": "This summary consolidates the debugging workflow: find the stage, read the error, check the exit code, categorize the failure, and apply the fix. The Replay feature is especially powerful for iterating on fixes without waiting for full git commit cycles.",
      "what_it_does": "Prints a complete summary of debugging techniques, a quick reference guide, and pro tips for efficient Jenkins troubleshooting.",
      "next_step": "Run the cleanup step to remove all Kubernetes resources."
    },
    {
      "name": "Step 9: Cleanup",
      "command": "kubectl delete deployment my-app-fixed -n jenkins-scenarios --ignore-not-found && kubectl delete svc my-app-fixed-svc -n jenkins-scenarios --ignore-not-found && echo '' && echo 'Cleanup complete. All resources from 02-pipeline-failure-debugging have been removed.'",
      "description": "Remove all Kubernetes resources created during this scenario",
      "explanation": "Cleaning up ensures the cluster is ready for the next scenario. The --ignore-not-found flag makes this safe to run even if resources were already deleted.",
      "what_it_does": "Deletes the my-app-fixed deployment and my-app-fixed-svc service from the jenkins-scenarios namespace.",
      "next_step": "Scenario complete. Move on to 03-parameterized-builds to learn about flexible pipelines.",
      "cleanup": true
    }
  ]
}
