{
  "scenario_id": "03-parameterized-builds",
  "difficulty": "easy",
  "duration": "10 min",
  "commands": [
    {
      "name": "Step 1: Review Parameterized Jenkinsfile",
      "command": "cat << 'JENKINSFILE'\npipeline {\n    agent any\n\n    parameters {\n        choice(\n            name: 'ENVIRONMENT',\n            choices: ['dev', 'staging', 'production'],\n            description: 'Target deployment environment'\n        )\n        string(\n            name: 'IMAGE_TAG',\n            defaultValue: 'latest',\n            description: 'Docker image tag to deploy'\n        )\n        booleanParam(\n            name: 'RUN_TESTS',\n            defaultValue: true,\n            description: 'Run test suite before deploying'\n        )\n        booleanParam(\n            name: 'FORCE_DEPLOY',\n            defaultValue: false,\n            description: 'Skip approval gate for production'\n        )\n    }\n\n    stages {\n        stage('Build') {\n            steps {\n                echo \"Building for ${params.ENVIRONMENT} with tag ${params.IMAGE_TAG}\"\n                sh 'npm install && npm run build'\n            }\n        }\n        stage('Test') {\n            when {\n                expression { params.RUN_TESTS == true }\n            }\n            steps {\n                echo 'Running test suite...'\n                sh 'npm test'\n            }\n        }\n        stage('Approval') {\n            when {\n                allOf {\n                    expression { params.ENVIRONMENT == 'production' }\n                    expression { params.FORCE_DEPLOY == false }\n                }\n            }\n            steps {\n                input message: 'Deploy to production?', ok: 'Approve'\n            }\n        }\n        stage('Deploy') {\n            steps {\n                echo \"Deploying ${params.IMAGE_TAG} to ${params.ENVIRONMENT}\"\n                sh \"kubectl apply -f k8s/${params.ENVIRONMENT}/\"\n            }\n        }\n    }\n}\nJENKINSFILE",
      "description": "Display a Jenkinsfile that uses parameters, when conditions, and input steps",
      "explanation": "Parameterized pipelines let users provide input at build time, making one Jenkinsfile serve multiple purposes. The 'parameters' block defines a form in the Jenkins UI. Parameters are accessed via 'params.NAME' in the pipeline. The 'when' block conditionally skips stages based on parameter values.",
      "what_it_does": "Prints a complete parameterized Jenkinsfile showing choice, string, and boolean parameters combined with conditional stage execution.",
      "next_step": "Let's examine each parameter type in detail."
    },
    {
      "name": "Step 2: Understand Parameter Types",
      "command": "echo '=== JENKINS PARAMETER TYPES ==='\necho ''\necho '1. STRING PARAMETER'\necho '   string(name: \"BRANCH\", defaultValue: \"main\", description: \"Git branch\")'\necho '   -> Free-text input field in Jenkins UI'\necho '   -> Access: params.BRANCH'\necho ''\necho '2. CHOICE PARAMETER'\necho '   choice(name: \"ENV\", choices: [\"dev\", \"staging\", \"prod\"], description: \"...\")'\necho '   -> Dropdown menu -- user picks one option'\necho '   -> Access: params.ENV'\necho ''\necho '3. BOOLEAN PARAMETER'\necho '   booleanParam(name: \"DEBUG\", defaultValue: false, description: \"...\")'\necho '   -> Checkbox -- true/false toggle'\necho '   -> Access: params.DEBUG'\necho ''\necho '4. PASSWORD PARAMETER'\necho '   password(name: \"API_KEY\", defaultValue: \"\", description: \"...\")'\necho '   -> Masked input field -- hidden in logs'\necho '   -> Access: params.API_KEY'\necho ''\necho '5. TEXT PARAMETER (multi-line)'\necho '   text(name: \"CONFIG\", defaultValue: \"\", description: \"...\")'\necho '   -> Multi-line text area'\necho '   -> Access: params.CONFIG'\necho ''\necho 'IN THE JENKINS UI:'\necho '  Job page -> \"Build with Parameters\" button -> form with all params -> \"Build\"'\necho '  First build always uses default values (parameters are registered on first run)'",
      "description": "Explore all five Jenkins parameter types with syntax and usage examples",
      "explanation": "Jenkins supports five parameter types, each rendering as a different UI control. String and text are free-form input. Choice restricts to predefined options (safest for environments). Boolean is a simple toggle. Password masks input in the UI and logs. The first pipeline run always uses defaults because Jenkins needs to parse the Jenkinsfile to discover parameters.",
      "what_it_does": "Lists all parameter types with their Jenkinsfile syntax, UI rendering, and how to access values at runtime.",
      "next_step": "Now let's see how the when{} block uses parameters to control stage execution."
    },
    {
      "name": "Step 3: Understand Conditional When Blocks",
      "command": "echo '=== CONDITIONAL STAGE EXECUTION WITH when{} ==='\necho ''\necho 'The when{} block SKIPS a stage if its condition is false:'\necho ''\necho 'EXPRESSION-BASED (most flexible):'\necho '  when { expression { params.RUN_TESTS == true } }'\necho '  when { expression { env.BRANCH_NAME == \"main\" } }'\necho '  when { expression { currentBuild.result == null } }'\necho ''\necho 'BUILT-IN CONDITIONS:'\necho '  when { branch \"main\" }           // Only on main branch'\necho '  when { tag \"v*\" }                // Only on version tags'\necho '  when { environment name: \"ENV\", value: \"prod\" }'\necho '  when { changeset \"**/*.js\" }      // Only if JS files changed'\necho '  when { not { branch \"dev\" } }    // Negation'\necho ''\necho 'COMBINING CONDITIONS:'\necho '  when {'\necho '      allOf {                        // AND logic'\necho '          branch \"main\"'\necho '          expression { params.ENVIRONMENT == \"production\" }'\necho '      }'\necho '  }'\necho '  when {'\necho '      anyOf {                        // OR logic'\necho '          branch \"main\"'\necho '          branch \"release/*\"'\necho '      }'\necho '  }'\necho ''\necho 'BEHAVIOR: Skipped stages show as gray in Jenkins UI (not red/failed)'",
      "description": "Learn how when{} blocks conditionally skip or execute pipeline stages",
      "explanation": "The when{} directive is the gatekeeper for conditional logic in declarative pipelines. It evaluates before a stage runs and either allows or skips it. allOf requires ALL conditions to be true (AND), while anyOf requires at least one (OR). Skipped stages appear gray in the Jenkins UI, distinct from failed (red) or successful (green) stages.",
      "what_it_does": "Shows all forms of when{} conditions: expression-based, built-in shortcuts, negation, and combined (allOf/anyOf) logic.",
      "next_step": "Let's simulate running the pipeline with different parameter combinations."
    },
    {
      "name": "Step 4: Simulate Parameter-Based Deployment",
      "command": "echo '=== SIMULATION: Build with Parameters ==='\necho ''\necho '--- Run 1: Dev deployment (default params) ---'\necho 'Parameters: ENVIRONMENT=dev, IMAGE_TAG=latest, RUN_TESTS=true, FORCE_DEPLOY=false'\necho ''\necho '  [Build]    -> RUNS (always runs)'\necho '  [Test]     -> RUNS (RUN_TESTS=true)'\necho '  [Approval] -> SKIPPED (ENVIRONMENT != production)'\necho '  [Deploy]   -> RUNS (deploys to dev)'\necho '  Result: SUCCESS'\necho ''\necho '--- Run 2: Production with approval ---'\necho 'Parameters: ENVIRONMENT=production, IMAGE_TAG=v2.1.0, RUN_TESTS=true, FORCE_DEPLOY=false'\necho ''\necho '  [Build]    -> RUNS'\necho '  [Test]     -> RUNS'\necho '  [Approval] -> RUNS (production + FORCE_DEPLOY=false -> shows approval dialog)'\necho '  [Deploy]   -> RUNS (only after manual approval)'\necho '  Result: SUCCESS (after approval)'\necho ''\necho '--- Run 3: Hotfix to production (skip tests + approval) ---'\necho 'Parameters: ENVIRONMENT=production, IMAGE_TAG=v2.1.1-hotfix, RUN_TESTS=false, FORCE_DEPLOY=true'\necho ''\necho '  [Build]    -> RUNS'\necho '  [Test]     -> SKIPPED (RUN_TESTS=false)'\necho '  [Approval] -> SKIPPED (FORCE_DEPLOY=true)'\necho '  [Deploy]   -> RUNS (immediate deploy, no gates)'\necho '  Result: SUCCESS (fast path)'",
      "description": "Simulate three different pipeline runs showing how parameters change the flow",
      "explanation": "This shows the power of parameterized pipelines: one Jenkinsfile handles dev, staging, and production with different behaviors. Dev deployments skip approval. Production requires manual approval unless FORCE_DEPLOY overrides it (useful for hotfixes). Tests can be skipped for known-good builds. This flexibility eliminates the need for separate pipelines per environment.",
      "what_it_does": "Walks through three realistic parameter combinations showing which stages run, skip, or block for each scenario.",
      "next_step": "Let's deploy a real app with environment-specific configuration."
    },
    {
      "name": "Step 5: Deploy with Environment-Specific Config",
      "command": "kubectl create namespace jenkins-scenarios --dry-run=client -o yaml | kubectl apply -f - && echo '--- Simulating: ENVIRONMENT=staging, IMAGE_TAG=v2.1.0 ---' && cat <<'EOF' | kubectl apply -n jenkins-scenarios -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config-staging\n  labels:\n    app: parameterized-app\n    environment: staging\ndata:\n  APP_ENV: \"staging\"\n  LOG_LEVEL: \"debug\"\n  DB_HOST: \"staging-db.internal\"\n  FEATURE_FLAGS: \"new-ui=true,beta-api=true\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: parameterized-app\n  labels:\n    app: parameterized-app\n    environment: staging\n    image-tag: v2.1.0\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: parameterized-app\n  template:\n    metadata:\n      labels:\n        app: parameterized-app\n        environment: staging\n    spec:\n      containers:\n      - name: app\n        image: nginx:1.25-alpine\n        ports:\n        - containerPort: 80\n        envFrom:\n        - configMapRef:\n            name: app-config-staging\n        resources:\n          requests:\n            cpu: 50m\n            memory: 64Mi\n          limits:\n            cpu: 100m\n            memory: 128Mi\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: parameterized-app-svc\n  labels:\n    app: parameterized-app\nspec:\n  selector:\n    app: parameterized-app\n  ports:\n  - port: 80\n    targetPort: 80\n  type: ClusterIP\nEOF",
      "description": "Deploy an app with staging-specific ConfigMap settings driven by pipeline parameters",
      "explanation": "In a real parameterized pipeline, the ENVIRONMENT parameter determines which config files to apply. Each environment has its own ConfigMap with different database hosts, log levels, and feature flags. The Jenkins pipeline would run 'kubectl apply -f k8s/${params.ENVIRONMENT}/' to select the right manifests. This shows how one pipeline serves all environments.",
      "what_it_does": "Creates a staging ConfigMap with environment-specific settings and deploys the app with those configs injected via envFrom.",
      "next_step": "Let's verify the environment-specific config was applied correctly."
    },
    {
      "name": "Step 6: Verify Environment Config",
      "command": "echo '=== Verifying Staging Configuration ==='\necho ''\necho 'ConfigMap contents:'\nkubectl get configmap app-config-staging -n jenkins-scenarios -o yaml | grep -A 10 'data:'\necho ''\necho 'Deployment status:'\nkubectl get deployment parameterized-app -n jenkins-scenarios\necho ''\necho 'Environment variables in running pod:'\nkubectl get pods -n jenkins-scenarios -l app=parameterized-app -o name | head -1 | xargs -I{} kubectl exec {} -n jenkins-scenarios -- env 2>/dev/null | grep -E '^(APP_ENV|LOG_LEVEL|DB_HOST|FEATURE_FLAGS)' || echo '  (Pod may still be starting -- config is in the ConfigMap above)'\necho ''\necho 'In production, you would see:'\necho '  APP_ENV=production'\necho '  LOG_LEVEL=warn'\necho '  DB_HOST=prod-db.internal'\necho '  FEATURE_FLAGS=new-ui=false,beta-api=false'",
      "description": "Verify that the staging ConfigMap values are correctly injected into the running pods",
      "explanation": "Verifying config injection is critical in parameterized deployments. A common failure mode is deploying production code with staging config or vice versa. Always verify the environment variables in running pods match the intended environment. The labels (environment: staging) provide additional traceability.",
      "what_it_does": "Shows the ConfigMap data, deployment status, and attempts to read the environment variables from inside a running pod to confirm staging config is active.",
      "next_step": "Let's review everything we learned about parameterized pipelines."
    },
    {
      "name": "Step 7: Summary",
      "command": "echo '=== SCENARIO COMPLETE: Parameterized Builds ==='\necho ''\necho 'WHAT YOU LEARNED:'\necho '  1. Five parameter types: string, choice, boolean, password, text'\necho '  2. Access parameters via params.NAME in pipeline code'\necho '  3. when{} blocks conditionally skip stages based on parameters'\necho '  4. allOf (AND) and anyOf (OR) combine multiple conditions'\necho '  5. One pipeline handles all environments with different behavior per env'\necho ''\necho 'PARAMETERIZED PIPELINE SKELETON:'\necho '  pipeline {'\necho '      parameters {'\necho '          choice(name: \"ENV\", choices: [\"dev\", \"staging\", \"prod\"])'\necho '          booleanParam(name: \"SKIP_TESTS\", defaultValue: false)'\necho '      }'\necho '      stages {'\necho '          stage(\"Test\") {'\necho '              when { expression { params.SKIP_TESTS == false } }'\necho '              steps { sh \"make test\" }'\necho '          }'\necho '          stage(\"Approve\") {'\necho '              when { expression { params.ENV == \"prod\" } }'\necho '              steps { input \"Deploy to prod?\" }'\necho '          }'\necho '          stage(\"Deploy\") {'\necho '              steps { sh \"kubectl apply -f k8s/${params.ENV}/\" }'\necho '          }'\necho '      }'\necho '  }'\necho ''\necho 'NEXT SCENARIO: 04-credentials-and-secrets'\necho '  Learn how Jenkins securely manages credentials and integrates with K8s secrets.'",
      "description": "Review all concepts covered about parameters, when blocks, and environment-specific deployments",
      "explanation": "This summary reinforces the pattern of using parameters to create flexible, multi-environment pipelines. The skeleton provides a minimal template that includes the most common parameter types and conditional patterns.",
      "what_it_does": "Prints a complete summary of parameterized pipeline concepts and a reusable skeleton template.",
      "next_step": "Run cleanup to remove all resources."
    },
    {
      "name": "Step 8: Cleanup",
      "command": "kubectl delete deployment parameterized-app -n jenkins-scenarios --ignore-not-found && kubectl delete svc parameterized-app-svc -n jenkins-scenarios --ignore-not-found && kubectl delete configmap app-config-staging -n jenkins-scenarios --ignore-not-found && echo '' && echo 'Cleanup complete. All resources from 03-parameterized-builds have been removed.'",
      "description": "Remove all Kubernetes resources created during this scenario",
      "explanation": "This removes the deployment, service, and ConfigMap. The --ignore-not-found flag ensures cleanup succeeds even if some resources were already removed.",
      "what_it_does": "Deletes the parameterized-app deployment, parameterized-app-svc service, and app-config-staging ConfigMap from the jenkins-scenarios namespace.",
      "next_step": "Scenario complete. Move on to 04-credentials-and-secrets to learn secret management.",
      "cleanup": true
    }
  ]
}
