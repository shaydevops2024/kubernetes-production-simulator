{
  "scenario_id": "06-shared-library",
  "difficulty": "medium",
  "duration": "15 min",
  "commands": [
    {
      "name": "Step 1: Understand Shared Library Structure",
      "command": "echo '=== Jenkins Shared Library Structure ===\n\nA Shared Library is a reusable code repository that multiple pipelines can import.\nInstead of duplicating pipeline logic across repositories, you define it once.\n\nDirectory structure:\n\n  my-jenkins-library/\n  ├── vars/                     # Global functions (called from pipelines)\n  │   ├── buildApp.groovy       # Callable as: buildApp()\n  │   ├── deployToK8s.groovy    # Callable as: deployToK8s()\n  │   ├── notifySlack.groovy    # Callable as: notifySlack()\n  │   └── runTests.groovy       # Callable as: runTests()\n  ├── src/                      # Helper classes (OOP Groovy code)\n  │   └── com/\n  │       └── example/\n  │           ├── DockerHelper.groovy\n  │           └── KubeHelper.groovy\n  ├── resources/                # Non-Groovy files (templates, configs)\n  │   └── deploy-template.yaml\n  └── README.md\n\nKey rules:\n  - vars/ files define global functions usable in any pipeline\n  - Each file in vars/ becomes a \"step\" (filename = step name)\n  - src/ contains reusable Groovy classes\n  - Configured in Jenkins: Manage Jenkins -> Configure System -> Global Pipeline Libraries'",
      "description": "Learn the directory structure and purpose of Jenkins Shared Libraries",
      "explanation": "Shared Libraries solve the code duplication problem in Jenkins. When 50 microservices all need the same build-test-deploy pattern, you write it once in a Shared Library and import it everywhere. The vars/ directory holds global step definitions, src/ holds Groovy classes, and resources/ holds non-code files like templates.",
      "what_it_does": "Displays the standard directory structure of a Jenkins Shared Library with explanations of each directory's purpose and the key rules for organizing library code.",
      "next_step": "Review example global functions in the vars/ directory.",
      "cleanup": false
    },
    {
      "name": "Step 2: Review vars/ Global Functions",
      "command": "echo '=== vars/buildApp.groovy ==='\ncat << 'EOF'\n// vars/buildApp.groovy\ndef call(Map config = [:]) {\n    def appName = config.appName ?: error('appName is required')\n    def buildTool = config.buildTool ?: 'maven'\n\n    stage(\"Build ${appName}\") {\n        echo \"Building ${appName} with ${buildTool}\"\n        switch (buildTool) {\n            case 'maven':\n                sh 'mvn clean package -DskipTests'\n                break\n            case 'gradle':\n                sh './gradlew build -x test'\n                break\n            case 'npm':\n                sh 'npm ci && npm run build'\n                break\n            default:\n                error \"Unknown build tool: ${buildTool}\"\n        }\n    }\n}\nEOF\necho ''\necho '=== vars/deployToK8s.groovy ==='\ncat << 'EOF'\n// vars/deployToK8s.groovy\ndef call(Map config = [:]) {\n    def namespace = config.namespace ?: 'default'\n    def appName = config.appName ?: error('appName is required')\n    def imageTag = config.imageTag ?: 'latest'\n\n    stage(\"Deploy to ${namespace}\") {\n        echo \"Deploying ${appName}:${imageTag} to namespace ${namespace}\"\n        sh \"\"\"\n            kubectl set image deployment/${appName} \\\\\n                app=${appName}:${imageTag} \\\\\n                -n ${namespace}\n            kubectl rollout status deployment/${appName} \\\\\n                -n ${namespace} --timeout=120s\n        \"\"\"\n    }\n}\nEOF\necho ''\necho '=== vars/notifySlack.groovy ==='\ncat << 'EOF'\n// vars/notifySlack.groovy\ndef call(Map config = [:]) {\n    def channel = config.channel ?: '#builds'\n    def status = config.status ?: currentBuild.currentResult\n    def color = status == 'SUCCESS' ? 'good' : 'danger'\n\n    slackSend(\n        channel: channel,\n        color: color,\n        message: \"${env.JOB_NAME} #${env.BUILD_NUMBER}: ${status}\"\n    )\n}\nEOF",
      "description": "Examine reusable global functions that any pipeline can call",
      "explanation": "Each file in vars/ must define a 'call' method. The filename becomes the step name: vars/buildApp.groovy is called as buildApp() in pipelines. Using Map config as a parameter allows flexible, named arguments. These functions encapsulate complex logic (build tool selection, Kubernetes deployment, Slack notifications) behind simple, reusable interfaces.",
      "what_it_does": "Displays three complete global function definitions: buildApp.groovy (multi-tool build support), deployToK8s.groovy (Kubernetes deployment with rollout check), and notifySlack.groovy (build notification).",
      "next_step": "Review the src/ directory for helper classes.",
      "cleanup": false
    },
    {
      "name": "Step 3: Review src/ Helper Classes",
      "command": "echo '=== src/com/example/DockerHelper.groovy ==='\ncat << 'EOF'\npackage com.example\n\nclass DockerHelper implements Serializable {\n    def script  // Reference to the pipeline script\n\n    DockerHelper(script) {\n        this.script = script\n    }\n\n    def build(String imageName, String tag, String dockerfile = 'Dockerfile') {\n        script.sh \"docker build -t ${imageName}:${tag} -f ${dockerfile} .\"\n    }\n\n    def push(String imageName, String tag, String registry) {\n        script.sh \"docker push ${registry}/${imageName}:${tag}\"\n    }\n\n    def buildAndPush(Map config) {\n        build(config.imageName, config.tag, config.dockerfile ?: 'Dockerfile')\n        push(config.imageName, config.tag, config.registry)\n    }\n}\nEOF\necho ''\necho '=== src/com/example/KubeHelper.groovy ==='\ncat << 'EOF'\npackage com.example\n\nclass KubeHelper implements Serializable {\n    def script\n\n    KubeHelper(script) {\n        this.script = script\n    }\n\n    def deploy(String namespace, String deployment, String image) {\n        script.sh \"kubectl set image deployment/${deployment} app=${image} -n ${namespace}\"\n        script.sh \"kubectl rollout status deployment/${deployment} -n ${namespace} --timeout=180s\"\n    }\n\n    def rollback(String namespace, String deployment) {\n        script.sh \"kubectl rollout undo deployment/${deployment} -n ${namespace}\"\n    }\n\n    def getStatus(String namespace, String deployment) {\n        return script.sh(\n            script: \"kubectl rollout status deployment/${deployment} -n ${namespace}\",\n            returnStdout: true\n        ).trim()\n    }\n}\nEOF\necho ''\necho 'Note: src/ classes require \"implements Serializable\" because Jenkins'\necho 'pipelines may be paused and resumed (CPS transformation).'\necho 'The \"script\" field provides access to pipeline steps like sh().'",
      "description": "Examine reusable Groovy classes in the src/ directory",
      "explanation": "The src/ directory follows standard Groovy/Java package conventions. Classes here provide object-oriented functionality that is too complex for simple vars/ functions. The 'implements Serializable' is required because Jenkins uses Continuation Passing Style (CPS) to pause/resume pipelines. The 'script' reference is needed to call pipeline steps (sh, echo, etc.) from class methods.",
      "what_it_does": "Displays two helper classes: DockerHelper (build and push Docker images) and KubeHelper (deploy, rollback, and check status of Kubernetes deployments), with an explanation of the Serializable requirement.",
      "next_step": "See how to import and use the Shared Library in a Jenkinsfile.",
      "cleanup": false
    },
    {
      "name": "Step 4: See How to Import the Library",
      "command": "echo '=== Three Ways to Import a Shared Library ==='\necho ''\necho '--- Method 1: @Library annotation (most common) ---'\ncat << 'EOF'\n@Library('my-jenkins-library') _\n\npipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                buildApp(appName: 'my-service', buildTool: 'maven')\n            }\n        }\n    }\n}\nEOF\necho ''\necho '--- Method 2: Specific version/branch ---'\ncat << 'EOF'\n@Library('my-jenkins-library@v2.1.0') _\n// or\n@Library('my-jenkins-library@main') _\nEOF\necho ''\necho '--- Method 3: Dynamic loading (in script block) ---'\ncat << 'EOF'\npipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                script {\n                    library('my-jenkins-library@main')\n                    buildApp(appName: 'my-service')\n                }\n            }\n        }\n    }\n}\nEOF\necho ''\necho 'The underscore (_) after @Library is required syntax when'\necho 'the annotation is not followed by an import statement.'\necho ''\necho 'Version pinning (@v2.1.0) is recommended for production'\necho 'to prevent library changes from breaking pipelines.'",
      "description": "Learn the different ways to import a Shared Library into a Jenkinsfile",
      "explanation": "The @Library annotation is the standard way to load a Shared Library. The library name must match what is configured in Jenkins global settings. The trailing underscore is a Groovy requirement for annotations not attached to a class or import. Version pinning with @version ensures stability -- without it, Jenkins uses the default branch configured in settings.",
      "what_it_does": "Displays three methods for importing Shared Libraries: the @Library annotation, version-pinned imports, and dynamic loading via the library() step, with explanations of each approach.",
      "next_step": "See a complete pipeline that leverages the Shared Library.",
      "cleanup": false
    },
    {
      "name": "Step 5: Show a Pipeline Using the Shared Library",
      "command": "echo '=== Complete Pipeline Using Shared Library ==='\ncat << 'EOF'\n@Library('my-jenkins-library@v2.1.0') _\n\nimport com.example.DockerHelper\nimport com.example.KubeHelper\n\npipeline {\n    agent any\n\n    environment {\n        APP_NAME  = 'payment-service'\n        IMAGE_TAG = \"${env.BUILD_NUMBER}\"\n        REGISTRY  = 'registry.example.com'\n    }\n\n    stages {\n        stage('Build') {\n            steps {\n                // Uses vars/buildApp.groovy\n                buildApp(appName: env.APP_NAME, buildTool: 'maven')\n            }\n        }\n\n        stage('Test') {\n            steps {\n                // Uses vars/runTests.groovy\n                runTests(appName: env.APP_NAME, testType: 'unit')\n                runTests(appName: env.APP_NAME, testType: 'integration')\n            }\n        }\n\n        stage('Docker Build & Push') {\n            steps {\n                script {\n                    // Uses src/com/example/DockerHelper.groovy\n                    def docker = new DockerHelper(this)\n                    docker.buildAndPush(\n                        imageName: env.APP_NAME,\n                        tag: env.IMAGE_TAG,\n                        registry: env.REGISTRY\n                    )\n                }\n            }\n        }\n\n        stage('Deploy') {\n            steps {\n                // Uses vars/deployToK8s.groovy\n                deployToK8s(\n                    namespace: 'production',\n                    appName: env.APP_NAME,\n                    imageTag: \"${REGISTRY}/${APP_NAME}:${IMAGE_TAG}\"\n                )\n            }\n        }\n    }\n\n    post {\n        always {\n            // Uses vars/notifySlack.groovy\n            notifySlack(channel: '#payment-team')\n        }\n    }\n}\nEOF\necho ''\necho 'Notice how clean this pipeline is -- all complex logic lives'\necho 'in the Shared Library. The Jenkinsfile is a simple orchestrator.'",
      "description": "See a complete Jenkinsfile that uses both vars/ functions and src/ classes from the Shared Library",
      "explanation": "This pipeline demonstrates the power of Shared Libraries. Instead of 100+ lines of duplicated logic, the Jenkinsfile is a clean, readable orchestration of reusable steps. buildApp(), runTests(), deployToK8s(), and notifySlack() come from vars/. DockerHelper comes from src/. If you need to change how Docker images are built, you update the library once and all pipelines benefit.",
      "what_it_does": "Displays a complete Jenkinsfile that imports the Shared Library and uses global functions (buildApp, runTests, deployToK8s, notifySlack) and a helper class (DockerHelper) to implement a full CI/CD pipeline in minimal code.",
      "next_step": "Simulate a deployment using the shared library pattern.",
      "cleanup": false
    },
    {
      "name": "Step 6: Simulate Library-Based Deployment",
      "command": "kubectl create namespace jenkins-scenarios --dry-run=client -o yaml | kubectl apply -f - && \\\necho '=== Simulating Shared Library Pipeline Execution ===' && \\\necho '' && \\\necho '[Pipeline] @Library my-jenkins-library@v2.1.0 loaded' && \\\necho '[Pipeline] Resolving library from: https://github.com/example/my-jenkins-library.git' && \\\necho '[Pipeline] Using version: v2.1.0' && \\\necho '' && \\\necho '[Stage: Build]' && \\\necho '  buildApp(appName: payment-service, buildTool: maven)' && \\\necho '  -> mvn clean package -DskipTests' && \\\necho '  -> BUILD SUCCESS' && \\\necho '' && \\\necho '[Stage: Test]' && \\\necho '  runTests(appName: payment-service, testType: unit)' && \\\necho '  -> 234 tests, 0 failures' && \\\necho '  runTests(appName: payment-service, testType: integration)' && \\\necho '  -> 45 tests, 0 failures' && \\\necho '' && \\\necho '[Stage: Docker Build & Push]' && \\\necho '  DockerHelper.buildAndPush(payment-service:42, registry.example.com)' && \\\necho '  -> docker build -t payment-service:42 -f Dockerfile .' && \\\necho '  -> docker push registry.example.com/payment-service:42' && \\\necho '' && \\\necho '[Stage: Deploy]' && \\\necho '  deployToK8s(namespace: production, appName: payment-service)' && \\\necho '  -> kubectl set image deployment/payment-service app=payment-service:42 -n production' && \\\necho '  -> Rollout complete: 3/3 replicas updated' && \\\necho '' && \\\nkubectl create configmap shared-library-demo \\\n  --from-literal=library-name=my-jenkins-library \\\n  --from-literal=library-version=v2.1.0 \\\n  --from-literal=app-name=payment-service \\\n  --from-literal=build-number=42 \\\n  --from-literal=functions-used='buildApp,runTests,deployToK8s,notifySlack' \\\n  --from-literal=classes-used='DockerHelper' \\\n  -n jenkins-scenarios \\\n  --dry-run=client -o yaml | kubectl apply -f - && \\\necho '' && \\\necho '[Post: Notify]' && \\\necho '  notifySlack(channel: #payment-team)' && \\\necho '  -> Slack message sent: payment-service #42: SUCCESS' && \\\necho '' && \\\necho 'Pipeline complete. ConfigMap created with library metadata.'",
      "description": "Simulate a full pipeline execution that uses the Shared Library functions and classes",
      "explanation": "This simulation shows exactly what happens when Jenkins runs a pipeline using a Shared Library. First, the library is loaded from Git at the specified version. Then each stage calls library functions which encapsulate the real commands. The ConfigMap records what library functions and classes were used, simulating how you might track library usage across pipelines.",
      "what_it_does": "Simulates the full execution of a Shared Library pipeline, showing each stage calling library functions, and creates a ConfigMap in jenkins-scenarios recording the library metadata used.",
      "next_step": "Verify the deployment metadata.",
      "cleanup": false
    },
    {
      "name": "Step 7: Verify Library Deployment",
      "command": "echo '=== Shared Library Usage Report ==='\necho ''\nkubectl get configmap shared-library-demo -n jenkins-scenarios -o jsonpath='{.data}' | python3 -c \"\nimport sys, json\ndata = json.loads(sys.stdin.read())\nprint(f'Library:    {data[\\\"library-name\\\"]} @ {data[\\\"library-version\\\"]}')\nprint(f'App:        {data[\\\"app-name\\\"]} (build #{data[\\\"build-number\\\"]})')\nprint(f'Functions:  {data[\\\"functions-used\\\"]}')\nprint(f'Classes:    {data[\\\"classes-used\\\"]}')\n\" 2>/dev/null || kubectl get configmap shared-library-demo -n jenkins-scenarios -o yaml\necho ''\necho 'Benefits of Shared Libraries demonstrated:'\necho '  1. Pipeline Jenkinsfile: ~40 lines (vs ~200 without library)'\necho '  2. Consistent build process across all microservices'\necho '  3. Version-pinned library prevents unexpected changes'\necho '  4. Central place to update build/deploy logic'\necho '  5. Easier onboarding -- new services copy a short template'",
      "description": "Verify the deployment and review the benefits of Shared Libraries",
      "explanation": "By examining the ConfigMap, we can see exactly which library version, functions, and classes were used. This traceability is valuable in production. The benefits summary highlights why Shared Libraries are a Jenkins best practice: they reduce code duplication from hundreds of lines to a few, enforce consistency, and simplify updates.",
      "what_it_does": "Reads the shared-library-demo ConfigMap to display library usage details, then summarizes the key benefits of using Shared Libraries for pipeline code reuse.",
      "next_step": "Review the scenario summary.",
      "cleanup": false
    },
    {
      "name": "Step 8: Scenario Summary",
      "command": "echo '╔══════════════════════════════════════════════════════════════╗'\necho '║           Shared Library - Key Takeaways                    ║'\necho '╠══════════════════════════════════════════════════════════════╣'\necho '║                                                            ║'\necho '║  1. Structure:                                             ║'\necho '║     vars/  -> Global functions (step definitions)          ║'\necho '║     src/   -> Groovy helper classes                        ║'\necho '║     resources/ -> Templates and configs                    ║'\necho '║                                                            ║'\necho '║  2. vars/ files define the call() method                   ║'\necho '║     -> Filename becomes the step name                      ║'\necho '║     -> Use Map config for flexible parameters              ║'\necho '║                                                            ║'\necho '║  3. src/ classes must implement Serializable               ║'\necho '║     -> Required for Jenkins CPS pipeline execution         ║'\necho '║     -> Accept \"script\" parameter for pipeline step access  ║'\necho '║                                                            ║'\necho '║  4. Import with @Library annotation                        ║'\necho '║     -> Pin versions: @Library(\"lib@v2.1.0\") _              ║'\necho '║     -> Configure in Manage Jenkins -> Global Libraries     ║'\necho '║                                                            ║'\necho '║  5. Best Practices:                                        ║'\necho '║     -> Version-pin in production pipelines                 ║'\necho '║     -> Write unit tests for library code                   ║'\necho '║     -> Document function parameters                        ║'\necho '║     -> Keep vars/ functions small, use src/ for logic      ║'\necho '║                                                            ║'\necho '╚══════════════════════════════════════════════════════════════╝'",
      "description": "Review the key concepts learned about Jenkins Shared Libraries",
      "explanation": "Shared Libraries are how organizations scale Jenkins pipelines. They centralize complex logic, enforce standards, and dramatically reduce per-pipeline code. Understanding the vars/ vs src/ distinction, the @Library annotation, and version pinning are essential skills for Jenkins administrators and pipeline developers.",
      "what_it_does": "Displays a formatted summary of all key Shared Library concepts including structure, vars/ conventions, src/ requirements, import syntax, and best practices.",
      "next_step": "Clean up all resources created during this scenario.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo 'Cleaning up Shared Library scenario resources...'\nkubectl delete configmap shared-library-demo -n jenkins-scenarios --ignore-not-found\necho ''\necho 'All Shared Library scenario resources have been removed.'\necho 'The jenkins-scenarios namespace is preserved for other scenarios.'",
      "description": "Remove all resources created during this scenario",
      "explanation": "Cleanup removes the ConfigMap created during the scenario. The jenkins-scenarios namespace is preserved since other Jenkins scenarios may use it.",
      "what_it_does": "Deletes the shared-library-demo ConfigMap from the jenkins-scenarios namespace.",
      "next_step": "Scenario complete! Try the Docker Build and Push scenario next to learn about building container images in Jenkins.",
      "cleanup": true
    }
  ]
}
