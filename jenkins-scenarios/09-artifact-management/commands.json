{
  "scenario_id": "09-artifact-management",
  "difficulty": "medium",
  "duration": "12 min",
  "commands": [
    {
      "name": "Step 1: Understand Artifact Types",
      "command": "echo '=== Jenkins Artifact Types ===' && echo '' && echo '1. Build Artifacts   - Compiled binaries, JARs, WARs, Docker images' && echo '2. Test Reports      - JUnit XML, HTML coverage reports, Allure reports' && echo '3. Log Files         - Build logs, test output, deployment logs' && echo '4. Documentation     - Generated API docs, changelogs, release notes' && echo '5. Configuration     - Build metadata, environment snapshots, dependency lists' && echo '' && echo 'Artifacts are files produced during a build that you want to' && echo 'preserve beyond the build lifecycle for deployment, debugging,' && echo 'auditing, or downstream consumption.' && echo '' && echo 'Jenkins stores artifacts in JENKINS_HOME/jobs/<job>/builds/<build>/archive/'",
      "description": "Overview of artifact types Jenkins can manage",
      "explanation": "Jenkins artifacts are any files produced during a build that need to be preserved. Understanding the different categories helps you decide what to archive, how long to retain them, and which plugins to use for publishing. Build artifacts are typically deployed, test reports feed into dashboards, and logs aid in post-mortem debugging.",
      "what_it_does": "Displays a categorized list of common Jenkins artifact types with explanations of where they are stored.",
      "next_step": "Review the archiveArtifacts pipeline step.",
      "type": "info"
    },
    {
      "name": "Step 2: Review archiveArtifacts Step",
      "command": "cat << 'JENKINSFILE'\npipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                sh 'mvn clean package -DskipTests'\n            }\n        }\n        stage('Archive') {\n            steps {\n                // Archive JAR files from target directory\n                archiveArtifacts artifacts: 'target/*.jar',\n                    fingerprint: true,\n                    allowEmptyArchive: false,\n                    onlyIfSuccessful: true\n\n                // Archive multiple patterns\n                archiveArtifacts artifacts: 'target/**/*.jar, docs/**/*.pdf',\n                    excludes: 'target/*-sources.jar',\n                    fingerprint: true\n            }\n        }\n    }\n}\nJENKINSFILE",
      "description": "Examine the archiveArtifacts pipeline step and its options",
      "explanation": "archiveArtifacts is Jenkins' built-in step for preserving build outputs. The 'artifacts' parameter uses Ant-style glob patterns to match files. 'fingerprint: true' creates MD5 checksums for tracking artifacts across jobs. 'allowEmptyArchive: false' fails the build if no matching files are found, catching build errors early. 'onlyIfSuccessful: true' skips archiving if the build failed. The 'excludes' parameter filters out unwanted matches like source JARs.",
      "what_it_does": "Displays a Jenkinsfile showing archiveArtifacts usage with fingerprinting, glob patterns, and exclusion filters.",
      "next_step": "Review JUnit and HTML report publishing steps."
    },
    {
      "name": "Step 3: Review JUnit and publishHTML Steps",
      "command": "cat << 'JENKINSFILE'\npipeline {\n    agent any\n    stages {\n        stage('Test') {\n            steps {\n                sh 'mvn test'\n            }\n            post {\n                always {\n                    // Publish JUnit test results\n                    junit testResults: 'target/surefire-reports/*.xml',\n                        allowEmptyResults: false,\n                        skipPublishingChecks: false\n\n                    // Publish HTML coverage report\n                    publishHTML(target: [\n                        reportName: 'Code Coverage',\n                        reportDir: 'target/site/jacoco',\n                        reportFiles: 'index.html',\n                        keepAll: true,\n                        alwaysLinkToLastBuild: true,\n                        allowMissing: false\n                    ])\n                }\n            }\n        }\n    }\n}\nJENKINSFILE",
      "description": "Examine junit and publishHTML steps for test reporting",
      "explanation": "The 'junit' step parses JUnit XML test results and integrates them into Jenkins' test trend dashboard. It tracks pass/fail/skip counts over time, making regressions immediately visible. 'publishHTML' creates a browsable HTML report tab on the build page - commonly used for code coverage (JaCoCo, Istanbul), API documentation, or custom reports. Both steps are placed in 'post { always {} }' to ensure reports are published even when tests fail, which is critical for debugging failures.",
      "what_it_does": "Displays a Jenkinsfile demonstrating JUnit test result publishing and HTML report generation with JaCoCo coverage.",
      "next_step": "Simulate creating build artifacts."
    },
    {
      "name": "Step 4: Simulate Creating Build Artifacts",
      "command": "kubectl create namespace jenkins-scenarios --dry-run=client -o yaml | kubectl apply -f - && kubectl run artifact-builder --image=busybox -n jenkins-scenarios --restart=Never -- sh -c '\nmkdir -p /tmp/artifacts/target /tmp/artifacts/docs\necho \"Manifest-Version: 1.0\" > /tmp/artifacts/target/myapp-1.2.3.jar\necho \"Manifest-Version: 1.0\" > /tmp/artifacts/target/myapp-1.2.3-sources.jar\necho \"{\\\"version\\\": \\\"1.2.3\\\", \\\"commit\\\": \\\"abc123\\\", \\\"timestamp\\\": \\\"2025-01-15T10:30:00Z\\\"}\" > /tmp/artifacts/target/build-info.json\necho \"<html><body><h1>API Docs v1.2.3</h1></body></html>\" > /tmp/artifacts/docs/api-docs.html\necho \"=== Artifacts Created ===\"\necho \"target/myapp-1.2.3.jar         (application binary)\"\necho \"target/myapp-1.2.3-sources.jar (source archive - excluded from archive)\"\necho \"target/build-info.json         (build metadata)\"\necho \"docs/api-docs.html             (generated documentation)\"\necho \"\"\necho \"Total: 4 files, 3 will be archived (sources.jar excluded)\"\nsleep 300' && sleep 3 && kubectl logs artifact-builder -n jenkins-scenarios",
      "description": "Create a pod that simulates generating build artifacts",
      "explanation": "In a real Jenkins pipeline, the build stage produces artifacts like compiled JARs, metadata files, and documentation. This simulation creates representative files to demonstrate what a typical Java project build produces. The build-info.json file is a best practice - it embeds version, commit SHA, and timestamp into the artifact for full traceability. The sources JAR would typically be excluded from archiving since it duplicates the source repository.",
      "what_it_does": "Creates a pod in the jenkins-scenarios namespace that generates simulated build artifacts and displays what was created.",
      "next_step": "Simulate test report generation."
    },
    {
      "name": "Step 5: Simulate Test Report Generation",
      "command": "kubectl run report-generator --image=busybox -n jenkins-scenarios --restart=Never -- sh -c '\nmkdir -p /tmp/reports/surefire /tmp/reports/coverage\ncat > /tmp/reports/surefire/TEST-com.example.AppTest.xml << EOF\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuite name=\"com.example.AppTest\" tests=\"5\" failures=\"0\" errors=\"0\" skipped=\"1\" time=\"2.341\">\n  <testcase name=\"testHealthEndpoint\" classname=\"com.example.AppTest\" time=\"0.234\"/>\n  <testcase name=\"testDatabaseConnection\" classname=\"com.example.AppTest\" time=\"1.102\"/>\n  <testcase name=\"testUserCreation\" classname=\"com.example.AppTest\" time=\"0.567\"/>\n  <testcase name=\"testAuthentication\" classname=\"com.example.AppTest\" time=\"0.438\"/>\n  <testcase name=\"testEdgeCaseHandling\" classname=\"com.example.AppTest\" time=\"0.000\">\n    <skipped message=\"Pending implementation\"/>\n  </testcase>\n</testsuite>\nEOF\necho \"=== JUnit Test Report ===\"\necho \"Suite: com.example.AppTest\"\necho \"Tests: 5 | Passed: 4 | Failed: 0 | Skipped: 1\"\necho \"Duration: 2.341s\"\necho \"\"\necho \"=== Coverage Summary ===\"\necho \"Line Coverage:   87.3% (target: 80%)\"\necho \"Branch Coverage: 72.1% (target: 70%)\"\necho \"Method Coverage:  91.5%\"\necho \"\"\necho \"Reports generated in surefire-reports/ and site/jacoco/\"\nsleep 300' && sleep 3 && kubectl logs report-generator -n jenkins-scenarios",
      "description": "Create a pod that simulates generating JUnit XML and coverage reports",
      "explanation": "Jenkins parses JUnit XML to track test health over time. The XML format includes test suite metadata (name, counts, duration) and individual test cases with pass/fail/skip status. The 'junit' step aggregates these results into trend graphs on the Jenkins dashboard. Coverage reports from tools like JaCoCo provide line, branch, and method coverage percentages. Jenkins can enforce coverage thresholds - failing builds that drop below minimum coverage, preventing code quality regression.",
      "what_it_does": "Creates a pod that generates a sample JUnit XML report and coverage summary, showing test results and coverage metrics.",
      "next_step": "Explore artifact retention policies."
    },
    {
      "name": "Step 6: Show Artifact Retention Policies",
      "command": "cat << 'JENKINSFILE'\npipeline {\n    agent any\n\n    // Global build retention policy\n    options {\n        buildDiscarder(logRotator(\n            numToKeepStr: '20',        // Keep last 20 builds\n            artifactNumToKeepStr: '5', // Keep artifacts from last 5 only\n            daysToKeepStr: '90',       // Delete builds older than 90 days\n            artifactDaysToKeepStr: '30' // Delete artifacts older than 30 days\n        ))\n    }\n\n    stages {\n        stage('Build') {\n            steps {\n                sh 'make build'\n                archiveArtifacts artifacts: 'dist/**/*', fingerprint: true\n            }\n        }\n    }\n}\nJENKINSFILE\n\necho ''\necho '=== Retention Strategy Best Practices ==='\necho ''\necho 'Build Logs:  Keep 30-90 days  (lightweight, useful for debugging)'\necho 'Artifacts:   Keep 5-10 builds  (heavy, store releases externally)'\necho 'Test Reports: Keep 20-30 builds (trend analysis needs history)'\necho ''\necho 'WARNING: Without retention policies, JENKINS_HOME grows unbounded!'\necho 'A busy server with 100 jobs running 10x/day generates ~3000 builds/day.'\necho 'Each build with artifacts can consume 50-500MB of disk space.'",
      "description": "Examine artifact retention and build discard policies",
      "explanation": "Retention policies are critical for Jenkins disk management. buildDiscarder with logRotator controls how many builds and artifacts are kept. The key insight is that build logs and artifacts can have different retention periods - you might keep build logs for 90 days for debugging but only keep large artifacts for the last 5 builds. For release artifacts, the best practice is to publish them to an external artifact repository (Nexus, Artifactory, S3) rather than relying on Jenkins storage. This keeps Jenkins lean and ensures artifacts survive Jenkins maintenance.",
      "what_it_does": "Displays a Jenkinsfile with build discarder configuration and best practices for artifact retention to prevent disk exhaustion.",
      "next_step": "Deploy with artifact versioning."
    },
    {
      "name": "Step 7: Deploy with Artifact Versioning",
      "command": "cat << 'JENKINSFILE'\npipeline {\n    agent any\n    environment {\n        VERSION = \"${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7)}\"\n        ARTIFACT_NAME = \"myapp-${VERSION}\"\n    }\n    stages {\n        stage('Build & Tag') {\n            steps {\n                sh \"mvn versions:set -DnewVersion=${VERSION}\"\n                sh 'mvn clean package'\n                // Fingerprint for cross-job tracking\n                fingerprint 'target/*.jar'\n            }\n        }\n        stage('Publish to Artifactory') {\n            steps {\n                rtUpload(serverId: 'artifactory',\n                    spec: \"\"\"{\n                        \"files\": [{\n                            \"pattern\": \"target/*.jar\",\n                            \"target\": \"libs-release/com/example/myapp/${VERSION}/\"\n                        }]\n                    }\"\"\")\n            }\n        }\n        stage('Deploy') {\n            steps {\n                sh \"kubectl set image deployment/myapp app=registry.example.com/myapp:${VERSION} -n production\"\n            }\n        }\n    }\n}\nJENKINSFILE\n\necho ''\necho '=== Artifact Versioning Strategies ==='\necho ''\necho 'Semantic:     1.2.3           (manual, for releases)'\necho 'Build-based:  1.2.3-42        (version + build number)'\necho 'Commit-based: 1.2.3-abc1234   (version + git short SHA)'\necho 'Timestamp:    1.2.3-20250115  (version + date)'\necho 'Combined:     42-abc1234      (build number + commit SHA)'\necho ''\necho 'Fingerprinting creates MD5 hashes that let Jenkins track'\necho 'which build produced an artifact and where it was used.'",
      "description": "Show artifact versioning and fingerprinting for deployment traceability",
      "explanation": "Artifact versioning creates a unique, traceable identifier for every build output. Combining the build number with the git commit SHA (e.g., '42-abc1234') provides both human-readable ordering and exact source traceability. Jenkins fingerprinting computes MD5 hashes of artifacts, enabling you to answer 'which build produced this JAR?' and 'which downstream jobs used it?' The Artifactory integration publishes artifacts to an external repository with proper Maven coordinates, making them available for deployment and downstream projects without depending on Jenkins storage.",
      "what_it_does": "Displays a Jenkinsfile with version-tagged artifacts, Artifactory publishing, and Kubernetes deployment, plus a summary of versioning strategies.",
      "next_step": "Verify the scenario resources."
    },
    {
      "name": "Step 8: Verify and Summary",
      "command": "echo '=== Scenario Resources ===' && kubectl get pods -n jenkins-scenarios -o wide && echo '' && echo '=== Artifact Management Summary ===' && echo '' && echo 'Core Steps:' && echo '  archiveArtifacts  - Preserve build outputs in Jenkins' && echo '  fingerprint       - Track artifacts with MD5 hashes' && echo '  junit             - Parse and trend JUnit XML test results' && echo '  publishHTML       - Create browsable HTML report tabs' && echo '' && echo 'Best Practices:' && echo '  1. Always fingerprint artifacts for traceability' && echo '  2. Set retention policies to prevent disk exhaustion' && echo '  3. Publish release artifacts to Nexus/Artifactory/S3' && echo '  4. Use semantic versioning with build metadata' && echo '  5. Archive build-info.json with commit SHA and timestamp' && echo '  6. Place test reporting in post { always {} } blocks' && echo '  7. Enforce coverage thresholds to prevent regression' && echo '' && echo 'Scenario complete! Proceed to cleanup.'",
      "description": "Verify resources and summarize artifact management concepts",
      "explanation": "This step verifies that all demonstration pods are running and provides a comprehensive summary of artifact management in Jenkins. The key takeaway is that artifact management is not just about storing files - it encompasses versioning, fingerprinting for traceability, test result trending, retention policies for disk management, and external repository integration for production-grade artifact storage.",
      "what_it_does": "Lists all pods in the jenkins-scenarios namespace and displays a summary of artifact management concepts and best practices.",
      "next_step": "Clean up all scenario resources."
    },
    {
      "name": "Cleanup: Remove All Resources",
      "command": "kubectl delete pod artifact-builder report-generator -n jenkins-scenarios --ignore-not-found && echo '' && echo 'Cleanup complete. All artifact management demo resources removed.'",
      "description": "Remove all pods created during this scenario",
      "explanation": "Deletes the artifact-builder and report-generator pods from the jenkins-scenarios namespace. The --ignore-not-found flag ensures the command succeeds even if pods were already deleted or failed to create.",
      "what_it_does": "Removes all demonstration pods from the jenkins-scenarios namespace.",
      "next_step": "Cleanup complete! Cleanup complete!",
      "cleanup": true
    }
  ]
}
