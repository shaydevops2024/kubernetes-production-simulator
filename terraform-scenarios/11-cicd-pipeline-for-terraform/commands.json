{
  "scenario_id": "11-cicd-pipeline-for-terraform",
  "difficulty": "medium",
  "duration": "30 min",
  "commands": [
    {
      "name": "Step 1: Review CI/CD Workflow for IaC",
      "command": "echo '=== CI/CD Pipeline for Terraform - Overview ==='\necho ''\necho 'A production Terraform pipeline ensures that infrastructure changes are:'\necho '  - Formatted consistently (terraform fmt)'\necho '  - Syntactically valid (terraform validate)'\necho '  - Reviewed before apply (plan + approval gate)'\necho '  - Applied only from a trusted branch (main/master)'\necho ''\necho '=== Pipeline Stages ==='\necho ''\necho '  PR Created/Updated:'\necho '  +----------+    +-----------+    +--------+    +----------+'\necho '  |  fmt     | -> | validate  | -> |  plan  | -> | comment  |'\necho '  |  check   |    |  check    |    | output |    | on PR    |'\necho '  +----------+    +-----------+    +--------+    +----------+'\necho ''\necho '  PR Merged to main:'\necho '  +----------+    +-----------+    +--------+    +----------+'\necho '  |  fmt     | -> | validate  | -> |  plan  | -> |  apply   |'\necho '  |  check   |    |  check    |    | verify |    | (auto)   |'\necho '  +----------+    +-----------+    +--------+    +----------+'\necho ''\necho '=== Key Principles ==='\necho '  1. Never run terraform apply on a feature branch'\necho '  2. Plan output must be reviewed before merge'\necho '  3. Apply uses the EXACT plan that was reviewed (plan artifact)'\necho '  4. Credentials are stored in GitHub Secrets, never in code'\necho '  5. State locking prevents concurrent modifications'\necho '  6. Branch protection rules enforce the workflow'",
      "description": "Understand the architecture of a CI/CD pipeline for Terraform",
      "explanation": "Running Terraform manually from laptops is fine for learning but dangerous in production. A CI/CD pipeline enforces consistency, requires code review for infrastructure changes, and creates an audit trail. The pipeline has two main flows: on pull requests (format, validate, plan, comment) and on merge to main (format, validate, plan, apply). The key insight is that terraform apply should only run from a trusted branch after human review.",
      "what_it_does": "Displays the overall CI/CD pipeline architecture with two flows (PR and merge), the stages in each flow, and the key principles that make the pipeline production-safe.",
      "next_step": "Next we will create the GitHub Actions workflow file structure.",
      "cleanup": false
    },
    {
      "name": "Step 2: Create GitHub Actions Workflow File",
      "command": "cat << 'TFEOF'\n# .github/workflows/terraform.yml\n# Production Terraform CI/CD Pipeline\n\nname: \"Terraform\"\n\non:\n  pull_request:\n    branches: [main]\n    paths:\n      - 'terraform/**'      # Only trigger on infra changes\n      - '.github/workflows/terraform.yml'\n  push:\n    branches: [main]\n    paths:\n      - 'terraform/**'\n      - '.github/workflows/terraform.yml'\n\n# Cancel in-progress runs for the same PR\nconcurrency:\n  group: terraform-${{ github.event.pull_request.number || github.ref }}\n  cancel-in-progress: true\n\n# Minimum permissions (principle of least privilege)\npermissions:\n  contents: read\n  pull-requests: write    # To comment plan output on PRs\n  id-token: write         # For OIDC authentication with AWS\n\nenv:\n  TF_VERSION: \"1.7.0\"\n  TF_WORKING_DIR: \"terraform/environments/production\"\n  AWS_REGION: \"us-east-1\"\n\njobs:\n  # Jobs defined in the following steps...\nTFEOF\necho ''\necho '=== Key Configuration Choices ==='\necho ''\necho '1. PATH FILTERING: Only triggers when terraform/ files change'\necho '   Saves CI minutes and avoids unnecessary runs'\necho ''\necho '2. CONCURRENCY: Cancels older runs for the same PR'\necho '   Prevents conflicting plans from running simultaneously'\necho ''\necho '3. PERMISSIONS: Minimal permissions with id-token for OIDC'\necho '   OIDC eliminates long-lived AWS access keys'\necho ''\necho '4. PINNED VERSION: TF_VERSION ensures consistent behavior'\necho '   All CI runs use the exact same Terraform version'",
      "description": "Create the GitHub Actions workflow file with triggers, concurrency, and permissions",
      "explanation": "The workflow file is the foundation of the pipeline. Path filtering ensures the pipeline only runs when Terraform files change, saving CI minutes. The concurrency group prevents multiple plans from running simultaneously for the same PR, which could cause state lock conflicts. OIDC authentication (id-token: write) is the modern best practice for AWS authentication -- it generates short-lived credentials instead of storing long-lived access keys in GitHub Secrets.",
      "what_it_does": "Displays the GitHub Actions workflow header with trigger configuration, concurrency controls, minimal permissions, and environment variables for Terraform version and working directory.",
      "next_step": "Next we will add the terraform fmt check stage.",
      "cleanup": false
    },
    {
      "name": "Step 3: Add Terraform Fmt Check Stage",
      "command": "cat << 'TFEOF'\n  # Job 1: Format Check\n  fmt:\n    name: \"Format Check\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: ${{ env.TF_VERSION }}\n\n      - name: Terraform Format Check\n        id: fmt\n        run: terraform fmt -check -recursive -diff\n        working-directory: ${{ env.TF_WORKING_DIR }}\n        continue-on-error: true\n\n      - name: Comment on PR (fmt failure)\n        if: steps.fmt.outcome == 'failure' && github.event_name == 'pull_request'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: '## Terraform Format Check Failed\\n\\nPlease run `terraform fmt -recursive` locally and commit the changes.'\n            })\n\n      - name: Fail if fmt check failed\n        if: steps.fmt.outcome == 'failure'\n        run: exit 1\nTFEOF\necho ''\necho '=== Why fmt matters in CI ==='\necho ''\necho '  terraform fmt -check     Returns exit code 1 if files need formatting'\necho '  terraform fmt -recursive  Formats all .tf files in subdirectories'\necho '  terraform fmt -diff       Shows the exact changes needed'\necho ''\necho '  Benefits:'\necho '    - Consistent code style across the team'\necho '    - No more formatting debates in code review'\necho '    - Catches copy-paste formatting issues'\necho ''\necho '  Pro tip: Add a pre-commit hook to run fmt locally:'\necho '    # .pre-commit-config.yaml'\necho '    repos:'\necho '      - repo: https://github.com/antonbabenko/pre-commit-terraform'\necho '        hooks:'\necho '          - id: terraform_fmt'",
      "description": "Add the terraform fmt formatting check as the first pipeline stage",
      "explanation": "The format check is the fastest and cheapest stage in the pipeline. It verifies that all Terraform files follow the canonical formatting standard. The -check flag makes it exit with code 1 if any file needs formatting without actually modifying files. The continue-on-error pattern lets us post a helpful comment on the PR before failing the job. In practice, teams also set up pre-commit hooks to catch formatting issues before they even reach CI.",
      "what_it_does": "Shows the GitHub Actions job for terraform fmt with checkout, setup, format check, PR commenting on failure, and the rationale for enforcing consistent formatting.",
      "next_step": "Next we will add the terraform validate stage.",
      "cleanup": false
    },
    {
      "name": "Step 4: Add Terraform Validate Stage",
      "command": "cat << 'TFEOF'\n  # Job 2: Validate\n  validate:\n    name: \"Validate\"\n    runs-on: ubuntu-latest\n    needs: [fmt]             # Only run if fmt passes\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: ${{ env.TF_VERSION }}\n\n      - name: Terraform Init (backend disabled)\n        run: terraform init -backend=false\n        working-directory: ${{ env.TF_WORKING_DIR }}\n\n      - name: Terraform Validate\n        id: validate\n        run: terraform validate -no-color\n        working-directory: ${{ env.TF_WORKING_DIR }}\n\n      - name: Comment on PR (validate failure)\n        if: failure() && github.event_name == 'pull_request'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const output = `## Terraform Validation Failed\n\n            Please fix the validation errors before merging.\n\n            Run \\`terraform validate\\` locally to see detailed errors.`;\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: output\n            })\nTFEOF\necho ''\necho '=== Key Details ==='\necho ''\necho '  terraform init -backend=false'\necho '    Initializes providers WITHOUT connecting to remote state.'\necho '    This is faster and does not require AWS credentials.'\necho '    Validate only checks syntax and internal consistency.'\necho ''\necho '  terraform validate checks for:'\necho '    - HCL syntax errors'\necho '    - Invalid resource arguments'\necho '    - Missing required attributes'\necho '    - Type mismatches in variable assignments'\necho '    - Invalid references between resources'\necho ''\necho '  What validate does NOT check:'\necho '    - Whether resource values are valid in the cloud'\necho '    - State consistency'\necho '    - Provider API errors'\necho '    (Those are caught during the plan stage)'",
      "description": "Add the terraform validate stage to catch syntax and configuration errors",
      "explanation": "The validate stage catches configuration errors without needing cloud credentials. By using init -backend=false, we skip connecting to the remote state backend, making this stage fast and credential-free. Validate checks HCL syntax, required attributes, type constraints, and internal references. It runs after fmt because there is no point validating unformatted code. However, validate cannot catch cloud-specific errors like invalid AMI IDs or insufficient permissions -- those are caught during the plan stage.",
      "what_it_does": "Displays the validate job with backend-disabled init, terraform validate, PR commenting on failure, and explains what validate does and does not check.",
      "next_step": "Next we will add the terraform plan stage with artifact storage.",
      "cleanup": false
    },
    {
      "name": "Step 5: Add Terraform Plan with Output Artifact",
      "command": "cat << 'TFEOF'\n  # Job 3: Plan\n  plan:\n    name: \"Plan\"\n    runs-on: ubuntu-latest\n    needs: [validate]       # Only run if validate passes\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: ${{ env.TF_VERSION }}\n          terraform_wrapper: false   # Needed for plan file output\n\n      - name: Configure AWS Credentials (OIDC)\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}\n          aws-region: ${{ env.AWS_REGION }}\n\n      - name: Terraform Init\n        run: terraform init\n        working-directory: ${{ env.TF_WORKING_DIR }}\n\n      - name: Terraform Plan\n        id: plan\n        run: |\n          terraform plan -no-color -input=false \\\n            -out=tfplan \\\n            -detailed-exitcode\n        working-directory: ${{ env.TF_WORKING_DIR }}\n        # Exit codes: 0=no changes, 1=error, 2=changes present\n        continue-on-error: true\n\n      - name: Save Plan Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: tfplan-${{ github.sha }}\n          path: ${{ env.TF_WORKING_DIR }}/tfplan\n          retention-days: 5\n\n      - name: Create Plan Summary\n        run: terraform show -no-color tfplan > plan-summary.txt\n        working-directory: ${{ env.TF_WORKING_DIR }}\n\n      - name: Comment Plan on PR\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const fs = require('fs');\n            const plan = fs.readFileSync(\n              '${{ env.TF_WORKING_DIR }}/plan-summary.txt', 'utf8'\n            );\n            const truncated = plan.length > 60000\n              ? plan.substring(0, 60000) + '\\n... (truncated)'\n              : plan;\n            const body = `## Terraform Plan\n            <details><summary>Show Plan</summary>\n\n            \\`\\`\\`terraform\\n${truncated}\\n\\`\\`\\`\n            </details>\n\n            *Commit: ${context.sha.substring(0, 8)}*`;\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: body\n            })\n\n      - name: Fail on plan error\n        if: steps.plan.outcome == 'failure'\n        run: exit 1\nTFEOF\necho ''\necho '=== Critical Details ==='\necho ''\necho '  -out=tfplan          Saves the binary plan file'\necho '  -detailed-exitcode   0=no changes, 1=error, 2=changes detected'\necho '  -input=false         Never prompt for input in CI'\necho ''\necho '  Plan artifact ensures the EXACT reviewed plan is applied later.'\necho '  Without it, infrastructure could change between plan and apply.'",
      "description": "Add the terraform plan stage that saves plan output as an artifact and comments on the PR",
      "explanation": "The plan stage is the most critical part of the pipeline. It connects to AWS using OIDC credentials, initializes the backend with real state, and generates a plan. The -out=tfplan flag saves the plan as a binary file, which is uploaded as a GitHub artifact. This is essential because it guarantees the apply stage uses the exact plan that was reviewed -- if someone pushes another change between review and merge, a new plan is generated. The plan output is also posted as a PR comment for easy review.",
      "what_it_does": "Shows the complete plan job with OIDC authentication, plan generation with -out flag, artifact upload, human-readable plan posted as PR comment, and exit code handling.",
      "next_step": "Next we will add the manual approval gate.",
      "cleanup": false
    },
    {
      "name": "Step 6: Add Manual Approval Gate",
      "command": "cat << 'TFEOF'\n  # Job 4: Approval Gate (for direct pushes or scheduled applies)\n  # Note: For PR-based workflows, the PR review IS the approval.\n  # This gate adds an extra layer for high-risk environments.\n\n  approval:\n    name: \"Approval Gate\"\n    runs-on: ubuntu-latest\n    needs: [plan]\n    if: github.ref == 'refs/heads/main' && github.event_name == 'push'\n    environment: production   # Requires environment protection rules\n    steps:\n      - name: Approval checkpoint\n        run: echo \"Deployment to production approved\"\nTFEOF\necho ''\necho '=== How GitHub Environment Protection Works ==='\necho ''\necho '  Settings -> Environments -> production:'\necho '    [x] Required reviewers: @platform-team'\necho '    [x] Wait timer: 5 minutes (cooldown period)'\necho '    [x] Deployment branches: main only'\necho ''\necho '  When the workflow reaches the \"approval\" job:'\necho '    1. Pipeline pauses and sends notification'\necho '    2. Designated reviewers see a \"Review deployments\" button'\necho '    3. Reviewer can approve or reject'\necho '    4. On approval, pipeline continues to apply'\necho '    5. On rejection, pipeline stops'\necho ''\necho '=== Alternative Approval Patterns ==='\necho ''\necho '  1. PR Review as Gate (simplest):'\necho '     - Require 2 approvals on PR before merge'\necho '     - Apply triggers automatically on merge to main'\necho ''\necho '  2. ChatOps:'\necho '     - Comment \"/approve-apply\" on the PR'\necho '     - Bot triggers the apply workflow'\necho ''\necho '  3. Terraform Cloud / Spacelift:'\necho '     - Built-in approval workflows'\necho '     - Sentinel/OPA policies for automated governance'\necho ''\necho '  For most teams, PR review + branch protection is sufficient.'",
      "description": "Add a manual approval gate before applying infrastructure changes to production",
      "explanation": "The approval gate ensures that a human reviews and explicitly approves infrastructure changes before they are applied to production. GitHub Environments with protection rules provide this natively -- you configure required reviewers, wait timers, and branch restrictions. When the workflow reaches a job with an environment, it pauses and waits for approval. For most teams, the PR review process itself serves as the approval gate, but high-risk environments benefit from an additional explicit approval step.",
      "what_it_does": "Shows the approval gate job using GitHub Environments, explains how environment protection rules work, and presents alternative approval patterns including PR reviews, ChatOps, and dedicated IaC platforms.",
      "next_step": "Next we will add the terraform apply stage that runs on merge to main.",
      "cleanup": false
    },
    {
      "name": "Step 7: Add Terraform Apply on Merge to Main",
      "command": "cat << 'TFEOF'\n  # Job 5: Apply (only on merge to main)\n  apply:\n    name: \"Apply\"\n    runs-on: ubuntu-latest\n    needs: [approval]\n    if: github.ref == 'refs/heads/main' && github.event_name == 'push'\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n        with:\n          terraform_version: ${{ env.TF_VERSION }}\n          terraform_wrapper: false\n\n      - name: Configure AWS Credentials (OIDC)\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}\n          aws-region: ${{ env.AWS_REGION }}\n\n      - name: Terraform Init\n        run: terraform init\n        working-directory: ${{ env.TF_WORKING_DIR }}\n\n      - name: Download Plan Artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: tfplan-${{ github.sha }}\n          path: ${{ env.TF_WORKING_DIR }}\n\n      - name: Terraform Apply\n        run: terraform apply -auto-approve -input=false tfplan\n        working-directory: ${{ env.TF_WORKING_DIR }}\n\n      - name: Post Apply Status\n        if: always()\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const status = '${{ job.status }}' === 'success'\n              ? ':white_check_mark: Apply succeeded'\n              : ':x: Apply FAILED - manual intervention required';\n            // Post to Slack, Teams, or create an issue\n            console.log(status);\nTFEOF\necho ''\necho '=== Why we apply the saved plan file ==='\necho ''\necho '  terraform apply tfplan'\necho '    Applies the EXACT plan that was reviewed.'\necho '    If state changed since the plan was created,'\necho '    Terraform will detect the drift and REFUSE to apply.'\necho ''\necho '  terraform apply (without plan file)'\necho '    Creates a NEW plan and applies it immediately.'\necho '    This could apply changes nobody reviewed!'\necho ''\necho '=== Post-Apply Actions ==='\necho '  - Send Slack/Teams notification'\necho '  - Update deployment tracker'\necho '  - Trigger downstream pipelines (e.g., Kubernetes deploy)'\necho '  - On failure: create incident, page on-call engineer'",
      "description": "Add the terraform apply stage that runs automatically after approval on the main branch",
      "explanation": "The apply stage is the final step that makes real infrastructure changes. It downloads the exact plan artifact that was reviewed and approved, then applies it. Using the saved plan file is critical -- it guarantees that the changes applied are exactly what was reviewed. If the state has changed since the plan was created (someone else made changes), Terraform will detect the mismatch and refuse to apply. The -auto-approve flag is safe here because the plan file itself is the approval. Post-apply notifications are essential for observability.",
      "what_it_does": "Shows the complete apply job with OIDC auth, plan artifact download, terraform apply with the saved plan file, and post-apply status notifications.",
      "next_step": "Next we will review the complete pipeline with best practices.",
      "cleanup": false
    },
    {
      "name": "Step 8: Complete Pipeline Review with Best Practices",
      "command": "echo '=== Complete Pipeline Flow ==='\necho ''\necho '  Developer pushes branch -> Opens PR'\necho '    |'\necho '    v'\necho '  [fmt check] -> [validate] -> [plan] -> Comment plan on PR'\necho '                                             |'\necho '                                   Reviewer reads plan'\necho '                                   Approves and merges PR'\necho '                                             |'\necho '                                             v'\necho '  Merge to main triggers push event:'\necho '    |'\necho '    v'\necho '  [fmt] -> [validate] -> [plan] -> [approval gate] -> [apply]'\necho ''\necho '=== Security Best Practices ==='\necho ''\necho '  1. OIDC Authentication (no long-lived keys)'\necho '     - Short-lived tokens scoped to the workflow run'\necho '     - No AWS_ACCESS_KEY_ID in GitHub Secrets'\necho ''\necho '  2. Least Privilege IAM Role'\necho '     - CI role can only manage specific resources'\necho '     - Separate roles for plan (read-only) and apply (read-write)'\necho ''\necho '  3. Branch Protection Rules'\necho '     - Require PR reviews before merge'\necho '     - Require status checks (fmt, validate, plan) to pass'\necho '     - No direct pushes to main'\necho ''\necho '  4. State Security'\necho '     - Remote backend with encryption (S3 + KMS)'\necho '     - State locking with DynamoDB'\necho '     - State access audited via CloudTrail'\necho ''\necho '=== Operational Best Practices ==='\necho ''\necho '  1. Pin ALL versions (Terraform, providers, actions)'\necho '  2. Use -detailed-exitcode to detect \"no changes\" vs errors'\necho '  3. Truncate large plan outputs (GitHub has comment size limits)'\necho '  4. Set concurrency groups to prevent parallel state modifications'\necho '  5. Add cost estimation (Infracost) to PR comments'\necho '  6. Add policy checks (OPA/Sentinel) before apply'\necho '  7. Keep plan artifacts for audit trail (retention: 30-90 days)'\necho '  8. Monitor pipeline duration and failure rates'",
      "description": "Review the complete CI/CD pipeline architecture and production best practices",
      "explanation": "A production Terraform CI/CD pipeline requires careful attention to security and operations. OIDC authentication eliminates long-lived credentials. Separate IAM roles for plan (read-only) and apply (read-write) follow least privilege. Branch protection ensures every change goes through code review. Cost estimation tools like Infracost and policy engines like OPA/Sentinel add additional safety layers. The pipeline itself should be monitored for failures and performance, just like the infrastructure it manages.",
      "what_it_does": "Displays the complete pipeline flow from PR to apply, along with comprehensive security and operational best practices for production Terraform CI/CD.",
      "next_step": "Cleanup step to complete the scenario.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo '=== Scenario Complete: CI/CD Pipeline for Terraform ==='\necho ''\necho 'In a real project, you would commit the workflow file to your repo:'\necho '  .github/workflows/terraform.yml'\necho ''\necho 'And configure:'\necho '  - AWS OIDC identity provider + IAM role'\necho '  - GitHub Environment \"production\" with protection rules'\necho '  - Branch protection on main (require PR, status checks)'\necho '  - Terraform remote backend (S3 + DynamoDB)'\necho ''\necho 'What you learned:'\necho '  1. Pipeline architecture: fmt -> validate -> plan -> approve -> apply'\necho '  2. GitHub Actions workflow with path filtering and concurrency'\necho '  3. terraform fmt -check for consistent formatting in CI'\necho '  4. terraform validate with -backend=false for fast syntax checks'\necho '  5. Saving plan artifacts to ensure reviewed plans are applied'\necho '  6. Manual approval gates with GitHub Environments'\necho '  7. Safe apply using the saved plan file on merge to main'\necho '  8. Security best practices: OIDC, least privilege, branch protection'\necho ''\necho 'Next scenario: Full EKS Cluster'",
      "description": "Clean up all resources created during this scenario",
      "explanation": "This scenario was entirely educational using echo and cat commands to display CI/CD pipeline configuration. No actual workflows or cloud resources were created. To implement this pipeline in your own project, commit the workflow file to .github/workflows/ and configure the required GitHub settings and AWS resources.",
      "what_it_does": "Summarizes what was learned about Terraform CI/CD pipelines and lists the configuration steps needed to implement the pipeline in a real project.",
      "next_step": "Try the next scenario to learn about provisioning a full EKS cluster.",
      "cleanup": true
    }
  ]
}
