{
  "scenario_id": "13-multi-region-active-passive",
  "difficulty": "hard",
  "duration": "45 min",
  "commands": [
    {
      "name": "Step 1: Configure Multi-Region Providers",
      "command": "cat << 'TFEOF'\n# =============================================================\n# MULTI-REGION PROVIDER CONFIGURATION\n# =============================================================\n# In a multi-region setup, you define multiple AWS providers\n# using aliases. Each alias targets a different region.\n# Resources reference a specific provider to control placement.\n\n# ---------- providers.tf ----------\n\nterraform {\n  required_version = \">= 1.5.0\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n\n  backend \"s3\" {\n    bucket         = \"mycompany-terraform-state\"\n    key            = \"multi-region/terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"terraform-locks\"\n    encrypt        = true\n  }\n}\n\n# Primary region provider (default)\nprovider \"aws\" {\n  region = var.primary_region\n\n  default_tags {\n    tags = {\n      Environment = var.environment\n      Project     = \"multi-region-app\"\n      ManagedBy   = \"terraform\"\n      Region      = \"primary\"\n    }\n  }\n}\n\n# Secondary region provider (aliased)\nprovider \"aws\" {\n  alias  = \"secondary\"\n  region = var.secondary_region\n\n  default_tags {\n    tags = {\n      Environment = var.environment\n      Project     = \"multi-region-app\"\n      ManagedBy   = \"terraform\"\n      Region      = \"secondary\"\n    }\n  }\n}\n\n# ---------- variables.tf ----------\n\nvariable \"primary_region\" {\n  description = \"Primary AWS region\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"secondary_region\" {\n  description = \"Secondary AWS region for failover\"\n  type        = string\n  default     = \"us-west-2\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n  default     = \"production\"\n}\n\nvariable \"domain_name\" {\n  description = \"Root domain name\"\n  type        = string\n  default     = \"example.com\"\n}\n\n# KEY CONCEPT: The 'alias' keyword lets you manage resources\n# in multiple regions from a single Terraform configuration.\n# Resources use 'provider = aws.secondary' to deploy in the\n# secondary region.\nTFEOF",
      "description": "Set up Terraform providers for both primary and secondary AWS regions using provider aliases.",
      "explanation": "Multi-region deployments require multiple provider configurations. The default provider targets the primary region, while an aliased provider targets the secondary. This pattern lets you manage infrastructure in both regions from a single state file and configuration.",
      "what_it_does": "Displays the provider configuration with two AWS providers (us-east-1 as primary, us-west-2 as secondary), shared variables, and S3 backend configuration for centralized state management.",
      "next_step": "Next we will create the primary region VPC with public and private subnets.",
      "cleanup": false
    },
    {
      "name": "Step 2: Create Primary Region VPC",
      "command": "cat << 'TFEOF'\n# =============================================================\n# PRIMARY REGION VPC (us-east-1)\n# =============================================================\n# The primary region hosts the active workload. It gets a full\n# networking stack: VPC, public/private subnets across AZs,\n# NAT gateway, and an internet gateway.\n\n# ---------- primary-vpc.tf ----------\n\ndata \"aws_availability_zones\" \"primary\" {\n  state = \"available\"\n}\n\nresource \"aws_vpc\" \"primary\" {\n  cidr_block           = \"10.0.0.0/16\"\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name = \"${var.environment}-primary-vpc\"\n    Role = \"primary\"\n  }\n}\n\nresource \"aws_subnet\" \"primary_public\" {\n  count                   = 3\n  vpc_id                  = aws_vpc.primary.id\n  cidr_block              = cidrsubnet(\"10.0.0.0/16\", 8, count.index)\n  availability_zone       = data.aws_availability_zones.primary.names[count.index]\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name = \"${var.environment}-primary-public-${count.index + 1}\"\n    Tier = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"primary_private\" {\n  count             = 3\n  vpc_id            = aws_vpc.primary.id\n  cidr_block        = cidrsubnet(\"10.0.0.0/16\", 8, count.index + 10)\n  availability_zone = data.aws_availability_zones.primary.names[count.index]\n\n  tags = {\n    Name = \"${var.environment}-primary-private-${count.index + 1}\"\n    Tier = \"private\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"primary\" {\n  vpc_id = aws_vpc.primary.id\n  tags   = { Name = \"${var.environment}-primary-igw\" }\n}\n\nresource \"aws_eip\" \"primary_nat\" {\n  domain = \"vpc\"\n  tags   = { Name = \"${var.environment}-primary-nat-eip\" }\n}\n\nresource \"aws_nat_gateway\" \"primary\" {\n  allocation_id = aws_eip.primary_nat.id\n  subnet_id     = aws_subnet.primary_public[0].id\n  tags          = { Name = \"${var.environment}-primary-nat\" }\n\n  depends_on = [aws_internet_gateway.primary]\n}\n\nresource \"aws_route_table\" \"primary_public\" {\n  vpc_id = aws_vpc.primary.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.primary.id\n  }\n\n  tags = { Name = \"${var.environment}-primary-public-rt\" }\n}\n\nresource \"aws_route_table\" \"primary_private\" {\n  vpc_id = aws_vpc.primary.id\n\n  route {\n    cidr_block     = \"0.0.0.0/0\"\n    nat_gateway_id = aws_nat_gateway.primary.id\n  }\n\n  tags = { Name = \"${var.environment}-primary-private-rt\" }\n}\n\nresource \"aws_route_table_association\" \"primary_public\" {\n  count          = 3\n  subnet_id      = aws_subnet.primary_public[count.index].id\n  route_table_id = aws_route_table.primary_public.id\n}\n\nresource \"aws_route_table_association\" \"primary_private\" {\n  count          = 3\n  subnet_id      = aws_subnet.primary_private[count.index].id\n  route_table_id = aws_route_table.primary_private.id\n}\n\n# IMPORTANT: Use non-overlapping CIDR ranges between regions\n# Primary:   10.0.0.0/16\n# Secondary: 10.1.0.0/16\n# This is required for VPC peering to work.\nTFEOF",
      "description": "Create the primary VPC in us-east-1 with public and private subnets, internet gateway, and NAT gateway.",
      "explanation": "The primary region is where all traffic is routed under normal conditions. It has a full networking stack with three availability zones for high availability within the region. Non-overlapping CIDR ranges are essential for VPC peering between regions.",
      "what_it_does": "Displays Terraform configuration for a complete VPC in the primary region with 3 public subnets, 3 private subnets, an internet gateway, NAT gateway, and associated route tables.",
      "next_step": "Next we will create the secondary region VPC with its own networking stack.",
      "cleanup": false
    },
    {
      "name": "Step 3: Create Secondary Region VPC",
      "command": "cat << 'TFEOF'\n# =============================================================\n# SECONDARY REGION VPC (us-west-2)\n# =============================================================\n# The passive region mirrors the primary networking layout.\n# Note every resource uses 'provider = aws.secondary' to deploy\n# into us-west-2 instead of the default us-east-1.\n\n# ---------- secondary-vpc.tf ----------\n\ndata \"aws_availability_zones\" \"secondary\" {\n  provider = aws.secondary\n  state    = \"available\"\n}\n\nresource \"aws_vpc\" \"secondary\" {\n  provider             = aws.secondary\n  cidr_block           = \"10.1.0.0/16\"\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name = \"${var.environment}-secondary-vpc\"\n    Role = \"secondary\"\n  }\n}\n\nresource \"aws_subnet\" \"secondary_public\" {\n  count                   = 3\n  provider                = aws.secondary\n  vpc_id                  = aws_vpc.secondary.id\n  cidr_block              = cidrsubnet(\"10.1.0.0/16\", 8, count.index)\n  availability_zone       = data.aws_availability_zones.secondary.names[count.index]\n  map_public_ip_on_launch = true\n\n  tags = {\n    Name = \"${var.environment}-secondary-public-${count.index + 1}\"\n    Tier = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"secondary_private\" {\n  count             = 3\n  provider          = aws.secondary\n  vpc_id            = aws_vpc.secondary.id\n  cidr_block        = cidrsubnet(\"10.1.0.0/16\", 8, count.index + 10)\n  availability_zone = data.aws_availability_zones.secondary.names[count.index]\n\n  tags = {\n    Name = \"${var.environment}-secondary-private-${count.index + 1}\"\n    Tier = \"private\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"secondary\" {\n  provider = aws.secondary\n  vpc_id   = aws_vpc.secondary.id\n  tags     = { Name = \"${var.environment}-secondary-igw\" }\n}\n\nresource \"aws_eip\" \"secondary_nat\" {\n  provider = aws.secondary\n  domain   = \"vpc\"\n  tags     = { Name = \"${var.environment}-secondary-nat-eip\" }\n}\n\nresource \"aws_nat_gateway\" \"secondary\" {\n  provider      = aws.secondary\n  allocation_id = aws_eip.secondary_nat.id\n  subnet_id     = aws_subnet.secondary_public[0].id\n  tags          = { Name = \"${var.environment}-secondary-nat\" }\n\n  depends_on = [aws_internet_gateway.secondary]\n}\n\nresource \"aws_route_table\" \"secondary_public\" {\n  provider = aws.secondary\n  vpc_id   = aws_vpc.secondary.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.secondary.id\n  }\n\n  tags = { Name = \"${var.environment}-secondary-public-rt\" }\n}\n\nresource \"aws_route_table\" \"secondary_private\" {\n  provider = aws.secondary\n  vpc_id   = aws_vpc.secondary.id\n\n  route {\n    cidr_block     = \"0.0.0.0/0\"\n    nat_gateway_id = aws_nat_gateway.secondary.id\n  }\n\n  tags = { Name = \"${var.environment}-secondary-private-rt\" }\n}\n\nresource \"aws_route_table_association\" \"secondary_public\" {\n  count          = 3\n  provider       = aws.secondary\n  subnet_id      = aws_subnet.secondary_public[count.index].id\n  route_table_id = aws_route_table.secondary_public.id\n}\n\nresource \"aws_route_table_association\" \"secondary_private\" {\n  count          = 3\n  provider       = aws.secondary\n  subnet_id      = aws_subnet.secondary_private[count.index].id\n  route_table_id = aws_route_table.secondary_private.id\n}\n\n# NOTE: The secondary region is a mirror of the primary.\n# In active-passive, this region remains idle until failover.\n# Traffic only routes here when the primary health check fails.\nTFEOF",
      "description": "Create the secondary VPC in us-west-2, mirroring the primary region's network architecture.",
      "explanation": "The secondary region is the passive standby. Every resource explicitly sets 'provider = aws.secondary' to ensure it deploys in us-west-2. The CIDR range (10.1.0.0/16) does not overlap with the primary (10.0.0.0/16), which is a hard requirement for VPC peering.",
      "what_it_does": "Displays Terraform configuration for a complete VPC in the secondary region with the same 3+3 subnet layout, gateways, and route tables, all using the secondary provider alias.",
      "next_step": "Next we will set up VPC peering between the two regions for private connectivity.",
      "cleanup": false
    },
    {
      "name": "Step 4: Set Up VPC Peering",
      "command": "cat << 'TFEOF'\n# =============================================================\n# CROSS-REGION VPC PEERING\n# =============================================================\n# VPC peering creates a private network link between two VPCs,\n# even across regions. Traffic flows over the AWS backbone,\n# not the public internet. Both sides must accept the peering\n# and add routes to their route tables.\n\n# ---------- vpc-peering.tf ----------\n\n# Request peering from primary to secondary\nresource \"aws_vpc_peering_connection\" \"primary_to_secondary\" {\n  vpc_id      = aws_vpc.primary.id\n  peer_vpc_id = aws_vpc.secondary.id\n  peer_region = var.secondary_region\n  auto_accept = false   # Cross-region peering cannot auto-accept\n\n  tags = {\n    Name = \"${var.environment}-primary-to-secondary-peering\"\n    Side = \"requester\"\n  }\n}\n\n# Accept peering in the secondary region\nresource \"aws_vpc_peering_connection_accepter\" \"secondary\" {\n  provider                  = aws.secondary\n  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id\n  auto_accept               = true\n\n  tags = {\n    Name = \"${var.environment}-secondary-accept-peering\"\n    Side = \"accepter\"\n  }\n}\n\n# Configure peering connection options (requester side)\nresource \"aws_vpc_peering_connection_options\" \"requester\" {\n  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id\n\n  requester {\n    allow_remote_vpc_dns_resolution = true\n  }\n\n  depends_on = [aws_vpc_peering_connection_accepter.secondary]\n}\n\n# Configure peering connection options (accepter side)\nresource \"aws_vpc_peering_connection_options\" \"accepter\" {\n  provider                  = aws.secondary\n  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id\n\n  accepter {\n    allow_remote_vpc_dns_resolution = true\n  }\n\n  depends_on = [aws_vpc_peering_connection_accepter.secondary]\n}\n\n# Add route: primary private -> secondary CIDR\nresource \"aws_route\" \"primary_to_secondary\" {\n  route_table_id            = aws_route_table.primary_private.id\n  destination_cidr_block    = aws_vpc.secondary.cidr_block\n  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id\n}\n\n# Add route: secondary private -> primary CIDR\nresource \"aws_route\" \"secondary_to_primary\" {\n  provider                  = aws.secondary\n  route_table_id            = aws_route_table.secondary_private.id\n  destination_cidr_block    = aws_vpc.primary.cidr_block\n  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id\n}\n\n# ARCHITECTURE OVERVIEW:\n#\n#   us-east-1 (Primary)          us-west-2 (Secondary)\n#   +----------------+           +----------------+\n#   | VPC 10.0.0.0/16|<== PEER ==>| VPC 10.1.0.0/16|\n#   |                |           |                |\n#   | Public Subnets |           | Public Subnets |\n#   | Private Subnets|           | Private Subnets|\n#   | NAT Gateway    |           | NAT Gateway    |\n#   +----------------+           +----------------+\n#\n# Cross-region peering requires:\n# 1. A peering request from the requester VPC\n# 2. Acceptance from the accepter VPC\n# 3. Route table entries on BOTH sides\n# 4. Security group rules allowing peered traffic\nTFEOF",
      "description": "Establish a VPC peering connection between primary and secondary regions with route table entries.",
      "explanation": "VPC peering provides private, low-latency connectivity between regions without traversing the public internet. Cross-region peering requires explicit acceptance (cannot auto-accept) and routes must be added to both sides. DNS resolution across the peering link is enabled so services can resolve each other's private hostnames.",
      "what_it_does": "Displays Terraform configuration for creating a VPC peering connection between the primary and secondary VPCs, configuring DNS resolution, and adding the necessary routes to private route tables on both sides.",
      "next_step": "Next we will create Route53 failover records to direct traffic to the active region.",
      "cleanup": false
    },
    {
      "name": "Step 5: Create Route53 Failover Records",
      "command": "cat << 'TFEOF'\n# =============================================================\n# ROUTE53 FAILOVER ROUTING\n# =============================================================\n# Route53 failover routing sends traffic to the primary region\n# by default. If the primary health check fails, DNS\n# automatically resolves to the secondary region.\n\n# ---------- route53-failover.tf ----------\n\ndata \"aws_route53_zone\" \"main\" {\n  name         = var.domain_name\n  private_zone = false\n}\n\n# Health check for the primary region endpoint\nresource \"aws_route53_health_check\" \"primary\" {\n  fqdn              = \"primary-alb.${var.domain_name}\"\n  port              = 443\n  type              = \"HTTPS\"\n  resource_path     = \"/health\"\n  failure_threshold = 3\n  request_interval  = 10\n\n  regions = [\"us-east-1\", \"us-west-2\", \"eu-west-1\"]\n\n  tags = {\n    Name = \"${var.environment}-primary-health-check\"\n  }\n}\n\n# Health check for the secondary region endpoint\nresource \"aws_route53_health_check\" \"secondary\" {\n  fqdn              = \"secondary-alb.${var.domain_name}\"\n  port              = 443\n  type              = \"HTTPS\"\n  resource_path     = \"/health\"\n  failure_threshold = 3\n  request_interval  = 10\n\n  regions = [\"us-east-1\", \"us-west-2\", \"eu-west-1\"]\n\n  tags = {\n    Name = \"${var.environment}-secondary-health-check\"\n  }\n}\n\n# Primary failover record\nresource \"aws_route53_record\" \"app_primary\" {\n  zone_id = data.aws_route53_zone.main.zone_id\n  name    = \"app.${var.domain_name}\"\n  type    = \"A\"\n\n  failover_routing_policy {\n    type = \"PRIMARY\"\n  }\n\n  set_identifier  = \"primary\"\n  health_check_id = aws_route53_health_check.primary.id\n\n  alias {\n    name                   = aws_lb.primary.dns_name\n    zone_id                = aws_lb.primary.zone_id\n    evaluate_target_health = true\n  }\n}\n\n# Secondary failover record\nresource \"aws_route53_record\" \"app_secondary\" {\n  zone_id = data.aws_route53_zone.main.zone_id\n  name    = \"app.${var.domain_name}\"\n  type    = \"A\"\n\n  failover_routing_policy {\n    type = \"SECONDARY\"\n  }\n\n  set_identifier  = \"secondary\"\n  health_check_id = aws_route53_health_check.secondary.id\n\n  alias {\n    name                   = aws_lb.secondary.dns_name\n    zone_id                = aws_lb.secondary.zone_id\n    evaluate_target_health = true\n  }\n}\n\n# FAILOVER FLOW:\n#\n# User -> DNS (app.example.com)\n#           |\n#           v\n#   Health Check: Primary OK?\n#       YES -> Route to Primary ALB (us-east-1)\n#       NO  -> Route to Secondary ALB (us-west-2)\n#\n# Key settings:\n# - failure_threshold: 3 consecutive failures trigger failover\n# - request_interval: 10 seconds between health checks\n# - Multiple checker regions eliminate false positives\n# - evaluate_target_health: Also checks ALB target health\nTFEOF",
      "description": "Configure Route53 failover routing with health checks to automatically direct traffic to the healthy region.",
      "explanation": "Route53 failover routing is the core of active-passive architecture. Health checkers in multiple AWS regions continuously poll the primary endpoint. After three consecutive failures (30 seconds with 10-second intervals), DNS automatically resolves to the secondary region. The evaluate_target_health setting adds an extra layer by checking ALB target group health as well.",
      "what_it_does": "Displays Terraform configuration for Route53 health checks on both regions and failover DNS records that automatically route app.example.com to the secondary ALB when the primary becomes unhealthy.",
      "next_step": "Next we will configure a cross-region RDS read replica for database failover.",
      "cleanup": false
    },
    {
      "name": "Step 6: Configure Cross-Region RDS Replica",
      "command": "cat << 'TFEOF'\n# =============================================================\n# CROSS-REGION RDS REPLICA\n# =============================================================\n# The primary RDS instance handles all writes. A cross-region\n# read replica in the secondary region can be promoted to a\n# standalone master during failover.\n\n# ---------- rds.tf ----------\n\nresource \"aws_db_subnet_group\" \"primary\" {\n  name       = \"${var.environment}-primary-db-subnet\"\n  subnet_ids = aws_subnet.primary_private[*].id\n\n  tags = { Name = \"${var.environment}-primary-db-subnet-group\" }\n}\n\nresource \"aws_db_subnet_group\" \"secondary\" {\n  provider   = aws.secondary\n  name       = \"${var.environment}-secondary-db-subnet\"\n  subnet_ids = aws_subnet.secondary_private[*].id\n\n  tags = { Name = \"${var.environment}-secondary-db-subnet-group\" }\n}\n\nresource \"aws_security_group\" \"rds_primary\" {\n  name_prefix = \"${var.environment}-rds-primary-\"\n  vpc_id      = aws_vpc.primary.id\n\n  ingress {\n    from_port   = 5432\n    to_port     = 5432\n    protocol    = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/16\", \"10.1.0.0/16\"]\n    description = \"PostgreSQL from both VPCs\"\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = { Name = \"${var.environment}-rds-primary-sg\" }\n}\n\nresource \"aws_security_group\" \"rds_secondary\" {\n  provider    = aws.secondary\n  name_prefix = \"${var.environment}-rds-secondary-\"\n  vpc_id      = aws_vpc.secondary.id\n\n  ingress {\n    from_port   = 5432\n    to_port     = 5432\n    protocol    = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/16\", \"10.1.0.0/16\"]\n    description = \"PostgreSQL from both VPCs\"\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = { Name = \"${var.environment}-rds-secondary-sg\" }\n}\n\n# Primary RDS instance\nresource \"aws_db_instance\" \"primary\" {\n  identifier     = \"${var.environment}-primary-db\"\n  engine         = \"postgres\"\n  engine_version = \"15.4\"\n  instance_class = \"db.r6g.large\"\n\n  allocated_storage     = 100\n  max_allocated_storage = 500\n  storage_type          = \"gp3\"\n  storage_encrypted     = true\n\n  db_name  = \"appdb\"\n  username = \"dbadmin\"\n  password = var.db_password   # Use AWS Secrets Manager in production\n\n  multi_az               = true\n  db_subnet_group_name   = aws_db_subnet_group.primary.name\n  vpc_security_group_ids = [aws_security_group.rds_primary.id]\n\n  backup_retention_period = 7\n  backup_window           = \"03:00-04:00\"\n  maintenance_window      = \"Mon:04:00-Mon:05:00\"\n\n  deletion_protection = true\n  skip_final_snapshot = false\n  final_snapshot_identifier = \"${var.environment}-primary-db-final\"\n\n  tags = { Name = \"${var.environment}-primary-db\" }\n}\n\n# Cross-region read replica\nresource \"aws_db_instance\" \"secondary_replica\" {\n  provider = aws.secondary\n\n  identifier          = \"${var.environment}-secondary-db-replica\"\n  replicate_source_db = aws_db_instance.primary.arn   # ARN for cross-region\n\n  instance_class = \"db.r6g.large\"\n  storage_type   = \"gp3\"\n\n  db_subnet_group_name   = aws_db_subnet_group.secondary.name\n  vpc_security_group_ids = [aws_security_group.rds_secondary.id]\n\n  # Replica-specific settings\n  multi_az            = false   # Can enable for extra HA in DR region\n  storage_encrypted   = true\n  deletion_protection = true\n  skip_final_snapshot = true\n\n  tags = { Name = \"${var.environment}-secondary-db-replica\" }\n}\n\n# FAILOVER PROCEDURE:\n# 1. Promote the read replica: aws rds promote-read-replica\n# 2. Update application connection strings\n# 3. The replica becomes an independent master\n# 4. This is a manual step - automate with Lambda + CloudWatch\n#\n# WARNING: Promoting a replica is a one-way operation.\n# After promotion, you must set up replication again.\nTFEOF",
      "description": "Deploy the primary RDS instance and a cross-region read replica for database-level disaster recovery.",
      "explanation": "Cross-region RDS read replicas use asynchronous replication to keep a near real-time copy of the database in the secondary region. During failover, the replica is promoted to become an independent primary. This is a one-way operation: once promoted, the original replication link is broken and must be re-established. Note the use of ARN (not identifier) for cross-region replication.",
      "what_it_does": "Displays Terraform configuration for a primary RDS PostgreSQL instance in us-east-1 with Multi-AZ enabled, and a cross-region read replica in us-west-2 with its own subnet group and security group.",
      "next_step": "Next we will set up AWS Global Accelerator for performance and automatic failover.",
      "cleanup": false
    },
    {
      "name": "Step 7: Set Up Global Accelerator",
      "command": "cat << 'TFEOF'\n# =============================================================\n# AWS GLOBAL ACCELERATOR\n# =============================================================\n# Global Accelerator provides static IP addresses and routes\n# traffic over the AWS global network for better performance.\n# It can automatically failover between regional endpoints.\n\n# ---------- global-accelerator.tf ----------\n\nresource \"aws_globalaccelerator_accelerator\" \"app\" {\n  name            = \"${var.environment}-app-accelerator\"\n  ip_address_type = \"IPV4\"\n  enabled         = true\n\n  attributes {\n    flow_logs_enabled   = true\n    flow_logs_s3_bucket = aws_s3_bucket.accelerator_logs.id\n    flow_logs_s3_prefix = \"globalaccelerator/\"\n  }\n\n  tags = {\n    Name = \"${var.environment}-global-accelerator\"\n  }\n}\n\nresource \"aws_globalaccelerator_listener\" \"app\" {\n  accelerator_arn = aws_globalaccelerator_accelerator.app.id\n  protocol        = \"TCP\"\n\n  port_range {\n    from_port = 443\n    to_port   = 443\n  }\n}\n\n# Primary endpoint group (100% traffic when healthy)\nresource \"aws_globalaccelerator_endpoint_group\" \"primary\" {\n  listener_arn = aws_globalaccelerator_listener.app.id\n\n  endpoint_group_region         = var.primary_region\n  health_check_port             = 443\n  health_check_protocol         = \"HTTPS\"\n  health_check_path             = \"/health\"\n  health_check_interval_seconds = 10\n  threshold_count               = 3\n  traffic_dial_percentage        = 100\n\n  endpoint_configuration {\n    endpoint_id                    = aws_lb.primary.arn\n    weight                         = 100\n    client_ip_preservation_enabled = true\n  }\n}\n\n# Secondary endpoint group (failover target)\nresource \"aws_globalaccelerator_endpoint_group\" \"secondary\" {\n  listener_arn = aws_globalaccelerator_listener.app.id\n\n  endpoint_group_region         = var.secondary_region\n  health_check_port             = 443\n  health_check_protocol         = \"HTTPS\"\n  health_check_path             = \"/health\"\n  health_check_interval_seconds = 10\n  threshold_count               = 3\n  traffic_dial_percentage        = 100\n\n  endpoint_configuration {\n    endpoint_id                    = aws_lb.secondary.arn\n    weight                         = 100\n    client_ip_preservation_enabled = true\n  }\n}\n\n# ---------- outputs.tf ----------\n\noutput \"global_accelerator_ips\" {\n  description = \"Static IP addresses for the Global Accelerator\"\n  value       = aws_globalaccelerator_accelerator.app.ip_sets[0].ip_addresses\n}\n\noutput \"global_accelerator_dns\" {\n  description = \"DNS name for the Global Accelerator\"\n  value       = aws_globalaccelerator_accelerator.app.dns_name\n}\n\noutput \"primary_vpc_id\" {\n  value = aws_vpc.primary.id\n}\n\noutput \"secondary_vpc_id\" {\n  value = aws_vpc.secondary.id\n}\n\noutput \"primary_rds_endpoint\" {\n  value     = aws_db_instance.primary.endpoint\n  sensitive = true\n}\n\noutput \"secondary_rds_endpoint\" {\n  value     = aws_db_instance.secondary_replica.endpoint\n  sensitive = true\n}\n\n# GLOBAL ACCELERATOR vs ROUTE53 FAILOVER:\n#\n# Global Accelerator:\n# - Static IP addresses (no DNS caching issues)\n# - Traffic routed over AWS backbone network\n# - Failover in ~30 seconds\n# - Better for TCP/UDP workloads\n# - Costs: ~$0.025/hr + data transfer\n#\n# Route53 Failover:\n# - DNS-based (subject to TTL caching)\n# - Failover depends on DNS TTL (60-300 seconds)\n# - No additional data transfer costs\n# - Better for HTTP/HTTPS with CDN integration\n#\n# BEST PRACTICE: Use both! Global Accelerator handles\n# immediate failover while Route53 provides DNS-level routing.\nTFEOF",
      "description": "Configure AWS Global Accelerator with endpoint groups in both regions for fast failover with static IPs.",
      "explanation": "Global Accelerator provides two static anycast IP addresses that route traffic over the AWS global network. Unlike Route53 which relies on DNS TTLs, Global Accelerator can failover in roughly 30 seconds because there is no DNS caching involved. Using both Route53 and Global Accelerator together provides defense in depth for failover.",
      "what_it_does": "Displays Terraform configuration for an AWS Global Accelerator with a listener on port 443, primary and secondary endpoint groups pointing to regional ALBs, health checking configuration, and outputs for the static IPs and DNS name.",
      "next_step": "Next we will verify the complete failover architecture and review testing strategies.",
      "cleanup": false
    },
    {
      "name": "Step 8: Verify Failover Setup",
      "command": "echo '============================================================='\necho ' MULTI-REGION ACTIVE-PASSIVE VERIFICATION CHECKLIST'\necho '============================================================='\necho ''\necho '1. INFRASTRUCTURE VERIFICATION:'\necho '   terraform plan              # Review all resources across both regions'\necho '   terraform apply             # Deploy to both regions'\necho '   terraform state list        # Verify resources in state'\necho ''\necho '2. NETWORKING TESTS:'\necho '   # Verify VPC peering is active'\necho '   aws ec2 describe-vpc-peering-connections --region us-east-1'\necho '   # Test connectivity from primary to secondary'\necho '   # (SSH to an instance in primary, ping 10.1.x.x)'\necho ''\necho '3. DNS FAILOVER TEST:'\necho '   # Check current DNS resolution'\necho '   dig app.example.com'\necho '   # Verify health checks are healthy'\necho '   aws route53 get-health-check-status --health-check-id <id>'\necho '   # Simulate failure: stop the primary application'\necho '   # Watch DNS flip to secondary (may take 30-60 seconds)'\necho ''\necho '4. DATABASE FAILOVER TEST:'\necho '   # Check replication status'\necho '   aws rds describe-db-instances --db-instance-identifier prod-secondary-db-replica'\necho '   # Verify replication lag'\necho '   # Promote replica (CAUTION: one-way operation!)'\necho '   # aws rds promote-read-replica --db-instance-identifier prod-secondary-db-replica'\necho ''\necho '5. GLOBAL ACCELERATOR TEST:'\necho '   # Get static IPs'\necho '   terraform output global_accelerator_ips'\necho '   # Test connectivity'\necho '   curl -v https://<accelerator-dns>/health'\necho '   # Check endpoint health'\necho '   aws globalaccelerator list-endpoint-groups --listener-arn <arn>'\necho ''\necho '6. FULL FAILOVER DRILL:'\necho '   a) Document current primary state'\necho '   b) Stop primary region application/ALB'\necho '   c) Verify Route53 fails over (dig + curl)'\necho '   d) Verify Global Accelerator fails over'\necho '   e) Promote RDS replica if needed'\necho '   f) Verify secondary region serves traffic'\necho '   g) Document RTO (Recovery Time Objective) achieved'\necho '   h) Restore primary and re-establish replication'\necho ''\necho '============================================================='\necho ' TARGET METRICS:'\necho '   RTO (Recovery Time Objective): < 5 minutes'\necho '   RPO (Recovery Point Objective): < 1 minute (async replication)'\necho '   DNS Failover Time: ~30 seconds (Route53)'\necho '   GA Failover Time:  ~30 seconds (Global Accelerator)'\necho '============================================================='",
      "description": "Review the complete failover architecture and walk through testing and verification procedures.",
      "explanation": "A multi-region active-passive architecture is only as good as its last failover test. Regular drills are essential to validate that DNS failover, database promotion, and Global Accelerator routing all work correctly. Document your RTO and RPO metrics after each drill to track improvements and identify bottlenecks.",
      "what_it_does": "Displays a comprehensive verification checklist covering infrastructure validation, networking tests, DNS failover testing, database failover procedures, Global Accelerator testing, and a full failover drill procedure with target metrics.",
      "next_step": "When done reviewing, proceed to cleanup to remove temporary files.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo '=== Cleanup: Multi-Region Active-Passive Scenario ===' && echo '' && echo 'In a real environment, destroy in reverse dependency order:' && echo '' && echo '  # 1. Remove Global Accelerator' && echo '  terraform destroy -target=aws_globalaccelerator_endpoint_group.secondary' && echo '  terraform destroy -target=aws_globalaccelerator_endpoint_group.primary' && echo '  terraform destroy -target=aws_globalaccelerator_listener.app' && echo '  terraform destroy -target=aws_globalaccelerator_accelerator.app' && echo '' && echo '  # 2. Remove Route53 records and health checks' && echo '  terraform destroy -target=aws_route53_record.app_secondary' && echo '  terraform destroy -target=aws_route53_record.app_primary' && echo '  terraform destroy -target=aws_route53_health_check.secondary' && echo '  terraform destroy -target=aws_route53_health_check.primary' && echo '' && echo '  # 3. Remove RDS (disable deletion_protection first!)' && echo '  # Edit terraform: deletion_protection = false, then apply' && echo '  terraform destroy -target=aws_db_instance.secondary_replica' && echo '  terraform destroy -target=aws_db_instance.primary' && echo '' && echo '  # 4. Remove VPC peering' && echo '  terraform destroy -target=aws_vpc_peering_connection.primary_to_secondary' && echo '' && echo '  # 5. Remove all networking (or just destroy everything)' && echo '  terraform destroy' && echo '' && echo 'Scenario complete! You have learned multi-region active-passive architecture.' && echo ''",
      "description": "Clean up all resources created during this scenario.",
      "explanation": "Multi-region infrastructure must be destroyed in the correct order to avoid dependency errors. Global Accelerator and Route53 records should be removed first, then RDS instances (after disabling deletion protection), then VPC peering, and finally the VPCs themselves. Alternatively, 'terraform destroy' handles the ordering automatically.",
      "what_it_does": "Displays the recommended destroy order for multi-region resources and confirms scenario completion.",
      "next_step": "Scenario complete. Consider exploring the blue-green deployment scenario next.",
      "cleanup": true
    }
  ]
}
