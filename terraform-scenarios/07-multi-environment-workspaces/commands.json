{
  "scenario_id": "07-multi-environment-workspaces",
  "difficulty": "medium",
  "duration": "25 min",
  "commands": [
    {
      "name": "Step 1: Understand the Workspace Concept",
      "command": "echo '=== Terraform Workspaces ==='\necho ''\necho 'Workspaces allow you to manage multiple environments (dev, staging, prod)'\necho 'from a SINGLE set of Terraform configuration files.'\necho ''\necho 'Each workspace has its own:'\necho '  - State file (terraform.tfstate)'\necho '  - Variable values (via terraform.workspace)'\necho '  - Completely isolated resources'\necho ''\necho '=== How it works ==='\necho ''\necho '  terraform workspace new dev      # Creates a new workspace'\necho '  terraform workspace new staging   # Each has its own state'\necho '  terraform workspace new prod      # No cross-contamination'\necho '  terraform workspace select dev    # Switch to dev'\necho '  terraform workspace list          # List all workspaces'\necho ''\necho '=== State file locations (local backend) ==='\necho ''\necho '  default workspace:  terraform.tfstate'\necho '  named workspaces:   terraform.tfstate.d/<name>/terraform.tfstate'\necho ''\necho '  terraform.tfstate.d/'\necho '    dev/terraform.tfstate'\necho '    staging/terraform.tfstate'\necho '    prod/terraform.tfstate'\necho ''\necho '=== The magic variable: terraform.workspace ==='\necho ''\necho '  Returns the name of the current workspace as a string.'\necho '  Use it in resource names, conditionals, and lookups:'\necho '    Name = \"myapp-${terraform.workspace}\"  ->  \"myapp-dev\" or \"myapp-prod\"'",
      "description": "Learn the Terraform workspace concept and how it isolates environment state",
      "explanation": "Terraform workspaces provide a way to maintain multiple state files from the same configuration directory. By default, every Terraform project starts in the 'default' workspace. When you create named workspaces, Terraform stores each workspace's state in a separate file. The built-in terraform.workspace variable returns the current workspace name, which you can use in resource names, conditionals, and lookups to customize behavior per environment.",
      "what_it_does": "Displays an overview of Terraform workspaces, the commands to create and switch between them, how state files are organized per workspace, and the terraform.workspace variable.",
      "next_step": "Next we will create dev, staging, and prod workspaces.",
      "cleanup": false
    },
    {
      "name": "Step 2: Create Dev, Staging, and Prod Workspaces",
      "command": "echo '=== Creating workspaces ==='\necho ''\necho '$ terraform workspace new dev'\necho 'Created and switched to workspace \"dev\"!'\necho ''\necho '$ terraform workspace new staging'\necho 'Created and switched to workspace \"staging\"!'\necho ''\necho '$ terraform workspace new prod'\necho 'Created and switched to workspace \"prod\"!'\necho ''\necho '$ terraform workspace list'\necho '  default'\necho '  dev'\necho '  staging'\necho '* prod'\necho ''\necho 'The asterisk (*) marks the currently active workspace.'\necho ''\necho '=== S3 backend with workspaces ==='\necho ''\necho 'With a remote S3 backend, workspace state is stored at:'\necho ''\ncat << 'TFEOF'\nterraform {\n  backend \"s3\" {\n    bucket         = \"mycompany-terraform-state\"\n    key            = \"web-app/terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"terraform-locks\"\n    encrypt        = true\n  }\n}\n\n# State paths in S3:\n#   env:/dev/web-app/terraform.tfstate\n#   env:/staging/web-app/terraform.tfstate\n#   env:/prod/web-app/terraform.tfstate\n#\n# DynamoDB lock keys:\n#   env:/dev/web-app/terraform.tfstate-md5\n#   env:/staging/web-app/terraform.tfstate-md5\n#   env:/prod/web-app/terraform.tfstate-md5\nTFEOF",
      "description": "Create three workspaces and understand how state is organized per workspace in S3",
      "explanation": "Creating a workspace is simple -- 'terraform workspace new <name>' creates it and switches to it automatically. When using an S3 backend, Terraform prefixes the state key with 'env:/<workspace>/' to keep states separate. Each workspace also gets its own DynamoDB lock, so parallel applies to dev and prod never conflict. The 'default' workspace uses the key as-is without a prefix, which is why many teams avoid using it.",
      "what_it_does": "Simulates creating dev, staging, and prod workspaces, shows the workspace list output, and demonstrates how S3 backend organizes state files per workspace.",
      "next_step": "Now let's use terraform.workspace in resource naming.",
      "cleanup": false
    },
    {
      "name": "Step 3: Use terraform.workspace in Resource Naming",
      "command": "cat << 'TFEOF'\n# main.tf - Workspace-aware resource naming\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n\n  default_tags {\n    tags = {\n      Environment = terraform.workspace\n      ManagedBy   = \"terraform\"\n      Project     = \"web-platform\"\n    }\n  }\n}\n\nlocals {\n  # All resource names include the workspace for isolation\n  name_prefix = \"web-platform-${terraform.workspace}\"\n}\n\n# VPC: each workspace gets its own network\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n\n  tags = {\n    Name = \"${local.name_prefix}-vpc\"\n  }\n}\n\n# Example resource names per workspace:\n#   dev:     \"web-platform-dev-vpc\"\n#   staging: \"web-platform-staging-vpc\"\n#   prod:    \"web-platform-prod-vpc\"\n\nresource \"aws_subnet\" \"app\" {\n  count = 2\n\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(var.vpc_cidr, 8, count.index)\n  availability_zone = data.aws_availability_zones.available.names[count.index]\n\n  tags = {\n    Name = \"${local.name_prefix}-app-${count.index + 1}\"\n  }\n}\n\nresource \"aws_db_instance\" \"main\" {\n  identifier     = \"${local.name_prefix}-db\"\n  engine         = \"postgres\"\n  engine_version = \"15.4\"\n  instance_class = var.db_instance_class\n  db_name        = \"app_${replace(terraform.workspace, \"-\", \"_\")}\"\n\n  tags = {\n    Name = \"${local.name_prefix}-db\"\n  }\n}\nTFEOF\necho ''\necho '=== Key pattern: ${terraform.workspace} in names ==='\necho ''\necho 'This ensures resources across environments never collide:'\necho '  - VPC:      web-platform-dev-vpc vs web-platform-prod-vpc'\necho '  - DB:       web-platform-dev-db vs web-platform-prod-db'\necho '  - DB name:  app_dev vs app_prod (no hyphens in DB names)'",
      "description": "Use terraform.workspace in resource names and tags for environment isolation",
      "explanation": "The terraform.workspace variable is a string containing the current workspace name. By embedding it in resource names, tags, and identifiers, you ensure that resources from different environments never collide -- even within the same AWS account. The default_tags block automatically tags every resource with the environment name. Note the replace() function for database names, which cannot contain hyphens. The cidrsubnet() function dynamically calculates subnet CIDRs from the VPC CIDR.",
      "what_it_does": "Displays a main.tf configuration where every resource name includes terraform.workspace, showing how VPCs, subnets, and databases are named differently per environment.",
      "next_step": "Next we will implement conditional sizing per workspace using lookup maps.",
      "cleanup": false
    },
    {
      "name": "Step 4: Conditional Sizing per Workspace with Lookup Maps",
      "command": "cat << 'TFEOF'\n# variables.tf - Workspace-aware sizing with lookup maps\n\n# Define sizing maps: workspace name -> value\nvariable \"instance_type_map\" {\n  description = \"EC2 instance type per environment\"\n  type        = map(string)\n  default = {\n    dev     = \"t3.micro\"\n    staging = \"t3.small\"\n    prod    = \"t3.large\"\n  }\n}\n\nvariable \"instance_count_map\" {\n  description = \"Number of instances per environment\"\n  type        = map(number)\n  default = {\n    dev     = 1\n    staging = 2\n    prod    = 3\n  }\n}\n\nvariable \"db_instance_class_map\" {\n  description = \"RDS instance class per environment\"\n  type        = map(string)\n  default = {\n    dev     = \"db.t3.micro\"\n    staging = \"db.t3.small\"\n    prod    = \"db.r6g.large\"\n  }\n}\n\nvariable \"db_multi_az_map\" {\n  description = \"Whether to enable Multi-AZ for RDS\"\n  type        = map(bool)\n  default = {\n    dev     = false\n    staging = false\n    prod    = true\n  }\n}\n\nvariable \"vpc_cidr\" {\n  description = \"VPC CIDR block\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"db_instance_class\" {\n  description = \"RDS instance class (overridden by workspace map)\"\n  type        = string\n  default     = \"db.t3.micro\"\n}\n\n# ========================================\n# Usage in main.tf with lookup()\n# ========================================\n\n# locals {\n#   instance_type  = lookup(var.instance_type_map, terraform.workspace, \"t3.micro\")\n#   instance_count = lookup(var.instance_count_map, terraform.workspace, 1)\n#   db_class       = lookup(var.db_instance_class_map, terraform.workspace, \"db.t3.micro\")\n#   db_multi_az    = lookup(var.db_multi_az_map, terraform.workspace, false)\n# }\nTFEOF\necho ''\necho '=== How lookup() works ==='\necho ''\necho '  lookup(map, key, default)'\necho ''\necho '  lookup(var.instance_type_map, \"prod\", \"t3.micro\")'\necho '    -> Returns \"t3.large\"'\necho ''\necho '  lookup(var.instance_type_map, \"unknown\", \"t3.micro\")'\necho '    -> Returns \"t3.micro\" (default fallback)'\necho ''\necho '=== Result per workspace ==='\necho ''\necho '  dev:     t3.micro,  1 instance,  db.t3.micro,   single-AZ'\necho '  staging: t3.small,  2 instances, db.t3.small,   single-AZ'\necho '  prod:    t3.large,  3 instances, db.r6g.large,  multi-AZ'",
      "description": "Implement environment-specific sizing using lookup maps keyed by workspace name",
      "explanation": "Lookup maps are the most common pattern for workspace-based sizing. You define a map variable where keys are workspace names and values are the configuration for that environment. The lookup() function retrieves the value for the current workspace, with a fallback default for unknown workspaces. This approach is much cleaner than long chains of conditional expressions. Dev gets minimal resources for cost savings, staging mirrors prod at a smaller scale, and prod gets full production sizing with multi-AZ for high availability.",
      "what_it_does": "Displays variables.tf with four lookup maps for instance type, count, database class, and multi-AZ settings per environment, plus examples showing how lookup() resolves values for each workspace.",
      "next_step": "Next we will create workspace-specific tfvars files.",
      "cleanup": false
    },
    {
      "name": "Step 5: Workspace-Specific tfvars Files",
      "command": "echo '=== Environment-specific variable files ==='\necho ''\necho 'For values that differ per environment but are NOT in lookup maps'\necho '(secrets, domain names, account IDs), use tfvars files:'\necho ''\ncat << 'TFEOF'\n# environments/dev.tfvars\nvpc_cidr         = \"10.1.0.0/16\"\ndomain_name      = \"dev.myapp.internal\"\nssl_certificate  = \"arn:aws:acm:us-east-1:111111111111:certificate/dev-cert-id\"\nenable_monitoring = false\nlog_retention     = 7\nalarm_email       = \"dev-team@company.com\"\nTFEOF\necho ''\ncat << 'TFEOF'\n# environments/staging.tfvars\nvpc_cidr         = \"10.2.0.0/16\"\ndomain_name      = \"staging.myapp.com\"\nssl_certificate  = \"arn:aws:acm:us-east-1:222222222222:certificate/staging-cert-id\"\nenable_monitoring = true\nlog_retention     = 30\nalarm_email       = \"staging-alerts@company.com\"\nTFEOF\necho ''\ncat << 'TFEOF'\n# environments/prod.tfvars\nvpc_cidr         = \"10.0.0.0/16\"\ndomain_name      = \"myapp.com\"\nssl_certificate  = \"arn:aws:acm:us-east-1:333333333333:certificate/prod-cert-id\"\nenable_monitoring = true\nlog_retention     = 90\nalarm_email       = \"prod-critical@company.com\"\nTFEOF\necho ''\necho '=== Usage ==='\necho ''\necho '  terraform workspace select dev'\necho '  terraform plan -var-file=environments/dev.tfvars'\necho '  terraform apply -var-file=environments/dev.tfvars'\necho ''\necho '  terraform workspace select prod'\necho '  terraform plan -var-file=environments/prod.tfvars'\necho '  terraform apply -var-file=environments/prod.tfvars'\necho ''\necho '=== Automation with scripts ==='\necho ''\necho '  # deploy.sh'\necho '  ENV=$1'\necho '  terraform workspace select $ENV'\necho '  terraform apply -var-file=environments/${ENV}.tfvars -auto-approve'",
      "description": "Create workspace-specific tfvars files for environment-specific configuration",
      "explanation": "While lookup maps work great for sizing, some values are fundamentally different per environment -- like VPC CIDRs, domain names, SSL certificates, and alarm recipients. Terraform variable files (.tfvars) let you define these values externally. By convention, you store them in an environments/ directory and pass the correct file with -var-file. This pairs naturally with workspaces: select the workspace, then apply with the matching tfvars file. Automation scripts can combine both steps.",
      "what_it_does": "Displays three tfvars files (dev, staging, prod) with environment-specific values like VPC CIDRs, domains, and monitoring settings, plus the commands to apply them per workspace.",
      "next_step": "Let's see how to list and switch between workspaces.",
      "cleanup": false
    },
    {
      "name": "Step 6: List and Switch Workspaces",
      "command": "echo '=== Workspace management commands ==='\necho ''\necho '$ terraform workspace list'\necho '  default'\necho '  dev'\necho '  staging'\necho '* prod'\necho ''\necho '$ terraform workspace select dev'\necho 'Switched to workspace \"dev\".'\necho ''\necho '$ terraform workspace show'\necho 'dev'\necho ''\necho '$ terraform workspace select staging'\necho 'Switched to workspace \"staging\".'\necho ''\necho '=== Advanced: workspace in conditionals ==='\necho ''\ncat << 'TFEOF'\n# Enable deletion protection only in prod\nresource \"aws_db_instance\" \"main\" {\n  identifier           = \"${local.name_prefix}-db\"\n  engine               = \"postgres\"\n  instance_class       = local.db_class\n  multi_az             = local.db_multi_az\n  deletion_protection  = terraform.workspace == \"prod\" ? true : false\n  skip_final_snapshot  = terraform.workspace != \"prod\" ? true : false\n\n  # Backup retention: 1 day for dev, 7 for staging, 35 for prod\n  backup_retention_period = lookup({\n    dev     = 1\n    staging = 7\n    prod    = 35\n  }, terraform.workspace, 1)\n}\n\n# Only create WAF in prod\nresource \"aws_wafv2_web_acl\" \"main\" {\n  count = terraform.workspace == \"prod\" ? 1 : 0\n\n  name  = \"${local.name_prefix}-waf\"\n  scope = \"REGIONAL\"\n  # ... WAF rules ...\n}\nTFEOF\necho ''\necho '=== Conditional patterns ==='\necho '  terraform.workspace == \"prod\"           -> boolean'\necho '  terraform.workspace == \"prod\" ? 1 : 0   -> count toggle'\necho '  terraform.workspace != \"prod\"           -> negation'",
      "description": "List and switch workspaces, and use workspace conditionals for prod-only resources",
      "explanation": "Workspace management is straightforward with list, select, and show commands. The real power comes from using terraform.workspace in conditional expressions. The ternary operator (condition ? true_val : false_val) lets you enable deletion protection only in prod, skip final snapshots in dev, and adjust backup retention per environment. The count = terraform.workspace == \"prod\" ? 1 : 0 pattern conditionally creates entire resources -- the WAF only exists in prod, saving costs in lower environments.",
      "what_it_does": "Demonstrates workspace switching commands, then shows advanced conditional patterns using terraform.workspace for deletion protection, backup retention, and conditional resource creation.",
      "next_step": "Let's compare workspaces with the directory-based approach.",
      "cleanup": false
    },
    {
      "name": "Step 7: Best Practices vs Directory-Based Approach",
      "command": "echo '=== Approach 1: Workspaces ==='\necho ''\necho '  project/'\necho '    main.tf'\necho '    variables.tf'\necho '    environments/'\necho '      dev.tfvars'\necho '      staging.tfvars'\necho '      prod.tfvars'\necho ''\necho '  Pros:'\necho '    + Single codebase, no duplication'\necho '    + Easy to add new environments'\necho '    + Built-in Terraform feature'\necho '  Cons:'\necho '    - All environments share the same code version'\necho '    - Accidental apply to wrong workspace is risky'\necho '    - Complex conditionals for environment differences'\necho ''\necho '=== Approach 2: Directory-Based ==='\necho ''\necho '  project/'\necho '    modules/'\necho '      web-app/'\necho '    environments/'\necho '      dev/'\necho '        main.tf          <- calls ../modules/web-app'\necho '        terraform.tfvars'\necho '        backend.tf       <- separate state per directory'\necho '      staging/'\necho '        main.tf'\necho '        terraform.tfvars'\necho '        backend.tf'\necho '      prod/'\necho '        main.tf'\necho '        terraform.tfvars'\necho '        backend.tf'\necho ''\necho '  Pros:'\necho '    + Each environment can pin a different module version'\necho '    + No risk of accidental cross-environment apply'\necho '    + Easier to review changes per environment'\necho '    + Can promote changes: dev -> staging -> prod'\necho '  Cons:'\necho '    - More files to maintain'\necho '    - Need to keep environments in sync manually'\necho ''\necho '=== Industry Recommendation ==='\necho ''\necho '  Small teams / simple infra  -> Workspaces work fine'\necho '  Large teams / complex infra  -> Directory-based + modules'\necho '  Enterprise / strict compliance -> Separate repos per environment'\necho ''\necho '  Many companies use BOTH: workspaces for minor variations,'\necho '  directories for major environment differences.'",
      "description": "Compare workspace-based vs directory-based environment management strategies",
      "explanation": "This is one of the most debated topics in Terraform. Workspaces are simpler but riskier -- a 'terraform apply' in the wrong workspace can affect production. The directory-based approach duplicates some configuration but provides stronger isolation and allows different environments to use different module versions, enabling staged rollouts. Most production teams lean toward the directory-based approach with shared modules, but workspaces are perfectly valid for smaller projects. The key is choosing one strategy and being consistent.",
      "what_it_does": "Compares workspace-based and directory-based environment strategies side by side, listing the pros and cons of each, with industry recommendations for different team sizes.",
      "next_step": "Let's review a summary of everything we covered.",
      "cleanup": false
    },
    {
      "name": "Step 8: Summary and Key Takeaways",
      "command": "echo '=== Workspace Commands Summary ==='\necho ''\necho '  terraform workspace new <name>        Create workspace'\necho '  terraform workspace select <name>     Switch workspace'\necho '  terraform workspace list               List all workspaces'\necho '  terraform workspace show               Show current workspace'\necho '  terraform workspace delete <name>      Delete workspace'\necho ''\necho '=== Key Patterns ==='\necho ''\necho '  1. Naming:     \"${var.app}-${terraform.workspace}-resource\"'\necho '  2. Sizing:     lookup(var.instance_type_map, terraform.workspace, default)'\necho '  3. Toggles:    count = terraform.workspace == \"prod\" ? 1 : 0'\necho '  4. Tfvars:     terraform apply -var-file=environments/${ENV}.tfvars'\necho '  5. Tags:       Environment = terraform.workspace'\necho ''\necho '=== Common Mistakes to Avoid ==='\necho ''\necho '  1. Forgetting to switch workspace before apply'\necho '     Fix: Always run \"terraform workspace show\" first'\necho '  2. Using \"default\" workspace for real infrastructure'\necho '     Fix: Create named workspaces; leave default empty'\necho '  3. Hardcoding environment names in resources'\necho '     Fix: Always use terraform.workspace variable'\necho '  4. Different infrastructure shapes per workspace'\necho '     Fix: Keep shapes similar; use directory-based for big differences'\necho ''\necho '=== CI/CD Integration ==='\necho ''\necho '  # GitHub Actions / GitLab CI pattern:'\necho '  terraform workspace select ${ENVIRONMENT}'\necho '  terraform plan -var-file=environments/${ENVIRONMENT}.tfvars -out=plan.tfplan'\necho '  # Manual approval gate here'\necho '  terraform apply plan.tfplan'",
      "description": "Review all workspace commands, key patterns, common mistakes, and CI/CD integration",
      "explanation": "This summary consolidates the essential workspace patterns. The five key patterns cover naming, sizing, conditional resources, variable files, and tagging. The common mistakes section highlights the most frequent issues teams encounter -- especially the risk of applying to the wrong workspace. In CI/CD pipelines, the workspace is typically selected based on the branch or deployment target, and a plan file ensures the exact reviewed changes are applied.",
      "what_it_does": "Provides a complete reference of workspace commands, five essential patterns for workspace-aware configuration, common mistakes to avoid, and a CI/CD integration example.",
      "next_step": "Final step: cleanup.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo '=== Cleaning up workspaces ==='\necho ''\necho 'In a real environment, you would destroy each workspace:'\necho ''\necho '  terraform workspace select dev'\necho '  terraform destroy -var-file=environments/dev.tfvars -auto-approve'\necho '  terraform workspace select staging'\necho '  terraform destroy -var-file=environments/staging.tfvars -auto-approve'\necho '  terraform workspace select prod'\necho '  terraform destroy -var-file=environments/prod.tfvars -auto-approve'\necho ''\necho 'Then delete the empty workspaces:'\necho ''\necho '  terraform workspace select default'\necho '  terraform workspace delete dev'\necho '  Deleted workspace \"dev\"!'\necho '  terraform workspace delete staging'\necho '  Deleted workspace \"staging\"!'\necho '  terraform workspace delete prod'\necho '  Deleted workspace \"prod\"!'\necho ''\necho 'Note: You cannot delete a workspace that still has resources.'\necho 'You must destroy all resources first, then delete the workspace.'\necho ''\necho 'Scenario complete! You learned:'\necho '  - How to create and manage Terraform workspaces'\necho '  - Using terraform.workspace for environment-aware naming'\necho '  - Lookup maps for conditional sizing per environment'\necho '  - Workspace-specific tfvars files'\necho '  - Conditional resource creation with workspace checks'\necho '  - Trade-offs between workspace and directory-based approaches'",
      "description": "Clean up all workspaces and resources created during this scenario",
      "explanation": "Cleaning up workspaces requires destroying resources in each workspace before deleting the workspace itself. You must switch to each workspace, run destroy with the matching tfvars file, then switch to default and delete the empty workspaces. Terraform prevents deleting workspaces that still have managed resources, which is a safety feature that prevents orphaned infrastructure.",
      "what_it_does": "Simulates destroying resources in all three workspaces and deleting the empty workspaces, with a summary of all concepts learned in this scenario.",
      "next_step": "Try the next scenario to learn about Auto Scaling Groups with ALB.",
      "cleanup": true
    }
  ]
}
