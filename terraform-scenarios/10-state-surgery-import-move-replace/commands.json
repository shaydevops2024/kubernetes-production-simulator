{
  "scenario_id": "10-state-surgery-import-move-replace",
  "difficulty": "medium",
  "duration": "25 min",
  "commands": [
    {
      "name": "Step 1: When State Surgery Is Needed",
      "command": "echo '=== When Do You Need Terraform State Surgery? ==='\necho ''\necho 'State surgery is required when the Terraform state file gets out of'\necho 'sync with reality, or when you need to reorganize your code.'\necho ''\necho '=== Common Scenarios ==='\necho ''\necho '1. CLICKOPS RESOURCES (most common)'\necho '   Someone created resources manually in the AWS console.'\necho '   You need to bring them under Terraform management.'\necho '   Solution: terraform import or import blocks'\necho ''\necho '2. MODULE REFACTORING'\necho '   You want to move a resource into a module, or rename a module.'\necho '   Without state surgery, Terraform would destroy and recreate it.'\necho '   Solution: terraform state mv or moved blocks'\necho ''\necho '3. FORCED RECREATION'\necho '   A resource needs to be replaced when a dependency changes,'\necho '   but Terraform does not detect the change automatically.'\necho '   Solution: replace_triggered_by lifecycle rule'\necho ''\necho '4. REMOVING FROM MANAGEMENT'\necho '   You want Terraform to stop managing a resource without destroying it.'\necho '   Solution: terraform state rm or removed blocks (TF 1.7+)'\necho ''\necho '=== State Surgery Commands Overview ==='\necho '  terraform import <addr> <id>     Import existing resource'\necho '  terraform state mv <src> <dst>   Move/rename in state'\necho '  terraform state rm <addr>        Remove from state'\necho '  terraform state list             List all resources'\necho '  terraform state show <addr>      Show resource details'",
      "description": "Understand the scenarios that require Terraform state manipulation",
      "explanation": "Terraform state is the mapping between your configuration files and real infrastructure. When this mapping breaks -- because someone created resources manually, or you want to reorganize your code -- you need state surgery. Without it, Terraform might try to destroy and recreate resources that already exist, causing downtime. Understanding when and how to use these tools is essential for managing Terraform in production teams.",
      "what_it_does": "Displays the four main scenarios that require state surgery (ClickOps imports, module refactoring, forced recreation, removing management) along with the corresponding Terraform commands for each.",
      "next_step": "Next we will use terraform import to bring an existing resource under management.",
      "cleanup": false
    },
    {
      "name": "Step 2: Terraform Import for Existing Resources",
      "command": "echo '=== Importing a ClickOps Resource with terraform import ==='\necho ''\necho 'Imagine someone created an S3 bucket manually in the AWS console:'\necho '  Bucket name: legacy-app-data-prod'\necho '  Region: us-east-1'\necho '  Versioning: Enabled'\necho ''\necho 'Step 1: Write the Terraform config FIRST (import needs a target)'\necho ''\ncat << 'TFEOF'\n# main.tf - Configuration for the existing bucket\nresource \"aws_s3_bucket\" \"legacy_data\" {\n  bucket = \"legacy-app-data-prod\"\n\n  tags = {\n    Name        = \"Legacy App Data\"\n    ManagedBy   = \"terraform\"\n    ImportedOn  = \"2024-01-15\"\n  }\n}\n\nresource \"aws_s3_bucket_versioning\" \"legacy_data\" {\n  bucket = aws_s3_bucket.legacy_data.id\n\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\nTFEOF\necho ''\necho 'Step 2: Run terraform import for each resource'\necho ''\necho '  $ terraform import aws_s3_bucket.legacy_data legacy-app-data-prod'\necho '  aws_s3_bucket.legacy_data: Importing from ID \"legacy-app-data-prod\"...'\necho '  aws_s3_bucket.legacy_data: Import prepared!'\necho '  aws_s3_bucket.legacy_data: Refreshing state...'\necho '  Import successful!'\necho ''\necho '  $ terraform import aws_s3_bucket_versioning.legacy_data legacy-app-data-prod'\necho '  aws_s3_bucket_versioning.legacy_data: Import successful!'\necho ''\necho 'Step 3: Run terraform plan to check for drift'\necho '  After import, ALWAYS run plan to see if the config matches reality.'\necho '  Adjust your .tf file until \"No changes\" appears.'\necho ''\necho '=== IMPORTANT ==='\necho '  - You must write the HCL config BEFORE importing'\necho '  - Import only adds to state; it does NOT generate config'\necho '  - Each resource type has its own import ID format (check docs)'\necho '  - Some resources cannot be imported (check provider docs)'",
      "description": "Use terraform import to bring manually-created infrastructure under Terraform management",
      "explanation": "The terraform import command is the classic way to adopt existing infrastructure. You must first write the Terraform configuration that describes the resource, then run the import command which adds the resource to the state file. After importing, you run terraform plan to identify any drift between your config and the real resource. You then adjust the config until the plan shows no changes. This is a manual, resource-by-resource process -- import blocks (next step) improve on this significantly.",
      "what_it_does": "Walks through importing a manually-created S3 bucket: writing the HCL configuration, running terraform import with the resource ID, and verifying with terraform plan.",
      "next_step": "Next we will look at import blocks, a declarative approach introduced in Terraform 1.5.",
      "cleanup": false
    },
    {
      "name": "Step 3: Import Blocks (Terraform 1.5+)",
      "command": "echo '=== Declarative Import Blocks (Terraform 1.5+) ==='\necho ''\necho 'Import blocks let you define imports IN your configuration files.'\necho 'This is the modern, recommended approach.'\necho ''\ncat << 'TFEOF'\n# imports.tf - Declarative import blocks\n\n# Import the manually-created S3 bucket\nimport {\n  to = aws_s3_bucket.legacy_data\n  id = \"legacy-app-data-prod\"\n}\n\n# Import its versioning configuration\nimport {\n  to = aws_s3_bucket_versioning.legacy_data\n  id = \"legacy-app-data-prod\"\n}\n\n# Import a security group created by another team\nimport {\n  to = aws_security_group.legacy_sg\n  id = \"sg-0a1b2c3d4e5f67890\"\n}\n\n# Import with a for_each (importing multiple similar resources)\nimport {\n  to = aws_subnet.private[\"us-east-1a\"]\n  id = \"subnet-0abc123\"\n}\n\nimport {\n  to = aws_subnet.private[\"us-east-1b\"]\n  id = \"subnet-0def456\"\n}\nTFEOF\necho ''\necho '=== How it works ==='\necho ''\necho '  $ terraform plan'\necho '  aws_s3_bucket.legacy_data: Preparing import... [id=legacy-app-data-prod]'\necho '  aws_s3_bucket.legacy_data: Refreshing state... [id=legacy-app-data-prod]'\necho ''\necho '  Plan: 3 to import, 0 to add, 0 to change, 0 to destroy.'\necho ''\necho '  $ terraform apply'\necho '  aws_s3_bucket.legacy_data: Importing... [id=legacy-app-data-prod]'\necho '  aws_s3_bucket.legacy_data: Import complete [id=legacy-app-data-prod]'\necho ''\necho '=== Advantages over terraform import CLI ==='\necho '  1. Imports are version controlled (code review!)'\necho '  2. terraform plan shows imports before they happen'\necho '  3. Works with for_each and complex resource addresses'\necho '  4. Can generate config: terraform plan -generate-config-out=generated.tf'\necho '  5. Remove the import block after successful import (it is one-time)'",
      "description": "Use Terraform 1.5+ import blocks for declarative, reviewable imports",
      "explanation": "Import blocks were introduced in Terraform 1.5 as a major improvement over the CLI import command. Instead of running imperative commands, you declare your imports in .tf files. This means imports go through code review, appear in terraform plan output, and work with for_each. The -generate-config-out flag can even auto-generate the HCL configuration for imported resources. After a successful import and apply, you remove the import block since it is a one-time operation.",
      "what_it_does": "Shows the import block syntax for declaring imports in configuration files, demonstrates how terraform plan/apply handles them, and compares advantages over the CLI import approach.",
      "next_step": "Next we will learn how to move resources between modules with terraform state mv.",
      "cleanup": false
    },
    {
      "name": "Step 4: Terraform State Mv for Module Refactoring",
      "command": "echo '=== Refactoring with terraform state mv ==='\necho ''\necho 'Scenario: You have a flat configuration and want to organize it into modules.'\necho ''\necho 'BEFORE (flat):'\necho '  main.tf'\necho '    resource \"aws_s3_bucket\" \"data\"'\necho '    resource \"aws_s3_bucket\" \"logs\"'\necho '    resource \"aws_iam_role\" \"app_role\"'\necho ''\necho 'AFTER (modular):'\necho '  modules/storage/main.tf'\necho '    resource \"aws_s3_bucket\" \"data\"'\necho '    resource \"aws_s3_bucket\" \"logs\"'\necho '  modules/iam/main.tf'\necho '    resource \"aws_iam_role\" \"app_role\"'\necho ''\necho '=== Without state mv, Terraform would: ==='\necho '  Plan: 3 to add, 0 to change, 3 to destroy.'\necho '  (Destroy old resources, create new ones = DOWNTIME!)'\necho ''\necho '=== With state mv: ==='\necho ''\necho '  $ terraform state mv aws_s3_bucket.data module.storage.aws_s3_bucket.data'\necho '  Move \"aws_s3_bucket.data\" to \"module.storage.aws_s3_bucket.data\"'\necho '  Successfully moved 1 object(s).'\necho ''\necho '  $ terraform state mv aws_s3_bucket.logs module.storage.aws_s3_bucket.logs'\necho '  Successfully moved 1 object(s).'\necho ''\necho '  $ terraform state mv aws_iam_role.app_role module.iam.aws_iam_role.app_role'\necho '  Successfully moved 1 object(s).'\necho ''\necho '  $ terraform plan'\necho '  No changes. Your infrastructure matches the configuration.'\necho ''\necho '=== Other state mv use cases ==='\necho '  # Rename a resource'\necho '  terraform state mv aws_instance.web aws_instance.frontend'\necho ''\necho '  # Move between workspaces (requires -state flags)'\necho '  terraform state mv -state=source.tfstate -state-out=dest.tfstate aws_instance.web aws_instance.web'\necho ''\necho '=== WARNING ==='\necho '  - Always run terraform plan after state mv to verify'\necho '  - Back up your state file first: terraform state pull > backup.tfstate'\necho '  - state mv is imperative and not tracked in code'",
      "description": "Use terraform state mv to move resources into modules without destroying them",
      "explanation": "When you refactor Terraform code by moving resources into modules or renaming them, Terraform sees a resource disappearing at the old address and a new one appearing at the new address. Without state surgery, it would destroy and recreate the resource. terraform state mv updates the state file to reflect the new address, so terraform plan shows no changes. This is critical for zero-downtime refactoring. However, state mv is an imperative command that is not tracked in version control -- moved blocks (next step) solve this.",
      "what_it_does": "Demonstrates a flat-to-modular refactoring scenario, showing how terraform state mv prevents destroy-and-recreate by updating resource addresses in the state file.",
      "next_step": "Next we will learn about moved blocks, the declarative alternative to state mv.",
      "cleanup": false
    },
    {
      "name": "Step 5: Moved Blocks for Safe Renames",
      "command": "echo '=== Moved Blocks (Terraform 1.1+) ==='\necho ''\necho 'Moved blocks are the declarative, version-controlled alternative to state mv.'\necho 'They tell Terraform: \"this resource used to be here, now it is here.\"'\necho ''\ncat << 'TFEOF'\n# main.tf - Moved blocks for refactoring\n\n# Rename a resource (old name -> new name)\nmoved {\n  from = aws_instance.web\n  to   = aws_instance.frontend\n}\n\n# Move a resource into a module\nmoved {\n  from = aws_s3_bucket.data\n  to   = module.storage.aws_s3_bucket.data\n}\n\n# Move a resource from one module to another\nmoved {\n  from = module.old_network.aws_vpc.main\n  to   = module.networking.aws_vpc.main\n}\n\n# Rename a module itself\nmoved {\n  from = module.old_network\n  to   = module.networking\n}\n\n# Move a keyed instance (for_each refactoring)\nmoved {\n  from = aws_subnet.private[0]\n  to   = aws_subnet.private[\"us-east-1a\"]\n}\nTFEOF\necho ''\necho '=== How moved blocks work ==='\necho ''\necho '  $ terraform plan'\necho '  # aws_instance.frontend has moved from aws_instance.web'\necho '  # module.storage.aws_s3_bucket.data has moved from aws_s3_bucket.data'\necho ''\necho '  Plan: 0 to add, 0 to change, 0 to destroy.'\necho '  (Terraform updates state automatically during apply)'\necho ''\necho '=== Advantages over state mv ==='\necho '  1. Declarative -- lives in your .tf files'\necho '  2. Goes through code review (PR process)'\necho '  3. Works for the whole team (not just the person who ran it)'\necho '  4. Can be planned before applying'\necho '  5. Handles count -> for_each migrations'\necho ''\necho '=== When to remove moved blocks ==='\necho '  Keep them for at least one full apply cycle across all environments.'\necho '  After all states are updated, you can safely remove them.'",
      "description": "Use moved blocks for declarative, code-reviewed resource renames and module migrations",
      "explanation": "Moved blocks were introduced in Terraform 1.1 as the declarative replacement for terraform state mv. When you add a moved block, terraform plan recognizes the rename and updates the state automatically during apply -- no manual state manipulation needed. This is especially powerful for teams because the moved block is committed to version control and goes through code review. Every team member's state gets updated when they run apply. Moved blocks also handle complex migrations like converting count-based resources to for_each.",
      "what_it_does": "Shows moved block syntax for resource renames, module migrations, and for_each conversions, and explains the advantages over imperative state mv commands.",
      "next_step": "Next we will learn about replace_triggered_by for forced resource recreation.",
      "cleanup": false
    },
    {
      "name": "Step 6: Replace Triggered By for Forced Recreation",
      "command": "echo '=== replace_triggered_by Lifecycle Rule ==='\necho ''\necho 'Sometimes a resource needs to be replaced when a dependency changes,'\necho 'but Terraform does not detect the dependency automatically.'\necho ''\ncat << 'TFEOF'\n# Example: EC2 instance must be replaced when user_data template changes\n\nresource \"aws_launch_template\" \"app\" {\n  name_prefix   = \"app-\"\n  image_id      = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t3.medium\"\n\n  user_data = base64encode(templatefile(\"userdata.sh.tpl\", {\n    app_version = var.app_version\n    db_host     = aws_db_instance.main.address\n  }))\n}\n\nresource \"aws_instance\" \"app\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t3.medium\"\n\n  lifecycle {\n    # Replace this instance whenever the launch template changes\n    replace_triggered_by = [\n      aws_launch_template.app\n    ]\n  }\n\n  tags = {\n    Name = \"app-server\"\n  }\n}\n\n# Another common pattern: replace when a null_resource trigger fires\nresource \"null_resource\" \"config_hash\" {\n  triggers = {\n    config_hash = sha256(file(\"config.json\"))\n  }\n}\n\nresource \"aws_ecs_service\" \"app\" {\n  name            = \"app-service\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app.arn\n\n  lifecycle {\n    replace_triggered_by = [\n      null_resource.config_hash\n    ]\n  }\n}\nTFEOF\necho ''\necho '=== What happens during plan ==='\necho ''\necho '  # aws_instance.app must be replaced'\necho '  -/+ resource \"aws_instance\" \"app\" {'\necho '        ~ id = \"i-0abc123\" -> (known after apply)  # forces replacement'\necho '      }'\necho ''\necho '  Plan: 1 to add, 0 to change, 1 to destroy.'\necho ''\necho '=== Use cases for replace_triggered_by ==='\necho '  - EC2 instances when user_data or AMI changes externally'\necho '  - ECS services when config files change'\necho '  - Any resource that needs recreation on indirect dependency changes'\necho '  - Combined with null_resource triggers for custom change detection'",
      "description": "Use replace_triggered_by to force resource recreation when dependencies change",
      "explanation": "The replace_triggered_by lifecycle rule (introduced in Terraform 1.2) tells Terraform to replace a resource whenever a referenced resource or attribute changes. This is useful when Terraform cannot automatically detect that a change in one resource should cause recreation of another. A common pattern combines it with null_resource triggers that compute a hash of external files. Without this, you would need to manually taint resources, which is imperative and error-prone.",
      "what_it_does": "Displays examples of replace_triggered_by with launch templates and null_resource triggers, showing how to force resource recreation when indirect dependencies change.",
      "next_step": "Next we will learn how to remove resources from Terraform management without destroying them.",
      "cleanup": false
    },
    {
      "name": "Step 7: Terraform State Rm - Remove from Management",
      "command": "echo '=== terraform state rm - Stop Managing a Resource ==='\necho ''\necho 'Sometimes you need Terraform to \"forget\" about a resource without'\necho 'actually destroying it in the cloud.'\necho ''\necho '=== Common scenarios ==='\necho '  1. Transferring ownership to another Terraform workspace'\necho '  2. A resource that should now be managed manually'\necho '  3. Splitting a monolith state into smaller states'\necho '  4. Removing a resource that was imported by mistake'\necho ''\necho '=== Example: Transfer an RDS instance to another team ==='\necho ''\necho '  # First, check what is in state'\necho '  $ terraform state list'\necho '  aws_db_instance.shared_db'\necho '  aws_s3_bucket.app_data'\necho '  aws_iam_role.app_role'\necho ''\necho '  # Remove the database from THIS state (does NOT destroy it)'\necho '  $ terraform state rm aws_db_instance.shared_db'\necho '  Removed aws_db_instance.shared_db'\necho '  Successfully removed 1 resource instance(s).'\necho ''\necho '  # Verify it is gone from state'\necho '  $ terraform state list'\necho '  aws_s3_bucket.app_data'\necho '  aws_iam_role.app_role'\necho ''\necho '  # IMPORTANT: Also remove from your .tf files!'\necho '  # Otherwise, next plan will try to CREATE a new one.'\necho ''\necho '=== Removed blocks (Terraform 1.7+) ==='\necho ''\ncat << 'TFEOF'\n# The declarative alternative to state rm\nremoved {\n  from = aws_db_instance.shared_db\n\n  lifecycle {\n    destroy = false\n  }\n}\n# This tells Terraform: remove from state but do NOT destroy.\n# Like moved blocks, this goes through code review.\nTFEOF\necho ''\necho '=== WARNING ==='\necho '  - state rm does NOT delete the cloud resource'\necho '  - You MUST also remove the resource from your .tf config'\necho '  - The other team must import it into their state'\necho '  - Always back up state first: terraform state pull > backup.tfstate'",
      "description": "Remove resources from Terraform state without destroying the actual cloud infrastructure",
      "explanation": "terraform state rm removes a resource from the state file but does not touch the actual infrastructure. The resource continues to exist in the cloud -- Terraform simply stops tracking it. This is essential when transferring resource ownership between teams or splitting a monolithic state into smaller, focused states. In Terraform 1.7+, the removed block provides a declarative alternative that goes through code review. After running state rm, you must also remove the resource from your .tf files, or Terraform will try to create a new one.",
      "what_it_does": "Demonstrates removing an RDS instance from Terraform management while keeping it running, shows the removed block syntax (TF 1.7+), and explains the critical follow-up steps.",
      "next_step": "Next we will review a summary of all state operations in a quick-reference format.",
      "cleanup": false
    },
    {
      "name": "Step 8: State Operations Quick Reference",
      "command": "echo '=== Terraform State Operations Quick Reference ==='\necho ''\necho '+--------------------------+------------------+------------------------------+'\necho '| Operation                | CLI Command      | Declarative Block            |'\necho '+--------------------------+------------------+------------------------------+'\necho '| Import existing resource | terraform import | import { } (TF 1.5+)        |'\necho '| Move/rename resource     | state mv         | moved { }  (TF 1.1+)        |'\necho '| Remove from management   | state rm         | removed { } (TF 1.7+)       |'\necho '| Force replacement        | terraform taint  | replace_triggered_by (1.2+)  |'\necho '+--------------------------+------------------+------------------------------+'\necho ''\necho '=== Best Practices ==='\necho ''\necho '1. ALWAYS prefer declarative blocks over CLI commands'\necho '   - They go through code review'\necho '   - They work for the whole team automatically'\necho '   - They are idempotent and documented in code'\necho ''\necho '2. ALWAYS back up state before surgery'\necho '   terraform state pull > backup-$(date +%Y%m%d-%H%M%S).tfstate'\necho ''\necho '3. ALWAYS run terraform plan after any state operation'\necho '   The plan should show \"No changes\" if done correctly'\necho ''\necho '4. Use terraform state list to audit what is being managed'\necho '   terraform state list | wc -l  # count managed resources'\necho ''\necho '5. Enable state locking (DynamoDB for S3 backend)'\necho '   Prevents concurrent state modifications'\necho ''\necho '6. Keep state files small'\necho '   Split large monoliths into focused state files per team/service'\necho ''\necho '=== Dangerous Operations (require extra caution) ==='\necho '  terraform state rm   - Resource becomes unmanaged (orphaned)'\necho '  terraform state mv   - Wrong address = plan shows destroy'\necho '  terraform force-unlock - Only when lock is genuinely stuck'\necho '  terraform state push  - Overwrites remote state (VERY dangerous)'",
      "description": "Review a complete quick-reference table of all Terraform state operations and best practices",
      "explanation": "This summary consolidates all the state surgery techniques covered in this scenario into a single reference. The key takeaway is to prefer declarative blocks (import, moved, removed) over imperative CLI commands whenever possible. Declarative blocks are version-controlled, reviewed by your team, and applied automatically. Always back up state before surgery and verify with terraform plan afterward. In production, state locking and splitting large states into smaller, focused files are critical for team collaboration.",
      "what_it_does": "Displays a reference table mapping each state operation to its CLI command and declarative alternative, along with best practices and warnings about dangerous operations.",
      "next_step": "Cleanup step to complete the scenario.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo '=== Scenario Complete: State Surgery - Import, Move, Replace ==='\necho ''\necho 'In a real environment, state surgery cleanup depends on the operation:'\necho ''\necho '  terraform import   -> No cleanup needed (resource is now managed)'\necho '  terraform state mv  -> Remove old config, keep new config'\necho '  terraform state rm  -> Remove config for the unmanaged resource'\necho '  moved blocks        -> Remove after all envs have applied'\necho '  import blocks       -> Remove after successful import'\necho '  removed blocks      -> Remove after all envs have applied'\necho ''\necho 'What you learned:'\necho '  1. When and why state surgery is needed (ClickOps, refactoring)'\necho '  2. terraform import for adopting existing resources'\necho '  3. Import blocks (TF 1.5+) for declarative, reviewable imports'\necho '  4. terraform state mv for zero-downtime module refactoring'\necho '  5. Moved blocks (TF 1.1+) for team-friendly renames'\necho '  6. replace_triggered_by for forced resource recreation'\necho '  7. terraform state rm and removed blocks to stop managing resources'\necho '  8. Best practices: always prefer declarative, always backup, always plan'\necho ''\necho 'Next scenario: CI/CD Pipeline for Terraform'",
      "description": "Clean up all resources created during this scenario",
      "explanation": "This scenario was entirely educational using echo and cat commands to display Terraform concepts. No actual cloud resources were created. In real-world state surgery, cleanup involves removing one-time blocks (import, moved, removed) from your configuration after they have been applied across all environments and workspaces.",
      "what_it_does": "Summarizes what was learned about Terraform state surgery techniques and provides guidance on cleaning up one-time declarative blocks in real-world usage.",
      "next_step": "Try the next scenario to learn about CI/CD pipelines for Terraform.",
      "cleanup": true
    }
  ]
}
