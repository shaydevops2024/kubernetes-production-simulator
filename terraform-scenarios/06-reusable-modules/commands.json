{
  "scenario_id": "06-reusable-modules",
  "difficulty": "medium",
  "duration": "25 min",
  "commands": [
    {
      "name": "Step 1: Understand the Module Concept",
      "command": "echo '=== Terraform Modules ==='\necho ''\necho 'A module is a container for multiple resources used together.'\necho 'Every Terraform configuration is technically a module (the \"root\" module).'\necho ''\necho 'WHY modules?'\necho '  - DRY (Do not Repeat Yourself): Write once, reuse everywhere'\necho '  - Encapsulation: Hide complexity behind a clean interface'\necho '  - Consistency: Same patterns enforced across teams'\necho '  - Versioning: Pin module versions like any other dependency'\necho ''\necho '=== Module Directory Structure ==='\necho ''\necho 'project/'\necho '  main.tf              <- Root module (calls child modules)'\necho '  variables.tf         <- Root-level variables'\necho '  outputs.tf           <- Root-level outputs'\necho '  terraform.tfvars     <- Variable values'\necho '  modules/'\necho '    web-app/           <- Reusable child module'\necho '      main.tf          <- Resources (ALB, EC2, SG)'\necho '      variables.tf     <- Module inputs'\necho '      outputs.tf       <- Module outputs'\necho ''\necho '=== Module Types ==='\necho '  1. Local modules   -> source = \"./modules/web-app\"'\necho '  2. Registry modules -> source = \"terraform-aws-modules/vpc/aws\"'\necho '  3. Git modules      -> source = \"git::https://github.com/org/repo.git\"'\necho '  4. S3 modules       -> source = \"s3::https://bucket/module.zip\"'",
      "description": "Learn the Terraform module concept, benefits, and directory structure",
      "explanation": "Terraform modules are the primary way to package and reuse infrastructure code. A module is simply a directory containing .tf files. The root module is your top-level configuration. Child modules are called from the root module using 'module' blocks. Modules accept input variables, create resources, and expose outputs. This is analogous to functions in programming -- inputs are parameters, resources are the function body, and outputs are return values.",
      "what_it_does": "Displays an overview of the Terraform module concept, the standard directory layout for a project with modules, and the different module source types available.",
      "next_step": "Next we will create the module directory layout with the required files.",
      "cleanup": false
    },
    {
      "name": "Step 2: Create Module Directory Layout",
      "command": "echo '=== Module: modules/web-app/ ==='\necho ''\necho 'We will create a reusable \"web-app\" module that provisions:'\necho '  - A Security Group (firewall rules)'\necho '  - EC2 instances (application servers)'\necho '  - An Application Load Balancer (traffic distribution)'\necho ''\necho 'The module will accept parameters like:'\necho '  - app_name        (string)  -> Name prefix for all resources'\necho '  - instance_count  (number)  -> How many EC2 instances'\necho '  - instance_type   (string)  -> EC2 size (t3.micro, t3.small, etc.)'\necho '  - vpc_id          (string)  -> Which VPC to deploy into'\necho '  - subnet_ids      (list)    -> Which subnets to use'\necho '  - allowed_cidrs   (list)    -> Which IPs can reach the ALB'\necho ''\necho '=== File layout ==='\necho ''\necho 'modules/web-app/'\necho '  variables.tf   <- Declares what the module accepts'\necho '  main.tf        <- Creates the actual AWS resources'\necho '  outputs.tf     <- Exposes attributes for the caller'\necho ''\necho '=== Key Principle: Interface Design ==='\necho ''\necho 'A well-designed module has:'\necho '  - Clear, typed input variables with descriptions'\necho '  - Sensible defaults where appropriate'\necho '  - Validation rules on inputs'\necho '  - Outputs that expose only what callers need'\necho '  - No hardcoded values (everything parameterized)'",
      "description": "Design the reusable web-app module layout and understand the interface approach",
      "explanation": "Before writing any code, it is important to design your module interface. Think of a module like a black box -- callers should not need to understand the internals. They provide inputs (variables), and the module returns outputs. The web-app module encapsulates the common pattern of security group + compute + load balancer. By parameterizing everything (app name, instance count, VPC, subnets), the same module works for any web application.",
      "what_it_does": "Shows the planned module directory layout, lists the input parameters the module will accept, and explains the key principles of good module interface design.",
      "next_step": "Now let's define the module's input variables in variables.tf.",
      "cleanup": false
    },
    {
      "name": "Step 3: Define Module Input Variables",
      "command": "cat << 'TFEOF'\n# modules/web-app/variables.tf\n# Module input variables with types, descriptions, defaults, and validation\n\nvariable \"app_name\" {\n  description = \"Name prefix for all resources created by this module\"\n  type        = string\n\n  validation {\n    condition     = can(regex(\"^[a-z][a-z0-9-]{2,24}$\", var.app_name))\n    error_message = \"app_name must be 3-25 chars, lowercase alphanumeric and hyphens, start with letter.\"\n  }\n}\n\nvariable \"environment\" {\n  description = \"Environment name (dev, staging, prod)\"\n  type        = string\n  default     = \"dev\"\n\n  validation {\n    condition     = contains([\"dev\", \"staging\", \"prod\"], var.environment)\n    error_message = \"environment must be one of: dev, staging, prod.\"\n  }\n}\n\nvariable \"instance_count\" {\n  description = \"Number of EC2 instances to launch behind the ALB\"\n  type        = number\n  default     = 2\n\n  validation {\n    condition     = var.instance_count >= 1 && var.instance_count <= 10\n    error_message = \"instance_count must be between 1 and 10.\"\n  }\n}\n\nvariable \"instance_type\" {\n  description = \"EC2 instance type for the application servers\"\n  type        = string\n  default     = \"t3.micro\"\n}\n\nvariable \"vpc_id\" {\n  description = \"VPC ID where resources will be created\"\n  type        = string\n}\n\nvariable \"subnet_ids\" {\n  description = \"List of subnet IDs for EC2 instances and ALB\"\n  type        = list(string)\n\n  validation {\n    condition     = length(var.subnet_ids) >= 2\n    error_message = \"At least 2 subnet IDs required for ALB high availability.\"\n  }\n}\n\nvariable \"allowed_cidrs\" {\n  description = \"CIDR blocks allowed to access the ALB\"\n  type        = list(string)\n  default     = [\"0.0.0.0/0\"]\n}\n\nvariable \"tags\" {\n  description = \"Additional tags to apply to all resources\"\n  type        = map(string)\n  default     = {}\n}\nTFEOF",
      "description": "Define typed input variables with validation rules for the web-app module",
      "explanation": "Variables are the module's public API. Each variable has a type constraint (string, number, list, map) that Terraform enforces at plan time. The 'validation' blocks add custom rules -- for example, ensuring app_name follows a naming convention and instance_count stays within bounds. Variables without defaults are required; callers must provide them. Variables with defaults are optional. The 'description' field appears in documentation and terraform plan output, so always write clear descriptions.",
      "what_it_does": "Displays the variables.tf file for the web-app module, defining 8 input variables with types, defaults, descriptions, and validation rules for safe module usage.",
      "next_step": "Next we will write the module's main.tf with the actual resources.",
      "cleanup": false
    },
    {
      "name": "Step 4: Write Module main.tf (ALB + EC2 + Security Group)",
      "command": "cat << 'TFEOF'\n# modules/web-app/main.tf\n# Core resources: Security Group, EC2 Instances, Application Load Balancer\n\nlocals {\n  name_prefix = \"${var.app_name}-${var.environment}\"\n  common_tags = merge(var.tags, {\n    Module      = \"web-app\"\n    Application = var.app_name\n    Environment = var.environment\n  })\n}\n\n# --- Security Group ---\nresource \"aws_security_group\" \"app\" {\n  name_prefix = \"${local.name_prefix}-app-\"\n  description = \"Security group for ${var.app_name} application\"\n  vpc_id      = var.vpc_id\n\n  ingress {\n    description = \"HTTP from ALB\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = var.allowed_cidrs\n  }\n\n  ingress {\n    description = \"HTTPS from ALB\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = var.allowed_cidrs\n  }\n\n  egress {\n    description = \"All outbound traffic\"\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-sg\" })\n}\n\n# --- EC2 Instances ---\nresource \"aws_instance\" \"app\" {\n  count = var.instance_count\n\n  ami                    = data.aws_ami.amazon_linux.id\n  instance_type          = var.instance_type\n  subnet_id              = element(var.subnet_ids, count.index)\n  vpc_security_group_ids = [aws_security_group.app.id]\n\n  user_data = <<-USERDATA\n    #!/bin/bash\n    yum update -y\n    yum install -y httpd\n    echo \"Hello from ${var.app_name} instance ${count.index + 1}\" > /var/www/html/index.html\n    systemctl start httpd\n    systemctl enable httpd\n  USERDATA\n\n  tags = merge(local.common_tags, {\n    Name = \"${local.name_prefix}-${count.index + 1}\"\n  })\n}\n\ndata \"aws_ami\" \"amazon_linux\" {\n  most_recent = true\n  owners      = [\"amazon\"]\n\n  filter {\n    name   = \"name\"\n    values = [\"al2023-ami-*-x86_64\"]\n  }\n}\n\n# --- Application Load Balancer ---\nresource \"aws_lb\" \"app\" {\n  name               = \"${local.name_prefix}-alb\"\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.app.id]\n  subnets            = var.subnet_ids\n\n  tags = merge(local.common_tags, { Name = \"${local.name_prefix}-alb\" })\n}\n\nresource \"aws_lb_target_group\" \"app\" {\n  name     = \"${local.name_prefix}-tg\"\n  port     = 80\n  protocol = \"HTTP\"\n  vpc_id   = var.vpc_id\n\n  health_check {\n    path                = \"/\"\n    healthy_threshold   = 2\n    unhealthy_threshold = 3\n    timeout             = 5\n    interval            = 10\n  }\n\n  tags = local.common_tags\n}\n\nresource \"aws_lb_listener\" \"http\" {\n  load_balancer_arn = aws_lb.app.arn\n  port              = 80\n  protocol          = \"HTTP\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.app.arn\n  }\n}\n\nresource \"aws_lb_target_group_attachment\" \"app\" {\n  count = var.instance_count\n\n  target_group_arn = aws_lb_target_group.app.arn\n  target_id        = aws_instance.app[count.index].id\n  port             = 80\n}\nTFEOF",
      "description": "Write the module's main.tf with Security Group, EC2 instances, and ALB resources",
      "explanation": "The main.tf is the heart of the module. It creates: (1) A security group that controls network access, (2) EC2 instances distributed across subnets using count.index with element(), (3) An ALB with a target group, listener, and attachments. The 'locals' block computes a name_prefix and merges tags to avoid repetition. Notice how every resource references var.* for parameterization -- nothing is hardcoded. The data source 'aws_ami' dynamically finds the latest Amazon Linux AMI. The 'count' meta-argument creates multiple instances from a single resource block.",
      "what_it_does": "Displays the complete main.tf for the web-app module containing a security group with HTTP/HTTPS ingress, EC2 instances with user_data, an ALB with target group and listener, and target group attachments.",
      "next_step": "Next we will define the module outputs to expose key attributes.",
      "cleanup": false
    },
    {
      "name": "Step 5: Define Module Outputs",
      "command": "cat << 'TFEOF'\n# modules/web-app/outputs.tf\n# Expose key attributes so the caller can use them\n\noutput \"alb_dns_name\" {\n  description = \"DNS name of the Application Load Balancer\"\n  value       = aws_lb.app.dns_name\n}\n\noutput \"alb_arn\" {\n  description = \"ARN of the Application Load Balancer\"\n  value       = aws_lb.app.arn\n}\n\noutput \"alb_zone_id\" {\n  description = \"Route53 zone ID of the ALB (for alias records)\"\n  value       = aws_lb.app.zone_id\n}\n\noutput \"security_group_id\" {\n  description = \"ID of the application security group\"\n  value       = aws_security_group.app.id\n}\n\noutput \"instance_ids\" {\n  description = \"List of EC2 instance IDs\"\n  value       = aws_instance.app[*].id\n}\n\noutput \"instance_private_ips\" {\n  description = \"List of private IP addresses of the EC2 instances\"\n  value       = aws_instance.app[*].private_ip\n}\n\noutput \"target_group_arn\" {\n  description = \"ARN of the ALB target group\"\n  value       = aws_lb_target_group.app.arn\n}\nTFEOF\necho ''\necho '=== Why Outputs Matter ==='\necho ''\necho 'Outputs serve three purposes:'\necho '  1. Return values to the caller module'\necho '     -> module.api.alb_dns_name'\necho '  2. Display values after terraform apply'\necho '     -> Outputs = { alb_dns_name = \"api-prod-alb-123456.us-east-1.elb.amazonaws.com\" }'\necho '  3. Share data with other configurations via terraform_remote_state'\necho ''\necho 'The [*] splat expression (e.g., aws_instance.app[*].id)'\necho 'collects an attribute from all instances into a list.'",
      "description": "Define module outputs to expose ALB DNS, instance IDs, and other key attributes",
      "explanation": "Outputs are a module's return values. Without outputs, callers cannot access any attributes of the resources created inside the module -- modules create an encapsulation boundary. The splat expression [*] is a concise way to collect an attribute from all instances of a counted resource into a list. For example, aws_instance.app[*].id produces [\"i-abc123\", \"i-def456\"]. Outputs also appear in the CLI after apply and can be queried with 'terraform output'.",
      "what_it_does": "Displays the outputs.tf file exposing 7 key attributes from the web-app module, including the ALB DNS name, security group ID, and instance IDs, plus an explanation of why outputs are essential.",
      "next_step": "Now let's call this module from the root configuration.",
      "cleanup": false
    },
    {
      "name": "Step 6: Call Module from Root Module",
      "command": "cat << 'TFEOF'\n# main.tf (root module) - Calling the web-app module\n\nterraform {\n  required_version = \">= 1.5.0\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n# Reference the existing VPC and subnets\ndata \"aws_vpc\" \"main\" {\n  tags = { Name = \"main-vpc\" }\n}\n\ndata \"aws_subnets\" \"app\" {\n  filter {\n    name   = \"vpc-id\"\n    values = [data.aws_vpc.main.id]\n  }\n  tags = { Tier = \"application\" }\n}\n\n# ========================================\n# Call the web-app module for the API\n# ========================================\nmodule \"api\" {\n  source = \"./modules/web-app\"\n\n  app_name       = \"api-service\"\n  environment    = \"prod\"\n  instance_count = 3\n  instance_type  = \"t3.small\"\n  vpc_id         = data.aws_vpc.main.id\n  subnet_ids     = data.aws_subnets.app.ids\n  allowed_cidrs  = [\"10.0.0.0/8\"]\n\n  tags = {\n    Team       = \"backend\"\n    CostCenter = \"CC-2001\"\n  }\n}\n\n# ========================================\n# Root-level outputs from the module\n# ========================================\noutput \"api_alb_dns\" {\n  description = \"API service load balancer DNS\"\n  value       = module.api.alb_dns_name\n}\n\noutput \"api_instance_ids\" {\n  description = \"API service EC2 instance IDs\"\n  value       = module.api.instance_ids\n}\nTFEOF\necho ''\necho '=== How module calls work ==='\necho ''\necho '  module \"<local_name>\" {'\necho '    source = \"<path_or_url>\"    <- WHERE the module code lives'\necho '    <variable> = <value>        <- PASS inputs to the module'\necho '  }'\necho ''\necho '  Access outputs: module.<local_name>.<output_name>'\necho '  Example:        module.api.alb_dns_name'",
      "description": "Call the web-app module from the root configuration and wire up outputs",
      "explanation": "The 'module' block is how you call a child module. The 'source' argument tells Terraform where to find the module code. Each argument inside the block maps to a variable defined in the module's variables.tf. The module acts like a black box -- you pass in parameters and read outputs. Notice how data sources fetch the existing VPC and subnets, then pass them to the module. Root-level outputs reference module outputs using the module.<name>.<output> syntax, making them visible in the CLI.",
      "what_it_does": "Displays a root module main.tf that calls the web-app module for an API service with specific configuration values, plus root-level outputs that expose the module's ALB DNS and instance IDs.",
      "next_step": "Next we will instantiate the same module multiple times for different applications.",
      "cleanup": false
    },
    {
      "name": "Step 7: Instantiate Module Multiple Times",
      "command": "cat << 'TFEOF'\n# main.tf (continued) - Multiple module instances\n# The SAME module, called with DIFFERENT parameters\n\n# ========================================\n# Instance 1: API Service (already defined above)\n# ========================================\n# module \"api\" { ... }   (3x t3.small, prod)\n\n# ========================================\n# Instance 2: Frontend Application\n# ========================================\nmodule \"frontend\" {\n  source = \"./modules/web-app\"\n\n  app_name       = \"frontend\"\n  environment    = \"prod\"\n  instance_count = 2\n  instance_type  = \"t3.micro\"\n  vpc_id         = data.aws_vpc.main.id\n  subnet_ids     = data.aws_subnets.app.ids\n  allowed_cidrs  = [\"0.0.0.0/0\"]   # Public-facing\n\n  tags = {\n    Team       = \"frontend\"\n    CostCenter = \"CC-2002\"\n  }\n}\n\n# ========================================\n# Instance 3: Admin Dashboard\n# ========================================\nmodule \"admin\" {\n  source = \"./modules/web-app\"\n\n  app_name       = \"admin-dashboard\"\n  environment    = \"prod\"\n  instance_count = 1\n  instance_type  = \"t3.micro\"\n  vpc_id         = data.aws_vpc.main.id\n  subnet_ids     = data.aws_subnets.app.ids\n  allowed_cidrs  = [\"10.0.0.0/8\"]  # Internal only\n\n  tags = {\n    Team       = \"platform\"\n    CostCenter = \"CC-2003\"\n  }\n}\n\n# ========================================\n# Outputs for all services\n# ========================================\noutput \"all_alb_endpoints\" {\n  value = {\n    api      = module.api.alb_dns_name\n    frontend = module.frontend.alb_dns_name\n    admin    = module.admin.alb_dns_name\n  }\n}\nTFEOF\necho ''\necho '=== DRY Infrastructure ==='\necho ''\necho 'Without modules:  ~40 resources defined 3 times = 120 resource blocks'\necho 'With modules:     ~40 resources defined once + 3 module calls = 43 blocks'\necho ''\necho 'Each module instance gets its own isolated:'\necho '  - Security Group'\necho '  - EC2 Instances'\necho '  - ALB + Target Group'\necho '  - Unique naming via app_name'\necho ''\necho 'Changes to modules/web-app/ automatically propagate to ALL instances.'",
      "description": "Instantiate the same module three times with different parameters for DRY infrastructure",
      "explanation": "This is the real power of modules. By calling the same module block three times with different parameters, we create three completely independent sets of infrastructure -- each with its own security group, EC2 instances, and ALB. The API service gets 3 larger instances with internal-only access, the frontend gets 2 small public-facing instances, and the admin dashboard gets 1 small internal instance. If you later need to add HTTPS support, you change it once in the module and all three services get the update.",
      "what_it_does": "Displays three module instances (api, frontend, admin) using the same web-app module with different parameters, demonstrating how DRY modules reduce 120 resource blocks down to 43.",
      "next_step": "Let's verify the plan to see all resources that would be created.",
      "cleanup": false
    },
    {
      "name": "Step 8: Plan and Verify All Module Instances",
      "command": "echo '=== terraform plan (with modules) ==='\necho ''\necho 'Terraform will perform the following actions:'\necho ''\necho '  # module.api.aws_security_group.app will be created'\necho '  # module.api.aws_instance.app[0] will be created'\necho '  # module.api.aws_instance.app[1] will be created'\necho '  # module.api.aws_instance.app[2] will be created'\necho '  # module.api.aws_lb.app will be created'\necho '  # module.api.aws_lb_target_group.app will be created'\necho '  # module.api.aws_lb_listener.http will be created'\necho '  # module.api.aws_lb_target_group_attachment.app[0] will be created'\necho '  # module.api.aws_lb_target_group_attachment.app[1] will be created'\necho '  # module.api.aws_lb_target_group_attachment.app[2] will be created'\necho ''\necho '  # module.frontend.aws_security_group.app will be created'\necho '  # module.frontend.aws_instance.app[0] will be created'\necho '  # module.frontend.aws_instance.app[1] will be created'\necho '  # module.frontend.aws_lb.app will be created'\necho '  # module.frontend.aws_lb_target_group.app will be created'\necho '  # module.frontend.aws_lb_listener.http will be created'\necho '  # module.frontend.aws_lb_target_group_attachment.app[0] will be created'\necho '  # module.frontend.aws_lb_target_group_attachment.app[1] will be created'\necho ''\necho '  # module.admin.aws_security_group.app will be created'\necho '  # module.admin.aws_instance.app[0] will be created'\necho '  # module.admin.aws_lb.app will be created'\necho '  # module.admin.aws_lb_target_group.app will be created'\necho '  # module.admin.aws_lb_listener.http will be created'\necho '  # module.admin.aws_lb_target_group_attachment.app[0] will be created'\necho ''\necho 'Plan: 24 to add, 0 to change, 0 to destroy.'\necho ''\necho '=== Resource addressing with modules ==='\necho ''\necho '  module.api.aws_instance.app[0]       <- module.instance.resource[index]'\necho '  module.frontend.aws_lb.app           <- module.instance.resource'\necho '  module.admin.aws_security_group.app  <- module.instance.resource'\necho ''\necho '=== State commands for modules ==='\necho '  terraform state list                             # List all resources'\necho '  terraform state show module.api.aws_lb.app       # Show one resource'\necho '  terraform plan -target=module.frontend            # Plan one module only'",
      "description": "Review the terraform plan output showing all resources across the three module instances",
      "explanation": "When you use modules, Terraform prefixes every resource address with the module path. So aws_instance.app[0] inside the api module becomes module.api.aws_instance.app[0] in the state. This namespacing prevents collisions -- each module instance has its own isolated state. The plan shows 24 resources total: 10 for the api (3 instances), 8 for frontend (2 instances), and 6 for admin (1 instance). You can target individual modules with -target=module.<name> for selective applies.",
      "what_it_does": "Simulates terraform plan output showing 24 resources across 3 module instances, demonstrates module-prefixed resource addressing, and shows useful state commands for working with modules.",
      "next_step": "Final step: cleanup.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo '=== terraform destroy ==='\necho ''\necho 'In a real environment, you would run:'\necho '  terraform destroy'\necho ''\necho 'This would destroy all 24 resources across all 3 module instances.'\necho 'Terraform destroys modules in reverse dependency order:'\necho ''\necho '  1. Target group attachments (depend on instances + target groups)'\necho '  2. Listeners (depend on ALB + target groups)'\necho '  3. Target groups, EC2 instances (depend on SG + ALB)'\necho '  4. ALBs (depend on SG + subnets)'\necho '  5. Security groups (base dependency)'\necho ''\necho '  Destroy complete! Resources: 24 destroyed.'\necho ''\necho '=== Module Best Practices ==='\necho ''\necho '  1. Keep modules focused: one module = one logical component'\necho '  2. Use semantic versioning for shared modules (v1.2.3)'\necho '  3. Write a README.md for every module with usage examples'\necho '  4. Add validation blocks to all input variables'\necho '  5. Use output descriptions for self-documenting modules'\necho '  6. Test modules with terratest or tftest before publishing'\necho '  7. Pin module versions: source = \"./modules/web-app?ref=v1.2.0\"'\necho ''\necho 'Scenario complete! You learned:'\necho '  - How to structure a reusable Terraform module'\necho '  - Defining typed input variables with validation'\necho '  - Writing resources that reference module variables'\necho '  - Exposing outputs for callers to consume'\necho '  - Calling the same module multiple times for DRY infrastructure'",
      "description": "Clean up all resources and review module best practices",
      "explanation": "terraform destroy removes all resources managed by the configuration, including all module instances. Modules are destroyed in reverse dependency order just like individual resources. In production, you might destroy one module at a time using -target=module.<name>. Following module best practices -- like semantic versioning, validation, and testing -- ensures your modules remain reliable as your team and infrastructure grow.",
      "what_it_does": "Simulates terraform destroy for all 24 resources, lists module best practices for production use, and summarizes the key concepts learned in this scenario.",
      "next_step": "Try the next scenario to learn about multi-environment workspaces.",
      "cleanup": true
    }
  ]
}
