{
  "scenario_id": "14-zero-downtime-blue-green",
  "difficulty": "hard",
  "duration": "45 min",
  "commands": [
    {
      "name": "Step 1: Understand Blue/Green Infrastructure Pattern",
      "command": "cat << 'TFEOF'\n# =============================================================\n# BLUE/GREEN DEPLOYMENT PATTERN FOR INFRASTRUCTURE\n# =============================================================\n#\n# Traditional blue/green deploys swap application versions.\n# Infrastructure blue/green goes further: entire environments\n# (ASGs, target groups, launch templates) exist in parallel.\n#\n# CONCEPT:\n#\n#   +--------+       +-----------+       +------------------+\n#   | Users  | ----> |    ALB    | ----> | Blue TG (v1)     |\n#   +--------+       | Listener  |       | ASG: 3 instances |\n#                    | Rules     |       +------------------+\n#                    |           |\n#                    |           |       +------------------+\n#                    |           | ----> | Green TG (v2)    |\n#                    +-----------+       | ASG: 3 instances |\n#                                        +------------------+\n#\n# WORKFLOW:\n#   1. Blue environment serves 100% of production traffic\n#   2. Deploy green environment with new version alongside blue\n#   3. Run health checks and smoke tests against green\n#   4. Gradually shift traffic: 90/10 -> 70/30 -> 50/50 -> 0/100\n#   5. Once validated, decommission blue (or keep as rollback)\n#   6. Green becomes the new \"blue\" for the next release\n#\n# KEY BENEFITS:\n#   - Zero downtime during deployment\n#   - Instant rollback by shifting traffic back\n#   - Full environment-level testing before cutover\n#   - No in-place updates that could leave instances inconsistent\n#\n# TERRAFORM CHALLENGES:\n#   - Managing two parallel environments in state\n#   - create_before_destroy lifecycle to avoid downtime gaps\n#   - Coordinating ALB listener rules with traffic weights\n#   - Cleaning up the old environment after successful cutover\nTFEOF",
      "description": "Explore the blue/green deployment pattern applied to infrastructure with ALB and dual target groups.",
      "explanation": "Blue/green deployment for infrastructure means running two complete, parallel environments. The ALB acts as the traffic router, sending requests to one target group (blue) or the other (green) based on listener rule weights. This approach provides zero-downtime deployments because the new environment is fully provisioned and health-checked before receiving any traffic.",
      "what_it_does": "Displays an overview of the blue/green infrastructure pattern, the traffic flow diagram, the deployment workflow steps, key benefits, and Terraform-specific challenges.",
      "next_step": "Next we will create the blue environment with its ASG, launch template, and ALB target group.",
      "cleanup": false
    },
    {
      "name": "Step 2: Create Blue Environment (ASG + Target Group + ALB)",
      "command": "cat << 'TFEOF'\n# =============================================================\n# BLUE ENVIRONMENT - ALB + TARGET GROUP + ASG\n# =============================================================\n# The blue environment is the currently active production stack.\n# It includes an ALB, a target group, and an Auto Scaling Group.\n\n# ---------- variables.tf ----------\n\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n  default     = \"production\"\n}\n\nvariable \"active_color\" {\n  description = \"Which environment is currently active (blue or green)\"\n  type        = string\n  default     = \"blue\"\n}\n\nvariable \"blue_ami_id\" {\n  description = \"AMI ID for the blue environment\"\n  type        = string\n  default     = \"ami-0abcdef1234567890\"\n}\n\nvariable \"green_ami_id\" {\n  description = \"AMI ID for the green environment\"\n  type        = string\n  default     = \"ami-0abcdef1234567891\"\n}\n\nvariable \"blue_traffic_weight\" {\n  description = \"Percentage of traffic routed to blue (0-100)\"\n  type        = number\n  default     = 100\n}\n\n# ---------- alb.tf ----------\n\nresource \"aws_lb\" \"app\" {\n  name               = \"${var.environment}-app-alb\"\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.alb.id]\n  subnets            = aws_subnet.public[*].id\n\n  tags = {\n    Name        = \"${var.environment}-app-alb\"\n    Environment = var.environment\n  }\n}\n\nresource \"aws_lb_target_group\" \"blue\" {\n  name     = \"${var.environment}-blue-tg\"\n  port     = 80\n  protocol = \"HTTP\"\n  vpc_id   = aws_vpc.main.id\n\n  health_check {\n    path                = \"/health\"\n    port                = \"traffic-port\"\n    healthy_threshold   = 2\n    unhealthy_threshold = 3\n    timeout             = 5\n    interval            = 10\n    matcher             = \"200\"\n  }\n\n  tags = {\n    Name  = \"${var.environment}-blue-tg\"\n    Color = \"blue\"\n  }\n}\n\n# ---------- blue-asg.tf ----------\n\nresource \"aws_launch_template\" \"blue\" {\n  name_prefix   = \"${var.environment}-blue-\"\n  image_id      = var.blue_ami_id\n  instance_type = \"t3.medium\"\n\n  network_interfaces {\n    associate_public_ip_address = false\n    security_groups             = [aws_security_group.app.id]\n  }\n\n  user_data = base64encode(<<-USERDATA\n    #!/bin/bash\n    echo \"DEPLOY_COLOR=blue\" >> /etc/environment\n    echo \"APP_VERSION=${var.blue_ami_id}\" >> /etc/environment\n    systemctl start application\n  USERDATA\n  )\n\n  tag_specifications {\n    resource_type = \"instance\"\n    tags = {\n      Name  = \"${var.environment}-blue-instance\"\n      Color = \"blue\"\n    }\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_autoscaling_group\" \"blue\" {\n  name                = \"${var.environment}-blue-asg\"\n  desired_capacity    = 3\n  min_size            = 2\n  max_size            = 6\n  vpc_zone_identifier = aws_subnet.private[*].id\n  target_group_arns   = [aws_lb_target_group.blue.arn]\n  health_check_type   = \"ELB\"\n\n  launch_template {\n    id      = aws_launch_template.blue.id\n    version = \"$Latest\"\n  }\n\n  instance_refresh {\n    strategy = \"Rolling\"\n    preferences {\n      min_healthy_percentage = 90\n    }\n  }\n\n  tag {\n    key                 = \"Color\"\n    value               = \"blue\"\n    propagate_at_launch = true\n  }\n}\n\n# NOTE: The blue environment starts with 100% traffic.\n# The ALB listener rule weights will be adjusted in Step 5\n# to shift traffic to the green environment.\nTFEOF",
      "description": "Build the blue (current production) environment with ALB, target group, launch template, and Auto Scaling Group.",
      "explanation": "The blue environment represents the currently running production stack. The ALB sits in front of a target group that routes to an Auto Scaling Group with 3 instances. The launch template uses create_before_destroy so that when the AMI changes, Terraform creates the new launch template before destroying the old one, preventing a gap. Instance refresh with a 90% minimum healthy percentage ensures rolling updates within the ASG do not cause downtime.",
      "what_it_does": "Displays Terraform configuration for the complete blue environment: variables for traffic control, an Application Load Balancer, a target group with health checks, a launch template with lifecycle rules, and an Auto Scaling Group registered to the target group.",
      "next_step": "Next we will create the green environment with its own ASG and target group.",
      "cleanup": false
    },
    {
      "name": "Step 3: Create Green Environment (ASG + Target Group)",
      "command": "cat << 'TFEOF'\n# =============================================================\n# GREEN ENVIRONMENT - TARGET GROUP + ASG\n# =============================================================\n# The green environment is the NEW version being deployed.\n# It shares the same ALB but has its own target group and ASG.\n# Initially it receives 0% traffic until validated.\n\n# ---------- green-asg.tf ----------\n\nresource \"aws_lb_target_group\" \"green\" {\n  name     = \"${var.environment}-green-tg\"\n  port     = 80\n  protocol = \"HTTP\"\n  vpc_id   = aws_vpc.main.id\n\n  health_check {\n    path                = \"/health\"\n    port                = \"traffic-port\"\n    healthy_threshold   = 2\n    unhealthy_threshold = 3\n    timeout             = 5\n    interval            = 10\n    matcher             = \"200\"\n  }\n\n  tags = {\n    Name  = \"${var.environment}-green-tg\"\n    Color = \"green\"\n  }\n}\n\nresource \"aws_launch_template\" \"green\" {\n  name_prefix   = \"${var.environment}-green-\"\n  image_id      = var.green_ami_id\n  instance_type = \"t3.medium\"\n\n  network_interfaces {\n    associate_public_ip_address = false\n    security_groups             = [aws_security_group.app.id]\n  }\n\n  user_data = base64encode(<<-USERDATA\n    #!/bin/bash\n    echo \"DEPLOY_COLOR=green\" >> /etc/environment\n    echo \"APP_VERSION=${var.green_ami_id}\" >> /etc/environment\n    systemctl start application\n  USERDATA\n  )\n\n  tag_specifications {\n    resource_type = \"instance\"\n    tags = {\n      Name  = \"${var.environment}-green-instance\"\n      Color = \"green\"\n    }\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_autoscaling_group\" \"green\" {\n  name                = \"${var.environment}-green-asg\"\n  desired_capacity    = 3\n  min_size            = 2\n  max_size            = 6\n  vpc_zone_identifier = aws_subnet.private[*].id\n  target_group_arns   = [aws_lb_target_group.green.arn]\n  health_check_type   = \"ELB\"\n\n  launch_template {\n    id      = aws_launch_template.green.id\n    version = \"$Latest\"\n  }\n\n  instance_refresh {\n    strategy = \"Rolling\"\n    preferences {\n      min_healthy_percentage = 90\n    }\n  }\n\n  tag {\n    key                 = \"Color\"\n    value               = \"green\"\n    propagate_at_launch = true\n  }\n}\n\n# GREEN VALIDATION CHECKLIST:\n# Before shifting any traffic to green, verify:\n#\n# 1. All instances are InService in the target group:\n#    aws elbv2 describe-target-health \\\n#      --target-group-arn <green-tg-arn>\n#\n# 2. Application health endpoint returns 200:\n#    curl http://<green-instance-ip>/health\n#\n# 3. Smoke tests pass against the green endpoint directly:\n#    aws elbv2 describe-target-groups \\\n#      --names production-green-tg\n#\n# 4. No error spikes in CloudWatch metrics\n#\n# Only after validation should you proceed to traffic shifting.\nTFEOF",
      "description": "Build the green (new version) environment with its own target group, launch template, and Auto Scaling Group.",
      "explanation": "The green environment mirrors the blue environment structurally but runs the new application version (different AMI). It connects to the same ALB through its own target group. Initially, no traffic is routed to green -- it exists only for validation. The green ASG scales independently, allowing you to verify the new version handles load before cutover. Both launch templates use create_before_destroy to ensure seamless resource replacement.",
      "what_it_does": "Displays Terraform configuration for the green target group with identical health checks, a green launch template with the new AMI, a green Auto Scaling Group registered to the green target group, and a pre-traffic validation checklist.",
      "next_step": "Next we will configure weighted Route53 records for gradual traffic splitting between blue and green.",
      "cleanup": false
    },
    {
      "name": "Step 4: Configure Weighted Route53 Records for Traffic Split",
      "command": "cat << 'TFEOF'\n# =============================================================\n# WEIGHTED ROUTE53 RECORDS FOR TRAFFIC SPLITTING\n# =============================================================\n# Weighted routing lets you split DNS-level traffic between\n# blue and green environments using percentage weights.\n# This provides a DNS-layer traffic control independent of ALB.\n\n# ---------- route53-weighted.tf ----------\n\ndata \"aws_route53_zone\" \"main\" {\n  name         = var.domain_name\n  private_zone = false\n}\n\n# Blue weighted record\nresource \"aws_route53_record\" \"blue\" {\n  zone_id = data.aws_route53_zone.main.zone_id\n  name    = \"app.${var.domain_name}\"\n  type    = \"A\"\n\n  weighted_routing_policy {\n    weight = var.blue_traffic_weight\n  }\n\n  set_identifier = \"blue\"\n\n  alias {\n    name                   = aws_lb.app.dns_name\n    zone_id                = aws_lb.app.zone_id\n    evaluate_target_health = true\n  }\n}\n\n# Green weighted record\nresource \"aws_route53_record\" \"green\" {\n  zone_id = data.aws_route53_zone.main.zone_id\n  name    = \"app.${var.domain_name}\"\n  type    = \"A\"\n\n  weighted_routing_policy {\n    weight = 100 - var.blue_traffic_weight\n  }\n\n  set_identifier = \"green\"\n\n  alias {\n    name                   = aws_lb.app.dns_name\n    zone_id                = aws_lb.app.zone_id\n    evaluate_target_health = true\n  }\n}\n\n# TRAFFIC SHIFT SCHEDULE (adjust blue_traffic_weight):\n#\n#   Phase 1: blue_traffic_weight = 100  (100% blue, 0% green)\n#   Phase 2: blue_traffic_weight = 90   (90% blue, 10% green)   <- canary\n#   Phase 3: blue_traffic_weight = 50   (50% blue, 50% green)   <- split\n#   Phase 4: blue_traffic_weight = 0    (0% blue, 100% green)   <- cutover\n#\n# Apply each phase:\n#   terraform apply -var=\"blue_traffic_weight=90\"\n#   terraform apply -var=\"blue_traffic_weight=50\"\n#   terraform apply -var=\"blue_traffic_weight=0\"\n#\n# MONITORING BETWEEN PHASES:\n#   - Watch error rates in CloudWatch\n#   - Check latency percentiles (p50, p95, p99)\n#   - Monitor target group healthy host counts\n#   - Verify business metrics (conversion rate, etc.)\n#\n# IMPORTANT: DNS-weighted routing is probabilistic, not exact.\n# A weight of 90/10 means ~90% of DNS queries resolve to blue.\n# For precise traffic control, use ALB listener rule weights.\nTFEOF",
      "description": "Set up Route53 weighted DNS records to gradually split traffic between blue and green environments.",
      "explanation": "Weighted Route53 records provide DNS-level traffic control. By adjusting the blue_traffic_weight variable, you control what percentage of DNS resolutions point to each environment. This is useful for canary-style rollouts where you want a small percentage of users to hit the new version first. Note that DNS weighting is probabilistic due to DNS caching, so for precise control you should also use ALB listener rule weights.",
      "what_it_does": "Displays Terraform configuration for Route53 weighted records pointing to blue and green environments, with a phased traffic shift schedule showing how to gradually move traffic from 100/0 to 0/100 using terraform apply with variable overrides.",
      "next_step": "Next we will implement the create_before_destroy lifecycle rule and understand its role in zero-downtime updates.",
      "cleanup": false
    },
    {
      "name": "Step 5: Implement create_before_destroy Lifecycle Rule",
      "command": "cat << 'TFEOF'\n# =============================================================\n# CREATE_BEFORE_DESTROY LIFECYCLE RULE\n# =============================================================\n# By default, Terraform destroys the old resource BEFORE creating\n# the new one. This causes downtime. create_before_destroy\n# reverses the order: create the replacement first, then destroy.\n\n# ---------- lifecycle-examples.tf ----------\n\n# EXAMPLE 1: Launch template with create_before_destroy\n# When the AMI changes, Terraform creates the new launch template\n# first, updates the ASG to reference it, THEN deletes the old one.\n\nresource \"aws_launch_template\" \"example\" {\n  name_prefix   = \"${var.environment}-app-\"\n  image_id      = var.ami_id\n  instance_type = \"t3.medium\"\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\n# EXAMPLE 2: Security group with create_before_destroy\n# Avoids the \"cannot delete SG that is still in use\" error.\n\nresource \"aws_security_group\" \"app\" {\n  name_prefix = \"${var.environment}-app-\"\n  vpc_id      = aws_vpc.main.id\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\n# EXAMPLE 3: Target group with create_before_destroy\n# Ensures the ALB always has a valid target group attached.\n\nresource \"aws_lb_target_group\" \"app\" {\n  name_prefix = \"app-\"\n  port        = 80\n  protocol    = \"HTTP\"\n  vpc_id      = aws_vpc.main.id\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\n# DEFAULT BEHAVIOR (destroy then create):\n#   1. Destroy old launch template  <-- DOWNTIME WINDOW\n#   2. Create new launch template\n#   3. ASG has no valid template during step 1-2\n#\n# WITH create_before_destroy:\n#   1. Create new launch template\n#   2. Update ASG to reference new template\n#   3. Destroy old launch template\n#   4. No downtime at any point\n#\n# CAVEATS:\n#   - Resources with unique name constraints need name_prefix\n#     instead of name (Terraform appends a random suffix)\n#   - Some resources cannot use this (e.g., RDS with same identifier)\n#   - Dependencies may need adjustment (use depends_on carefully)\n#   - State can temporarily show both old and new resources\n#\n# WHEN TO USE:\n#   - Launch templates, security groups, target groups\n#   - Any resource where a brief absence causes errors\n#   - Resources referenced by other live resources\n#\n# WHEN NOT TO USE:\n#   - Resources with unique global names (S3 buckets)\n#   - Stateful resources where duplicates cause conflicts (RDS)\n#   - Resources with external dependencies that cannot handle two\nTFEOF",
      "description": "Understand and implement the create_before_destroy lifecycle rule to prevent downtime during resource replacement.",
      "explanation": "Terraform's default behavior is to destroy a resource before creating its replacement, which causes a gap. The create_before_destroy lifecycle meta-argument reverses this order: the new resource is created first, references are updated, and then the old resource is destroyed. This is critical for launch templates, security groups, and target groups where even a brief absence causes errors in dependent resources like ASGs and ALBs. The trade-off is that resources must use name_prefix instead of name to avoid naming conflicts during the overlap period.",
      "what_it_does": "Displays examples of create_before_destroy applied to launch templates, security groups, and target groups, with a comparison of default vs. lifecycle-modified behavior, caveats about naming constraints, and guidance on when to use or avoid this pattern.",
      "next_step": "Next we will configure ALB listener rules to shift traffic by updating weights.",
      "cleanup": false
    },
    {
      "name": "Step 6: Shift Traffic via ALB Listener Rules and Weights",
      "command": "cat << 'TFEOF'\n# =============================================================\n# ALB LISTENER RULES WITH TRAFFIC WEIGHTS\n# =============================================================\n# ALB forward actions support multiple target groups with weights.\n# This gives precise, connection-level traffic control (not DNS).\n# Combined with Route53 weights, you get two layers of control.\n\n# ---------- alb-listener.tf ----------\n\nresource \"aws_lb_listener\" \"app_https\" {\n  load_balancer_arn = aws_lb.app.arn\n  port              = 443\n  protocol          = \"HTTPS\"\n  ssl_policy        = \"ELBSecurityPolicy-TLS13-1-2-2021-06\"\n  certificate_arn   = var.certificate_arn\n\n  default_action {\n    type = \"forward\"\n\n    forward {\n      target_group {\n        arn    = aws_lb_target_group.blue.arn\n        weight = var.blue_traffic_weight\n      }\n\n      target_group {\n        arn    = aws_lb_target_group.green.arn\n        weight = 100 - var.blue_traffic_weight\n      }\n\n      stickiness {\n        enabled  = true\n        duration = 300   # 5 minutes - keeps user on same color\n      }\n    }\n  }\n}\n\n# TRAFFIC SHIFTING COMMANDS:\n#\n# Phase 1 - Canary (10% to green):\n#   terraform apply -var=\"blue_traffic_weight=90\"\n#\n# Phase 2 - Split (50/50):\n#   terraform apply -var=\"blue_traffic_weight=50\"\n#\n# Phase 3 - Full cutover to green:\n#   terraform apply -var=\"blue_traffic_weight=0\"\n#\n# ALB WEIGHTS vs ROUTE53 WEIGHTS:\n#\n#   ALB Weights (this approach):\n#   + Precise per-connection routing\n#   + Stickiness support (user stays on same color)\n#   + Instant effect (no DNS TTL delay)\n#   + Single ALB handles both target groups\n#   - Only works within a single ALB\n#\n#   Route53 Weights (previous step):\n#   + Works across regions and ALBs\n#   + DNS-level control\n#   - Probabilistic (DNS caching)\n#   - No stickiness guarantee\n#   - Slower to take effect (TTL)\n#\n# BEST PRACTICE: Use ALB weights for same-region blue/green.\n# Use Route53 weights for cross-region or multi-ALB setups.\n# The stickiness setting prevents users from flip-flopping\n# between blue and green during the transition period.\n\n# ---------- cloudwatch-alarms.tf ----------\n\n# Alarm to auto-rollback if green error rate spikes\nresource \"aws_cloudwatch_metric_alarm\" \"green_error_rate\" {\n  alarm_name          = \"${var.environment}-green-high-error-rate\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 2\n  metric_name         = \"HTTPCode_Target_5XX_Count\"\n  namespace           = \"AWS/ApplicationELB\"\n  period              = 60\n  statistic           = \"Sum\"\n  threshold           = 10\n\n  dimensions = {\n    TargetGroup  = aws_lb_target_group.green.arn_suffix\n    LoadBalancer = aws_lb.app.arn_suffix\n  }\n\n  alarm_actions = [aws_sns_topic.deployment_alerts.arn]\n\n  tags = {\n    Name = \"${var.environment}-green-error-alarm\"\n  }\n}\nTFEOF",
      "description": "Configure ALB listener rules with weighted forwarding to shift traffic precisely between blue and green target groups.",
      "explanation": "ALB weighted target groups provide precise, connection-level traffic routing without DNS caching delays. The listener's forward action can include multiple target groups, each with a weight. Stickiness ensures a user who lands on green stays on green for the duration. A CloudWatch alarm monitors the green target group's error rate and can trigger alerts for automated rollback. This approach is preferred over Route53 weights for same-region blue/green because it takes effect immediately.",
      "what_it_does": "Displays Terraform configuration for an ALB HTTPS listener with weighted forwarding to blue and green target groups, stickiness configuration, phased traffic shifting commands, a comparison of ALB vs Route53 weights, and a CloudWatch alarm for green environment error monitoring.",
      "next_step": "Next we will implement the rollback procedure to swap traffic weights back to blue.",
      "cleanup": false
    },
    {
      "name": "Step 7: Implement Rollback Procedure",
      "command": "echo '============================================================='\necho ' BLUE/GREEN ROLLBACK PROCEDURE'\necho '============================================================='\necho ''\necho 'Rollback = shift all traffic back to the blue environment.'\necho 'Because blue is still running, rollback is instant.'\necho ''\necho '--- IMMEDIATE ROLLBACK (ALB weights) ---'\necho ''\necho '  # Shift 100% traffic back to blue:'\necho '  terraform apply -var=\"blue_traffic_weight=100\"'\necho ''\necho '  # This takes effect in seconds (no DNS propagation).'\necho '  # The green ASG keeps running but receives zero traffic.'\necho ''\necho '--- ROLLBACK WITH ROUTE53 ---'\necho ''\necho '  # If using Route53 weighted records as well:'\necho '  terraform apply -var=\"blue_traffic_weight=100\"'\necho ''\necho '  # DNS TTL may delay full effect (60-300 seconds).'\necho '  # During TTL window, some users may still hit green.'\necho ''\necho '--- ROLLBACK DECISION CRITERIA ---'\necho ''\necho '  Trigger rollback if ANY of these occur:'\necho '  1. Error rate > 1% on green target group'\necho '  2. Latency p99 > 2x baseline on green'\necho '  3. Health check failures on green instances'\necho '  4. Business metric degradation (conversion, revenue)'\necho '  5. CloudWatch alarm fires (auto-notification)'\necho ''\necho '--- AUTOMATED ROLLBACK SCRIPT ---'\necho ''\necho '  #!/bin/bash'\necho '  # rollback.sh - Emergency rollback to blue'\necho '  set -euo pipefail'\necho ''\necho '  echo \"[ROLLBACK] Shifting 100% traffic to blue...\"'\necho '  terraform apply -auto-approve -var=\"blue_traffic_weight=100\"'\necho ''\necho '  echo \"[ROLLBACK] Verifying blue health...\"'\necho '  aws elbv2 describe-target-health \\'\necho '    --target-group-arn $(terraform output -raw blue_tg_arn)'\necho ''\necho '  echo \"[ROLLBACK] Scaling down green ASG...\"'\necho '  aws autoscaling update-auto-scaling-group \\'\necho '    --auto-scaling-group-name production-green-asg \\'\necho '    --desired-capacity 0 --min-size 0'\necho ''\necho '  echo \"[ROLLBACK] Complete. Blue serving 100% traffic.\"'\necho ''\necho '--- POST-ROLLBACK ACTIONS ---'\necho ''\necho '  1. Investigate why green failed'\necho '  2. Review CloudWatch logs and metrics'\necho '  3. Fix the issue in the green AMI/application'\necho '  4. Rebuild green and re-attempt deployment'\necho '  5. Do NOT destroy blue until green is validated'\necho ''\necho '============================================================='",
      "description": "Define the rollback procedure to instantly shift traffic back to blue if the green deployment has issues.",
      "explanation": "The key advantage of blue/green is instant rollback. Because the blue environment is still running and healthy, shifting all traffic back is a single terraform apply that updates ALB listener weights. There is no need to redeploy, restore from backup, or wait for instances to boot. The rollback script automates the process: shift traffic to blue, verify blue health, scale down green to save costs, and log the rollback event. Automated rollback can also be triggered by CloudWatch alarms.",
      "what_it_does": "Displays the complete rollback procedure including immediate ALB-based rollback commands, Route53 rollback considerations, decision criteria for when to trigger a rollback, an automated rollback shell script, and post-rollback investigation steps.",
      "next_step": "Next we will verify the complete zero-downtime deployment flow end to end.",
      "cleanup": false
    },
    {
      "name": "Step 8: Verify Zero-Downtime Deployment Flow",
      "command": "echo '============================================================='\necho ' ZERO-DOWNTIME BLUE/GREEN DEPLOYMENT VERIFICATION'\necho '============================================================='\necho ''\necho '--- FULL DEPLOYMENT FLOW ---'\necho ''\necho '  Phase 0: Initial State'\necho '    - Blue ASG: 3 instances, 100% traffic'\necho '    - Green ASG: does not exist yet'\necho '    terraform apply  # Blue environment only'\necho ''\necho '  Phase 1: Deploy Green'\necho '    - Create green ASG with new AMI'\necho '    - Green receives 0% traffic initially'\necho '    terraform apply -var=\"green_ami_id=ami-NEW\"'\necho ''\necho '  Phase 2: Validate Green'\necho '    - Wait for all green instances to pass health checks'\necho '    - Run smoke tests against green instances directly'\necho '    aws elbv2 describe-target-health \\'\necho '      --target-group-arn $(terraform output -raw green_tg_arn)'\necho ''\necho '  Phase 3: Canary (10% green)'\necho '    terraform apply -var=\"blue_traffic_weight=90\"'\necho '    # Monitor for 10-15 minutes'\necho '    # Check error rates, latency, business metrics'\necho ''\necho '  Phase 4: Split (50/50)'\necho '    terraform apply -var=\"blue_traffic_weight=50\"'\necho '    # Monitor for 15-30 minutes'\necho '    # Compare blue vs green metrics side by side'\necho ''\necho '  Phase 5: Full Cutover (100% green)'\necho '    terraform apply -var=\"blue_traffic_weight=0\"'\necho '    # Monitor for 30-60 minutes'\necho '    # Confirm green is stable under full load'\necho ''\necho '  Phase 6: Decommission Blue'\necho '    - After confidence period (1-24 hours)'\necho '    - Scale down blue ASG to 0'\necho '    - Green becomes the new \"blue\" for next deploy'\necho '    aws autoscaling update-auto-scaling-group \\'\necho '      --auto-scaling-group-name production-blue-asg \\'\necho '      --desired-capacity 0 --min-size 0'\necho ''\necho '--- VERIFICATION COMMANDS ---'\necho ''\necho '  # Check both target group health:'\necho '  aws elbv2 describe-target-health --target-group-arn <blue-arn>'\necho '  aws elbv2 describe-target-health --target-group-arn <green-arn>'\necho ''\necho '  # Check current ALB listener rule weights:'\necho '  aws elbv2 describe-rules \\'\necho '    --listener-arn $(terraform output -raw listener_arn)'\necho ''\necho '  # Continuous availability test during cutover:'\necho '  while true; do'\necho '    STATUS=$(curl -s -o /dev/null -w \"%{http_code}\" https://app.example.com/health)'\necho '    echo \"$(date): HTTP $STATUS\"'\necho '    sleep 1'\necho '  done'\necho ''\necho '  # If any request returns non-200, investigate immediately.'\necho ''\necho '============================================================='",
      "description": "Walk through the complete zero-downtime deployment flow from blue-only to full green cutover with verification steps.",
      "explanation": "A complete blue/green deployment follows a phased approach: deploy green with zero traffic, validate health, shift traffic gradually (canary at 10%, split at 50%, full cutover at 100%), and finally decommission the old environment after a confidence period. Continuous health monitoring during each phase is critical. The while loop running curl against the health endpoint provides a simple way to detect any requests that fail during the transition, confirming zero downtime was achieved.",
      "what_it_does": "Displays the complete 6-phase deployment flow from initial blue-only state through green deployment, validation, canary testing, split testing, full cutover, and blue decommission, along with verification commands for target group health, listener rules, and continuous availability testing.",
      "next_step": "Proceed to cleanup to finish the scenario.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo '=== Cleanup: Zero-Downtime Blue/Green Scenario ===' && echo '' && echo 'In a real environment, destroy in this order:' && echo '' && echo '  # 1. Shift all traffic to one environment first' && echo '  terraform apply -var=\"blue_traffic_weight=100\"' && echo '' && echo '  # 2. Scale down green ASG' && echo '  terraform destroy -target=aws_autoscaling_group.green' && echo '  terraform destroy -target=aws_launch_template.green' && echo '  terraform destroy -target=aws_lb_target_group.green' && echo '' && echo '  # 3. Remove Route53 weighted records' && echo '  terraform destroy -target=aws_route53_record.green' && echo '  terraform destroy -target=aws_route53_record.blue' && echo '' && echo '  # 4. Remove CloudWatch alarms' && echo '  terraform destroy -target=aws_cloudwatch_metric_alarm.green_error_rate' && echo '' && echo '  # 5. Destroy remaining infrastructure' && echo '  terraform destroy' && echo '' && echo 'Scenario complete! You have learned:' && echo '  - Blue/green infrastructure deployment pattern' && echo '  - ALB weighted target group traffic shifting' && echo '  - create_before_destroy lifecycle rules' && echo '  - Weighted Route53 DNS routing' && echo '  - Instant rollback procedures' && echo '  - Zero-downtime verification techniques' && echo ''",
      "description": "Clean up all resources created during this scenario.",
      "explanation": "When tearing down a blue/green setup, always shift traffic fully to one environment before destroying the other. This prevents dropped connections. Then remove the inactive environment (ASG, launch template, target group), DNS records, monitoring alarms, and finally the remaining infrastructure. In practice, terraform destroy handles dependency ordering automatically, but targeted destroys give you more control.",
      "what_it_does": "Displays the recommended destroy order for blue/green resources and summarizes what was learned in this scenario.",
      "next_step": "Scenario complete. Consider exploring the drift detection and compliance scenario next.",
      "cleanup": true
    }
  ]
}
