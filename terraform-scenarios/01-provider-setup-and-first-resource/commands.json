{
  "scenario_id": "01-provider-setup-and-first-resource",
  "difficulty": "easy",
  "duration": "15 min",
  "commands": [
    {
      "name": "Step 1: Review the AWS Provider Block",
      "command": "cat << 'TFEOF'\n# provider.tf - AWS Provider Configuration\n# The provider block tells Terraform which cloud platform to interact with\n# and how to authenticate.\n\nterraform {\n  required_version = \">= 1.5.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n\n  # In production, NEVER hardcode credentials.\n  # Use environment variables, IAM roles, or AWS SSO instead.\n  # AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY env vars are auto-detected.\n\n  default_tags {\n    tags = {\n      ManagedBy   = \"terraform\"\n      Environment = \"learning\"\n      Project     = \"k8s-simulator\"\n    }\n  }\n}\nTFEOF",
      "description": "Examine the provider configuration that connects Terraform to AWS",
      "explanation": "The provider block is the foundation of every Terraform project. It specifies which cloud provider plugin to download, which version constraints to enforce, and how to authenticate. The 'required_version' ensures everyone on the team uses a compatible Terraform CLI version. The '~> 5.0' version constraint means any 5.x version is allowed but not 6.0+. Default tags are applied to every resource automatically, which is critical for cost tracking in production.",
      "what_it_does": "Displays the provider.tf file showing how Terraform connects to AWS with version pinning, region selection, and default tags for all resources.",
      "next_step": "Next we will understand what 'terraform init' does behind the scenes.",
      "cleanup": false
    },
    {
      "name": "Step 2: Understand terraform init",
      "command": "echo '=== What happens during terraform init ==='\necho ''\necho '1. Downloads provider plugins to .terraform/providers/'\necho '   └── registry.terraform.io/hashicorp/aws/5.x.x/linux_amd64/'\necho ''\necho '2. Creates .terraform.lock.hcl (dependency lock file)'\necho '   - Pins exact provider versions for reproducible builds'\necho '   - ALWAYS commit this file to version control'\necho ''\necho '3. Initializes the backend (local by default)'\necho '   - Creates terraform.tfstate locally'\necho '   - In production, use remote backends (S3, GCS, etc.)'\necho ''\necho '=== Example output ==='\necho 'Initializing the backend...'\necho 'Initializing provider plugins...'\necho '- Finding hashicorp/aws versions matching \"~> 5.0\"...'\necho '- Installing hashicorp/aws v5.72.1...'\necho '- Installed hashicorp/aws v5.72.1 (signed by HashiCorp)'\necho ''\necho 'Terraform has been successfully initialized!'\necho ''\necho '=== .terraform.lock.hcl (auto-generated) ==='\ncat << 'LOCKEOF'\nprovider \"registry.terraform.io/hashicorp/aws\" {\n  version     = \"5.72.1\"\n  constraints = \"~> 5.0\"\n  hashes = [\n    \"h1:abc123...\",\n    \"zh:def456...\",\n  ]\n}\nLOCKEOF",
      "description": "Learn what terraform init does: downloading providers, creating lock files, and initializing backends",
      "explanation": "terraform init is the first command you run in any Terraform project. It downloads the provider plugins specified in your configuration, creates a dependency lock file (.terraform.lock.hcl) that pins exact versions for reproducible builds, and initializes the state backend. The lock file is similar to package-lock.json in Node.js -- it ensures every team member uses identical provider versions. You must re-run init whenever you add a new provider or change the backend configuration.",
      "what_it_does": "Shows the steps that terraform init performs internally and displays an example lock file that gets generated.",
      "next_step": "Now let's look at the S3 bucket resource we want to create.",
      "cleanup": false
    },
    {
      "name": "Step 3: Review the S3 Bucket Resource Block",
      "command": "cat << 'TFEOF'\n# main.tf - S3 Bucket with Versioning\n# This creates a production-ready S3 bucket with versioning enabled.\n\nresource \"aws_s3_bucket\" \"app_artifacts\" {\n  bucket = \"k8s-simulator-artifacts-prod\"\n\n  tags = {\n    Name        = \"Application Artifacts\"\n    Team        = \"platform-engineering\"\n    CostCenter  = \"CC-1234\"\n    DataClass   = \"internal\"\n  }\n}\n\n# Versioning is configured as a separate resource since AWS API v2\nresource \"aws_s3_bucket_versioning\" \"app_artifacts\" {\n  bucket = aws_s3_bucket.app_artifacts.id\n\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\n# Block all public access - security best practice\nresource \"aws_s3_bucket_public_access_block\" \"app_artifacts\" {\n  bucket = aws_s3_bucket.app_artifacts.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\n# Server-side encryption with AWS managed keys\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"app_artifacts\" {\n  bucket = aws_s3_bucket.app_artifacts.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"aws:kms\"\n    }\n    bucket_key_enabled = true\n  }\n}\nTFEOF",
      "description": "Examine the S3 bucket resource with versioning, public access blocking, and encryption",
      "explanation": "In Terraform, a 'resource' block declares a piece of infrastructure. The syntax is: resource \"<provider>_<type>\" \"<local_name>\". The S3 bucket uses four separate resources because AWS separates bucket configuration into distinct API calls. Notice how aws_s3_bucket_versioning references the bucket using aws_s3_bucket.app_artifacts.id -- this creates an implicit dependency. Terraform automatically determines the correct creation order. Blocking public access and enabling encryption are security best practices that should be on every S3 bucket.",
      "what_it_does": "Displays a production-ready S3 bucket configuration with versioning, public access blocking, and KMS encryption as separate linked resources.",
      "next_step": "Let's see what terraform plan reveals about these resources.",
      "cleanup": false
    },
    {
      "name": "Step 4: Run terraform plan (Simulated)",
      "command": "echo '=== terraform plan output ==='\necho ''\necho 'Terraform will perform the following actions:'\necho ''\necho '  # aws_s3_bucket.app_artifacts will be created'\necho '  + resource \"aws_s3_bucket\" \"app_artifacts\" {'\necho '      + arn                  = (known after apply)'\necho '      + bucket               = \"k8s-simulator-artifacts-prod\"'\necho '      + id                   = (known after apply)'\necho '      + region               = (known after apply)'\necho '      + tags                 = {'\necho '          + \"CostCenter\"  = \"CC-1234\"'\necho '          + \"DataClass\"   = \"internal\"'\necho '          + \"Name\"        = \"Application Artifacts\"'\necho '          + \"Team\"        = \"platform-engineering\"'\necho '        }'\necho '      + tags_all             = {'\necho '          + \"CostCenter\"  = \"CC-1234\"'\necho '          + \"DataClass\"   = \"internal\"'\necho '          + \"Environment\" = \"learning\"'\necho '          + \"ManagedBy\"   = \"terraform\"'\necho '          + \"Name\"        = \"Application Artifacts\"'\necho '          + \"Project\"     = \"k8s-simulator\"'\necho '          + \"Team\"        = \"platform-engineering\"'\necho '        }'\necho '    }'\necho ''\necho '  # aws_s3_bucket_versioning.app_artifacts will be created'\necho '  + resource \"aws_s3_bucket_versioning\" \"app_artifacts\" {'\necho '      + bucket = (known after apply)'\necho '      + versioning_configuration {'\necho '          + status = \"Enabled\"'\necho '        }'\necho '    }'\necho ''\necho '  # aws_s3_bucket_public_access_block.app_artifacts will be created'\necho '  + resource \"aws_s3_bucket_public_access_block\" \"app_artifacts\" {'\necho '      + block_public_acls       = true'\necho '      + block_public_policy     = true'\necho '      + ignore_public_acls      = true'\necho '      + restrict_public_buckets = true'\necho '    }'\necho ''\necho '  # aws_s3_bucket_server_side_encryption_configuration.app_artifacts will be created'\necho '  + resource \"aws_s3_bucket_server_side_encryption_configuration\" \"app_artifacts\" {'\necho '      + rule {'\necho '          + bucket_key_enabled = true'\necho '          + apply_server_side_encryption_by_default {'\necho '              + sse_algorithm = \"aws:kms\"'\necho '            }'\necho '        }'\necho '    }'\necho ''\necho 'Plan: 4 to add, 0 to change, 0 to destroy.'",
      "description": "See what terraform plan outputs before applying any changes",
      "explanation": "terraform plan is a dry-run that shows exactly what Terraform will do without making any changes. The '+' symbol means a resource will be created. Values shown as '(known after apply)' are computed by AWS at creation time (like ARNs and IDs). Notice that tags_all includes both the resource-specific tags AND the default_tags from the provider block. Always review the plan carefully before applying -- in production, plans are often saved to a file and reviewed in CI/CD pipelines before approval.",
      "what_it_does": "Simulates the terraform plan output showing the 4 resources that would be created, including computed values and merged tags.",
      "next_step": "Now let's apply the configuration and see what happens.",
      "cleanup": false
    },
    {
      "name": "Step 5: Apply the Configuration (Simulated)",
      "command": "echo '=== terraform apply ==='\necho ''\necho 'aws_s3_bucket.app_artifacts: Creating...'\necho 'aws_s3_bucket.app_artifacts: Creation complete after 2s [id=k8s-simulator-artifacts-prod]'\necho ''\necho 'aws_s3_bucket_versioning.app_artifacts: Creating...'\necho 'aws_s3_bucket_public_access_block.app_artifacts: Creating...'\necho 'aws_s3_bucket_server_side_encryption_configuration.app_artifacts: Creating...'\necho 'aws_s3_bucket_versioning.app_artifacts: Creation complete after 1s'\necho 'aws_s3_bucket_public_access_block.app_artifacts: Creation complete after 1s'\necho 'aws_s3_bucket_server_side_encryption_configuration.app_artifacts: Creation complete after 1s'\necho ''\necho 'Apply complete! Resources: 4 added, 0 changed, 0 destroyed.'\necho ''\necho '=== KEY CONCEPTS ==='\necho ''\necho '1. Terraform created the bucket FIRST because other resources depend on it'\necho '2. Versioning, public access block, and encryption were created IN PARALLEL'\necho '   (they depend on the bucket but NOT on each other)'\necho '3. The dependency graph is: '\necho ''\necho '   aws_s3_bucket.app_artifacts'\necho '       ├── aws_s3_bucket_versioning.app_artifacts'\necho '       ├── aws_s3_bucket_public_access_block.app_artifacts'\necho '       └── aws_s3_bucket_server_side_encryption_configuration.app_artifacts'\necho ''\necho '4. In production, always use: terraform apply -auto-approve=false (default)'\necho '   This requires manual confirmation before making changes.'",
      "description": "Apply the Terraform configuration and observe the dependency graph in action",
      "explanation": "terraform apply executes the plan and creates real infrastructure. Terraform builds a dependency graph (DAG) and creates resources in the correct order. Independent resources are created in parallel for speed. Notice the bucket was created first, then the three dependent resources were created simultaneously. In CI/CD pipelines, you typically run 'terraform plan -out=tfplan' first, get approval, then 'terraform apply tfplan' to ensure the exact reviewed plan is applied.",
      "what_it_does": "Simulates terraform apply output showing resource creation order, parallel execution of independent resources, and the dependency graph.",
      "next_step": "Let's verify what was created by checking the resource details.",
      "cleanup": false
    },
    {
      "name": "Step 6: Verify the Created Resource",
      "command": "echo '=== terraform show (resource details) ==='\necho ''\necho '# aws_s3_bucket.app_artifacts:'\necho 'resource \"aws_s3_bucket\" \"app_artifacts\" {'\necho '    arn                         = \"arn:aws:s3:::k8s-simulator-artifacts-prod\"'\necho '    bucket                      = \"k8s-simulator-artifacts-prod\"'\necho '    bucket_domain_name          = \"k8s-simulator-artifacts-prod.s3.amazonaws.com\"'\necho '    bucket_regional_domain_name = \"k8s-simulator-artifacts-prod.s3.us-east-1.amazonaws.com\"'\necho '    hosted_zone_id              = \"Z3AQBSTGFYJSTF\"'\necho '    id                          = \"k8s-simulator-artifacts-prod\"'\necho '    region                      = \"us-east-1\"'\necho '    request_payer               = \"BucketOwner\"'\necho '    tags                        = {'\necho '        \"CostCenter\" = \"CC-1234\"'\necho '        \"DataClass\"  = \"internal\"'\necho '        \"Name\"       = \"Application Artifacts\"'\necho '        \"Team\"       = \"platform-engineering\"'\necho '    }'\necho '}'\necho ''\necho '=== Useful verification commands ==='\necho ''\necho '  terraform show                    # Show full current state'\necho '  terraform output                  # Show output values'\necho '  terraform state list              # List all tracked resources'\necho '  terraform state show <resource>   # Show one resource in detail'\necho '  aws s3 ls                         # Verify with AWS CLI'",
      "description": "Verify the created resources using terraform show and understand verification commands",
      "explanation": "After applying, you should always verify that resources were created correctly. 'terraform show' displays the current state of all managed resources with their actual values (not just planned values). The ARN, domain names, and hosted zone ID are all values that AWS assigned at creation time. In production, you would also verify using the cloud provider's CLI or console. The state file is Terraform's source of truth about what infrastructure it manages.",
      "what_it_does": "Displays the terraform show output with all the actual resource attributes assigned by AWS after creation, plus common verification commands.",
      "next_step": "Finally, let's inspect the state file to understand how Terraform tracks infrastructure.",
      "cleanup": false
    },
    {
      "name": "Step 7: Inspect the State File",
      "command": "echo '=== Understanding terraform.tfstate ==='\necho ''\necho 'The state file is a JSON document that maps your config to real resources.'\necho 'It contains SENSITIVE DATA (resource IDs, ARNs, sometimes passwords).'\necho ''\necho '=== terraform state list ==='\necho 'aws_s3_bucket.app_artifacts'\necho 'aws_s3_bucket_public_access_block.app_artifacts'\necho 'aws_s3_bucket_server_side_encryption_configuration.app_artifacts'\necho 'aws_s3_bucket_versioning.app_artifacts'\necho ''\necho '=== State file structure (simplified) ==='\ncat << 'STATEEOF'\n{\n  \"version\": 4,\n  \"terraform_version\": \"1.5.7\",\n  \"serial\": 4,\n  \"lineage\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n  \"resources\": [\n    {\n      \"mode\": \"managed\",\n      \"type\": \"aws_s3_bucket\",\n      \"name\": \"app_artifacts\",\n      \"provider\": \"provider[\\\"registry.terraform.io/hashicorp/aws\\\"]\",\n      \"instances\": [\n        {\n          \"attributes\": {\n            \"id\": \"k8s-simulator-artifacts-prod\",\n            \"arn\": \"arn:aws:s3:::k8s-simulator-artifacts-prod\",\n            \"bucket\": \"k8s-simulator-artifacts-prod\",\n            \"region\": \"us-east-1\"\n          }\n        }\n      ]\n    }\n  ]\n}\nSTATEEOF\necho ''\necho '=== CRITICAL RULES for State Files ==='\necho '1. NEVER edit terraform.tfstate manually'\necho '2. NEVER commit it to git (add to .gitignore)'\necho '3. ALWAYS use remote state in production (S3, GCS, Terraform Cloud)'\necho '4. The \"serial\" increments on every change (optimistic locking)'\necho '5. The \"lineage\" uniquely identifies this state (prevents mixing states)'",
      "description": "Inspect the Terraform state file structure and learn critical state management rules",
      "explanation": "The state file is how Terraform knows what infrastructure it manages. It maps resource addresses (like aws_s3_bucket.app_artifacts) to real-world resource IDs. The 'serial' number increments on every state change, providing a form of optimistic locking. The 'lineage' UUID ensures you never accidentally apply one project's state to another. State files often contain sensitive data like database passwords, so they must never be committed to version control. In the next scenarios, we will learn about remote state backends that solve these problems.",
      "what_it_does": "Shows the state file JSON structure with metadata fields (version, serial, lineage) and resource mapping, plus critical rules for state management.",
      "next_step": "Cleanup step to remove scenario files.",
      "cleanup": false
    },
    {
      "name": "Step 8: Cleanup",
      "command": "echo '=== terraform destroy ==='\necho ''\necho 'In a real environment, you would run:'\necho '  terraform destroy'\necho ''\necho 'This would show:'\necho '  Plan: 0 to add, 0 to change, 4 to destroy.'\necho '  '\necho '  aws_s3_bucket_versioning.app_artifacts: Destroying...'\necho '  aws_s3_bucket_public_access_block.app_artifacts: Destroying...'\necho '  aws_s3_bucket_server_side_encryption_configuration.app_artifacts: Destroying...'\necho '  aws_s3_bucket_versioning.app_artifacts: Destruction complete'\necho '  aws_s3_bucket_public_access_block.app_artifacts: Destruction complete'\necho '  aws_s3_bucket_server_side_encryption_configuration.app_artifacts: Destruction complete'\necho '  aws_s3_bucket.app_artifacts: Destroying...'\necho '  aws_s3_bucket.app_artifacts: Destruction complete'\necho ''\necho '  Destroy complete! Resources: 4 destroyed.'\necho ''\necho 'Notice: Dependent resources are destroyed FIRST (reverse order of creation).'\necho ''\necho 'Scenario complete! You learned:'\necho '  - How to configure an AWS provider with version constraints'\necho '  - The init -> plan -> apply workflow'\necho '  - Creating S3 buckets with security best practices'\necho '  - How Terraform tracks infrastructure in state files'",
      "description": "Clean up all resources created during this scenario",
      "explanation": "terraform destroy removes all resources managed by the current configuration. It builds the dependency graph in reverse -- dependent resources (versioning, encryption, public access block) are destroyed before the bucket itself. In production, you might protect critical resources with lifecycle { prevent_destroy = true } to prevent accidental deletion. Always review the destroy plan before confirming.",
      "what_it_does": "Simulates terraform destroy showing resources being removed in reverse dependency order, and summarizes what was learned in this scenario.",
      "next_step": "Try the next scenario to learn about variables, locals, and outputs.",
      "cleanup": true
    }
  ]
}
