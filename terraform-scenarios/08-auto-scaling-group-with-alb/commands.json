{
  "scenario_id": "08-auto-scaling-group-with-alb",
  "difficulty": "medium",
  "duration": "30 min",
  "commands": [
    {
      "name": "Step 1: Create Launch Template with user_data",
      "command": "cat << 'TFEOF'\n# launch_template.tf - EC2 Launch Template\n# A launch template defines HOW instances are created in the ASG.\n\ndata \"aws_ami\" \"amazon_linux\" {\n  most_recent = true\n  owners      = [\"amazon\"]\n\n  filter {\n    name   = \"name\"\n    values = [\"al2023-ami-*-x86_64\"]\n  }\n}\n\nresource \"aws_launch_template\" \"app\" {\n  name_prefix   = \"web-app-\"\n  image_id      = data.aws_ami.amazon_linux.id\n  instance_type = \"t3.small\"\n\n  # Network configuration\n  vpc_security_group_ids = [aws_security_group.app.id]\n\n  # Bootstrap script runs on EVERY new instance launch\n  user_data = base64encode(<<-USERDATA\n    #!/bin/bash\n    set -euxo pipefail\n\n    # Install and configure web server\n    yum update -y\n    yum install -y httpd amazon-cloudwatch-agent\n\n    # Application deployment\n    INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)\n    cat > /var/www/html/index.html <<HTML\n    <h1>Web App v2.1</h1>\n    <p>Instance: $INSTANCE_ID</p>\n    <p>Launched: $(date)</p>\n    HTML\n\n    # Health check endpoint\n    echo \"OK\" > /var/www/html/health\n\n    # Start services\n    systemctl enable httpd\n    systemctl start httpd\n\n    # CloudWatch agent for metrics\n    /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \\\n      -a start -m ec2 -c default\n  USERDATA\n  )\n\n  # Instance metadata options (IMDSv2 required - security best practice)\n  metadata_options {\n    http_endpoint               = \"enabled\"\n    http_tokens                 = \"required\"\n    http_put_response_hop_limit = 1\n  }\n\n  # EBS volume configuration\n  block_device_mappings {\n    device_name = \"/dev/xvda\"\n    ebs {\n      volume_size           = 20\n      volume_type           = \"gp3\"\n      encrypted             = true\n      delete_on_termination = true\n    }\n  }\n\n  tag_specifications {\n    resource_type = \"instance\"\n    tags = {\n      Name        = \"web-app-asg\"\n      Environment = \"prod\"\n      ManagedBy   = \"terraform-asg\"\n    }\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\nTFEOF\necho ''\necho '=== Launch Template vs Launch Configuration ==='\necho '  Launch Configuration: LEGACY (deprecated by AWS)'\necho '  Launch Template:      CURRENT (supports versioning, mixed instances)'\necho ''\necho '  Always use Launch Templates for new projects.'",
      "description": "Create an EC2 launch template with user_data bootstrap, IMDSv2, and encrypted EBS",
      "explanation": "A launch template is a blueprint that tells the ASG how to create new EC2 instances. The user_data script runs on every new instance, installing the web server and deploying the application. IMDSv2 (http_tokens = required) is a security best practice that prevents SSRF attacks against the instance metadata service. The base64encode() function is required because AWS expects user_data in base64. The lifecycle block with create_before_destroy ensures new template versions are created before old ones are deleted during updates.",
      "what_it_does": "Displays a production-ready launch template with Amazon Linux 2023 AMI, user_data bootstrap script, IMDSv2 security, encrypted gp3 EBS volumes, and tag specifications for ASG instances.",
      "next_step": "Next we will create the Application Load Balancer.",
      "cleanup": false
    },
    {
      "name": "Step 2: Create ALB with Listeners",
      "command": "cat << 'TFEOF'\n# alb.tf - Application Load Balancer\n\nresource \"aws_lb\" \"app\" {\n  name               = \"web-app-alb\"\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.alb.id]\n  subnets            = var.public_subnet_ids\n\n  # Access logs to S3 for debugging and compliance\n  access_logs {\n    bucket  = aws_s3_bucket.alb_logs.id\n    prefix  = \"web-app\"\n    enabled = true\n  }\n\n  # Protect against accidental deletion\n  enable_deletion_protection = true\n\n  # Idle timeout (seconds) - how long to keep idle connections\n  idle_timeout = 60\n\n  tags = {\n    Name        = \"web-app-alb\"\n    Environment = \"prod\"\n  }\n}\n\n# HTTP listener - redirects to HTTPS\nresource \"aws_lb_listener\" \"http\" {\n  load_balancer_arn = aws_lb.app.arn\n  port              = 80\n  protocol          = \"HTTP\"\n\n  default_action {\n    type = \"redirect\"\n    redirect {\n      port        = \"443\"\n      protocol    = \"HTTPS\"\n      status_code = \"HTTP_301\"\n    }\n  }\n}\n\n# HTTPS listener - forwards to target group\nresource \"aws_lb_listener\" \"https\" {\n  load_balancer_arn = aws_lb.app.arn\n  port              = 443\n  protocol          = \"HTTPS\"\n  ssl_policy        = \"ELBSecurityPolicy-TLS13-1-2-2021-06\"\n  certificate_arn   = var.ssl_certificate_arn\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.app.arn\n  }\n}\n\n# ALB Security Group\nresource \"aws_security_group\" \"alb\" {\n  name_prefix = \"web-app-alb-\"\n  vpc_id      = var.vpc_id\n\n  ingress {\n    description = \"HTTP from internet\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    description = \"HTTPS from internet\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\nTFEOF\necho ''\necho '=== ALB Components ==='\necho '  ALB -> Listener (port 80)  -> Redirect to HTTPS'\necho '  ALB -> Listener (port 443) -> Forward to Target Group -> EC2 instances'\necho ''\necho '  The ALB distributes traffic across healthy instances in the target group.'",
      "description": "Create an Application Load Balancer with HTTP-to-HTTPS redirect and access logging",
      "explanation": "The ALB sits in front of your EC2 instances and distributes incoming traffic. It has two listeners: port 80 redirects to HTTPS (HTTP_301 permanent redirect), and port 443 terminates TLS and forwards to the target group. The ssl_policy specifies which TLS versions and ciphers to support -- TLS 1.3 is the current best practice. Access logs to S3 are essential for debugging and compliance auditing. The ALB has its own security group that allows HTTP/HTTPS from the internet, while the application security group only allows traffic from the ALB.",
      "what_it_does": "Displays the ALB configuration with HTTP-to-HTTPS redirect listener, HTTPS listener with TLS 1.3, S3 access logging, deletion protection, and a dedicated security group.",
      "next_step": "Now let's create the target group with health checks.",
      "cleanup": false
    },
    {
      "name": "Step 3: Create Target Group with Health Checks",
      "command": "cat << 'TFEOF'\n# target_group.tf - ALB Target Group with Health Checks\n\nresource \"aws_lb_target_group\" \"app\" {\n  name     = \"web-app-tg\"\n  port     = 80\n  protocol = \"HTTP\"\n  vpc_id   = var.vpc_id\n\n  # Target type: \"instance\" for EC2, \"ip\" for ECS/EKS, \"lambda\" for Lambda\n  target_type = \"instance\"\n\n  # Deregistration delay: seconds to wait before removing instance\n  # Allows in-flight requests to complete\n  deregistration_delay = 30\n\n  # Slow start: gradually increase traffic to new instances\n  # Gives the app time to warm up caches, JIT compile, etc.\n  slow_start = 60\n\n  # Health check configuration - CRITICAL for production\n  health_check {\n    # What to check\n    path     = \"/health\"\n    port     = \"traffic-port\"\n    protocol = \"HTTP\"\n    matcher  = \"200\"\n\n    # How often to check\n    interval = 15\n\n    # How long to wait for a response\n    timeout = 5\n\n    # How many checks before considering healthy/unhealthy\n    healthy_threshold   = 2\n    unhealthy_threshold = 3\n  }\n\n  # Stickiness: route same client to same instance (for sessions)\n  stickiness {\n    type            = \"lb_cookie\"\n    cookie_duration = 3600\n    enabled         = false  # Disable for stateless apps\n  }\n\n  tags = {\n    Name = \"web-app-tg\"\n  }\n}\nTFEOF\necho ''\necho '=== Health Check Timeline ==='\necho ''\necho '  Instance launches'\necho '    |'\necho '    v'\necho '  [Slow start: 60s] -> Traffic gradually increases'\necho '    |'\necho '    v'\necho '  Health check every 15s'\necho '    |'\necho '    +-- 200 OK x2 -> HEALTHY (receives full traffic)'\necho '    |'\necho '    +-- Non-200 x3 -> UNHEALTHY (removed from rotation)'\necho ''\necho '  Instance draining'\necho '    |'\necho '    v'\necho '  [Deregistration: 30s] -> In-flight requests complete'\necho '    |'\necho '    v'\necho '  Instance removed from target group'",
      "description": "Create an ALB target group with health checks, slow start, and deregistration delay",
      "explanation": "The target group defines how the ALB routes traffic to backend instances. Health checks are the most critical configuration -- they determine when instances receive traffic and when they are removed. The /health endpoint should return 200 when the application is ready. Slow start (60s) prevents a newly launched instance from being overwhelmed before caches are warm. Deregistration delay (30s) gives in-flight requests time to complete before an instance is removed. Stickiness is disabled here because stateless applications should not need session affinity.",
      "what_it_does": "Displays a target group with detailed health check configuration, slow start for gradual traffic ramp-up, deregistration delay for graceful shutdown, and a timeline showing the instance lifecycle.",
      "next_step": "Next we will create the Auto Scaling Group with capacity settings.",
      "cleanup": false
    },
    {
      "name": "Step 4: Create ASG with Min/Max/Desired",
      "command": "cat << 'TFEOF'\n# asg.tf - Auto Scaling Group\n\nresource \"aws_autoscaling_group\" \"app\" {\n  name = \"web-app-asg\"\n\n  # Capacity settings\n  min_size         = 2    # Never fewer than 2 (high availability)\n  max_size         = 8    # Cost ceiling\n  desired_capacity = 3    # Starting point\n\n  # Use the launch template we created\n  launch_template {\n    id      = aws_launch_template.app.id\n    version = \"$Latest\"   # Always use latest template version\n  }\n\n  # Distribute across subnets (AZs) for fault tolerance\n  vpc_zone_identifier = var.private_subnet_ids\n\n  # Health check configuration\n  health_check_type         = \"ELB\"    # Use ALB health checks (not just EC2)\n  health_check_grace_period = 120      # Seconds to wait before checking new instances\n\n  # Instance termination policy\n  termination_policies = [\"OldestLaunchTemplate\", \"OldestInstance\"]\n\n  # Wait for instances to pass health checks before marking ASG as ready\n  wait_for_capacity_timeout = \"10m\"\n  min_elb_capacity          = 2\n\n  # Protect instances from scale-in during business hours\n  # protect_from_scale_in = false\n\n  # Warm pool: pre-initialized instances for faster scaling\n  warm_pool {\n    pool_state                  = \"Stopped\"\n    min_size                    = 1\n    max_group_prepared_capacity = 4\n  }\n\n  tag {\n    key                 = \"Name\"\n    value               = \"web-app-asg\"\n    propagate_at_launch = true\n  }\n\n  tag {\n    key                 = \"Environment\"\n    value               = \"prod\"\n    propagate_at_launch = true\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\nTFEOF\necho ''\necho '=== Capacity Explained ==='\necho ''\necho '  min_size = 2          Always at least 2 instances running'\necho '  desired_capacity = 3  ASG will maintain 3 instances'\necho '  max_size = 8          Scaling policies can add up to 8 total'\necho ''\necho '  [min=2] <-- [desired=3] --> [max=8]'\necho '  ^-- scale-in floor    ^-- scale-out ceiling'\necho ''\necho '=== Health Check Types ==='\necho '  EC2:  Only checks if VM is running (default)'\necho '  ELB:  Uses ALB health checks (recommended for web apps)'\necho '        Catches app crashes that EC2 checks would miss'",
      "description": "Create an Auto Scaling Group with min/max/desired capacity, warm pool, and ELB health checks",
      "explanation": "The ASG automatically maintains a fleet of EC2 instances. min_size ensures high availability (never fewer than 2), max_size caps costs, and desired_capacity is the starting point. The health_check_type should be 'ELB' for web applications so the ALB's /health endpoint is used -- this catches application-level failures that EC2 status checks miss. The warm pool keeps pre-initialized stopped instances ready for rapid scaling (seconds vs minutes). The termination policy 'OldestLaunchTemplate' ensures instances with outdated configurations are removed first during scale-in.",
      "what_it_does": "Displays an ASG configuration with 2/3/8 capacity settings, ELB health checks, a warm pool for fast scaling, termination policies, and a visual explanation of capacity boundaries.",
      "next_step": "Now let's connect the ASG to the ALB target group.",
      "cleanup": false
    },
    {
      "name": "Step 5: Connect ASG to Target Group",
      "command": "cat << 'TFEOF'\n# asg_attachment.tf - Connect ASG to ALB Target Group\n\nresource \"aws_autoscaling_attachment\" \"app\" {\n  autoscaling_group_name = aws_autoscaling_group.app.name\n  lb_target_group_arn    = aws_lb_target_group.app.arn\n}\n\n# Application Security Group - only allows traffic FROM the ALB\nresource \"aws_security_group\" \"app\" {\n  name_prefix = \"web-app-ec2-\"\n  vpc_id      = var.vpc_id\n\n  # Only accept traffic from the ALB security group\n  ingress {\n    description     = \"HTTP from ALB only\"\n    from_port       = 80\n    to_port         = 80\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.alb.id]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"web-app-ec2-sg\"\n  }\n}\nTFEOF\necho ''\necho '=== Traffic Flow ==='\necho ''\necho '  Internet'\necho '    |'\necho '    v'\necho '  ALB (public subnets, port 443)'\necho '    |  [ALB SG: allows 0.0.0.0/0 on 80,443]'\necho '    v'\necho '  Target Group (routes to healthy instances)'\necho '    |'\necho '    v'\necho '  EC2 Instances (private subnets, port 80)'\necho '    [App SG: allows ONLY ALB SG on port 80]'\necho ''\necho '=== Auto-Registration ==='\necho ''\necho '  When ASG launches a new instance:'\necho '    1. Instance boots and runs user_data'\necho '    2. ASG registers instance with target group'\necho '    3. ALB starts health checks after grace period'\necho '    4. After 2 healthy checks -> instance receives traffic'\necho ''\necho '  When ASG terminates an instance:'\necho '    1. ALB stops sending new requests'\necho '    2. Deregistration delay (30s) drains connections'\necho '    3. Instance is terminated'",
      "description": "Connect the ASG to the ALB target group and configure security group chaining",
      "explanation": "The aws_autoscaling_attachment resource links the ASG to the target group, enabling automatic registration and deregistration of instances. When a new instance is launched, the ASG automatically registers it with the target group. The security group configuration is critical: EC2 instances only accept traffic from the ALB security group (not from the internet directly). This defense-in-depth approach means even if someone discovers an instance IP, they cannot bypass the ALB.",
      "what_it_does": "Displays the ASG-to-target-group attachment, the application security group that only allows ALB traffic, the complete traffic flow diagram, and the auto-registration lifecycle.",
      "next_step": "Next we will add a CPU-based scaling policy.",
      "cleanup": false
    },
    {
      "name": "Step 6: Add CPU-Based Scaling Policy",
      "command": "cat << 'TFEOF'\n# scaling_policy.tf - Auto Scaling Policies\n\n# Target Tracking Policy: maintain average CPU at 60%\nresource \"aws_autoscaling_policy\" \"cpu_target\" {\n  name                   = \"web-app-cpu-target\"\n  autoscaling_group_name = aws_autoscaling_group.app.name\n  policy_type            = \"TargetTrackingScaling\"\n\n  target_tracking_configuration {\n    predefined_metric_specification {\n      predefined_metric_type = \"ASGAverageCPUUtilization\"\n    }\n    target_value     = 60.0\n    disable_scale_in = false\n  }\n}\n\n# Step Scaling Policy: aggressive scale-out for CPU spikes\nresource \"aws_autoscaling_policy\" \"cpu_spike\" {\n  name                   = \"web-app-cpu-spike\"\n  autoscaling_group_name = aws_autoscaling_group.app.name\n  policy_type            = \"StepScaling\"\n  adjustment_type        = \"ChangeInCapacity\"\n\n  step_adjustment {\n    scaling_adjustment          = 2\n    metric_interval_lower_bound = 0\n    metric_interval_upper_bound = 20\n  }\n\n  step_adjustment {\n    scaling_adjustment          = 4\n    metric_interval_lower_bound = 20\n  }\n}\n\n# CloudWatch alarm to trigger step scaling\nresource \"aws_cloudwatch_metric_alarm\" \"cpu_high\" {\n  alarm_name          = \"web-app-cpu-high\"\n  comparison_operator = \"GreaterThanThreshold\"\n  evaluation_periods  = 2\n  metric_name         = \"CPUUtilization\"\n  namespace           = \"AWS/EC2\"\n  period              = 60\n  statistic           = \"Average\"\n  threshold           = 80\n\n  dimensions = {\n    AutoScalingGroupName = aws_autoscaling_group.app.name\n  }\n\n  alarm_actions = [aws_autoscaling_policy.cpu_spike.arn]\n\n  tags = {\n    Name = \"web-app-cpu-high\"\n  }\n}\n\n# Scheduled scaling for predictable traffic patterns\nresource \"aws_autoscaling_schedule\" \"business_hours\" {\n  scheduled_action_name  = \"scale-up-business-hours\"\n  autoscaling_group_name = aws_autoscaling_group.app.name\n  min_size               = 4\n  max_size               = 8\n  desired_capacity       = 5\n  recurrence             = \"0 8 * * MON-FRI\"\n  time_zone              = \"America/New_York\"\n}\n\nresource \"aws_autoscaling_schedule\" \"off_hours\" {\n  scheduled_action_name  = \"scale-down-off-hours\"\n  autoscaling_group_name = aws_autoscaling_group.app.name\n  min_size               = 2\n  max_size               = 4\n  desired_capacity       = 2\n  recurrence             = \"0 20 * * MON-FRI\"\n  time_zone              = \"America/New_York\"\n}\nTFEOF\necho ''\necho '=== Scaling Strategy Layers ==='\necho '  1. Target Tracking:  Smooth, automatic (CPU at 60%)'\necho '  2. Step Scaling:     Aggressive for spikes (CPU > 80%)'\necho '  3. Scheduled:        Predictable patterns (business hours)'\necho ''\necho '  These work together -- scheduled sets the baseline,'\necho '  target tracking handles gradual changes,'\necho '  step scaling handles sudden spikes.'",
      "description": "Add CPU-based target tracking, step scaling policies, and scheduled scaling",
      "explanation": "Production auto-scaling typically uses multiple policy types together. Target tracking is the simplest -- you set a target (60% CPU) and AWS handles the math. Step scaling adds aggressive responses for sudden spikes -- if CPU exceeds 80% for 2 minutes, add 2 instances; if it exceeds 100%, add 4. Scheduled scaling adjusts capacity for predictable patterns like business hours. CloudWatch alarms bridge metrics to scaling actions. The three layers work together: scheduled sets the baseline, target tracking handles gradual load changes, and step scaling handles traffic spikes.",
      "what_it_does": "Displays three scaling strategies: target tracking (maintain 60% CPU), step scaling (aggressive response to spikes above 80%), and scheduled scaling (business hours vs off-hours), plus a CloudWatch alarm configuration.",
      "next_step": "Next we will configure rolling update strategy for zero-downtime deployments.",
      "cleanup": false
    },
    {
      "name": "Step 7: Configure Rolling Update Strategy",
      "command": "cat << 'TFEOF'\n# instance_refresh.tf - Rolling Update Configuration\n# Automatically replace instances when the launch template changes\n\nresource \"aws_autoscaling_group\" \"app\" {\n  # ... (previous configuration) ...\n\n  # Instance refresh for rolling deployments\n  instance_refresh {\n    strategy = \"Rolling\"\n\n    preferences {\n      # Minimum percentage of healthy instances during update\n      min_healthy_percentage = 75\n\n      # Seconds to wait after an instance passes health checks\n      instance_warmup = 120\n\n      # Maximum percentage of instances to replace at once\n      # 25% means replace 1 of 4 instances at a time\n      max_healthy_percentage = 125\n\n      # Skip instances that match the desired configuration\n      skip_matching = true\n\n      # Auto rollback if health check failures exceed threshold\n      auto_rollback = true\n    }\n\n    triggers = [\"launch_template\"]\n  }\n}\nTFEOF\necho ''\necho '=== Rolling Update Timeline (4 instances) ==='\necho ''\necho '  Start: [v1] [v1] [v1] [v1]   (desired=4, min_healthy=75% -> 3)'\necho ''\necho '  Phase 1: Launch v2-a, wait for healthy'\necho '  [v1] [v1] [v1] [v1] [v2-a]   (5 running, 4 healthy)'\necho '  Terminate v1-oldest'\necho '  [v1] [v1] [v1] [v2-a]         (4 running, 3 healthy + 1 warming)'\necho ''\necho '  Phase 2: Launch v2-b, wait for healthy'\necho '  [v1] [v1] [v1] [v2-a] [v2-b]  (5 running)'\necho '  Terminate v1-next'\necho '  [v1] [v1] [v2-a] [v2-b]       (4 running)'\necho ''\necho '  Phase 3-4: Repeat until all replaced'\necho '  [v2-a] [v2-b] [v2-c] [v2-d]   (all v2, update complete!)'\necho ''\necho '=== Rollback Scenario ==='\necho '  If v2 instances keep failing health checks:'\necho '    auto_rollback = true -> ASG cancels refresh'\necho '    Remaining v1 instances stay running'\necho '    You fix the issue and trigger a new refresh'\necho ''\necho '=== Trigger a refresh manually ==='\necho '  aws autoscaling start-instance-refresh \\'\necho '    --auto-scaling-group-name web-app-asg \\'\necho '    --strategy Rolling'",
      "description": "Configure instance refresh for zero-downtime rolling updates when the launch template changes",
      "explanation": "Instance refresh automates rolling deployments within an ASG. When the launch template changes (new AMI, updated user_data), the ASG gradually replaces old instances with new ones. min_healthy_percentage=75 ensures at least 75% of instances are always healthy during the update. instance_warmup=120 gives new instances time to start and pass health checks before the next batch is replaced. auto_rollback stops the update if new instances are unhealthy, preserving the remaining old instances. This provides zero-downtime deployments without needing a separate blue/green setup.",
      "what_it_does": "Displays the instance refresh configuration for rolling updates, a visual timeline showing how 4 instances are replaced one by one, the rollback behavior, and how to trigger a manual refresh.",
      "next_step": "Let's verify the complete setup with a terraform plan.",
      "cleanup": false
    },
    {
      "name": "Step 8: Verify Complete Setup",
      "command": "echo '=== terraform plan - Complete ASG + ALB Setup ==='\necho ''\necho 'Terraform will perform the following actions:'\necho ''\necho '  # aws_launch_template.app will be created'\necho '  # aws_security_group.alb will be created'\necho '  # aws_security_group.app will be created'\necho '  # aws_lb.app will be created'\necho '  # aws_lb_listener.http will be created'\necho '  # aws_lb_listener.https will be created'\necho '  # aws_lb_target_group.app will be created'\necho '  # aws_autoscaling_group.app will be created'\necho '  # aws_autoscaling_attachment.app will be created'\necho '  # aws_autoscaling_policy.cpu_target will be created'\necho '  # aws_autoscaling_policy.cpu_spike will be created'\necho '  # aws_cloudwatch_metric_alarm.cpu_high will be created'\necho '  # aws_autoscaling_schedule.business_hours will be created'\necho '  # aws_autoscaling_schedule.off_hours will be created'\necho ''\necho 'Plan: 14 to add, 0 to change, 0 to destroy.'\necho ''\necho '=== Architecture Diagram ==='\necho ''\necho '  Internet'\necho '    |'\necho '    v'\necho '  [ALB] (public subnets, AZ-a + AZ-b)'\necho '    |  HTTP -> redirect to HTTPS'\necho '    |  HTTPS -> forward to target group'\necho '    v'\necho '  [Target Group] /health checks every 15s'\necho '    |'\necho '    v'\necho '  [ASG] min=2, desired=3, max=8'\necho '    |'\necho '    +-- [EC2-1] AZ-a (private subnet)'\necho '    +-- [EC2-2] AZ-b (private subnet)'\necho '    +-- [EC2-3] AZ-a (private subnet)'\necho '    |'\necho '    +-- [Warm Pool: 1 stopped instance]'\necho '    |'\necho '    +-- Scaling Policies:'\necho '         - Target Tracking: CPU -> 60%'\necho '         - Step Scaling: CPU > 80% -> add 2-4'\necho '         - Scheduled: Business hours 8am-8pm EST'\necho ''\necho '=== Key Terraform Resources ==='\necho '  14 resources working together as a production auto-scaling stack'",
      "description": "Review the complete terraform plan and architecture diagram for the ASG + ALB setup",
      "explanation": "The complete setup involves 14 Terraform resources that form a production-ready auto-scaling architecture. The architecture follows AWS best practices: ALB in public subnets, EC2 in private subnets, security group chaining (EC2 only accepts ALB traffic), ELB health checks, warm pool for fast scaling, multiple scaling strategies, and rolling updates for zero-downtime deployments. This is the standard pattern used by most AWS production workloads.",
      "what_it_does": "Simulates the terraform plan showing all 14 resources and displays a complete architecture diagram showing the traffic flow from internet through ALB, target group, ASG, to EC2 instances with all scaling policies.",
      "next_step": "Final step: cleanup.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo '=== terraform destroy ==='\necho ''\necho 'In a real environment, you would run:'\necho '  terraform destroy'\necho ''\necho 'IMPORTANT: Before destroying, disable deletion protection:'\necho '  1. Set enable_deletion_protection = false on the ALB'\necho '  2. Run terraform apply to update the ALB'\necho '  3. Then run terraform destroy'\necho ''\necho 'Destruction order (Terraform handles dependencies):'\necho '  1. Scheduled scaling actions'\necho '  2. Scaling policies and CloudWatch alarms'\necho '  3. ASG attachment (deregisters from target group)'\necho '  4. Auto Scaling Group (terminates all EC2 instances)'\necho '  5. Launch template'\necho '  6. ALB listeners'\necho '  7. Target group'\necho '  8. Application Load Balancer'\necho '  9. Security groups (ALB and EC2)'\necho ''\necho '  Destroy complete! Resources: 14 destroyed.'\necho ''\necho 'Scenario complete! You learned:'\necho '  - Launch templates with user_data, IMDSv2, and encrypted EBS'\necho '  - ALB with HTTP-to-HTTPS redirect and access logging'\necho '  - Target groups with health checks and slow start'\necho '  - ASG with min/max/desired capacity and warm pools'\necho '  - Security group chaining (EC2 only accepts ALB traffic)'\necho '  - Target tracking, step scaling, and scheduled scaling'\necho '  - Rolling updates with instance refresh and auto-rollback'",
      "description": "Clean up all resources and review what was learned about ASG and ALB architecture",
      "explanation": "Destroying an ASG+ALB stack requires disabling deletion protection on the ALB first, otherwise terraform destroy will fail. Terraform handles the dependency ordering automatically -- scaling policies and attachments are removed before the ASG, the ASG terminates all instances before deletion, and security groups are removed last since other resources depend on them. This scenario covered the complete production auto-scaling pattern used across most AWS deployments.",
      "what_it_does": "Simulates terraform destroy for all 14 resources with the correct destruction order, notes the deletion protection requirement, and summarizes the seven key concepts learned.",
      "next_step": "Try the next scenario to learn about RDS Multi-AZ with backups.",
      "cleanup": true
    }
  ]
}
