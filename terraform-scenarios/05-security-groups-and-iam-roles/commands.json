{
  "scenario_id": "05-security-groups-and-iam-roles",
  "difficulty": "easy",
  "duration": "15 min",
  "commands": [
    {
      "name": "Step 1: Create a Security Group",
      "command": "cat << 'TFEOF'\n# security_group.tf - Base Security Group\n\nresource \"aws_security_group\" \"web_server_sg\" {\n  name        = \"web-server-sg\"\n  description = \"Security group for web server instances\"\n  vpc_id      = aws_vpc.main.id\n\n  tags = {\n    Name        = \"web-server-sg\"\n    Environment = \"production\"\n    ManagedBy   = \"terraform\"\n  }\n}\n\n# Security Groups act as virtual firewalls for your EC2 instances.\n# By default, a new security group DENIES all inbound traffic\n# and ALLOWS all outbound traffic.\n# You must explicitly add rules to allow traffic in or restrict traffic out.\nTFEOF",
      "description": "Define a base AWS Security Group resource attached to a VPC",
      "explanation": "A Security Group is a stateful firewall that controls inbound and outbound traffic at the instance level. Unlike NACLs which are stateless, security groups automatically allow return traffic for any allowed inbound connection. We start by creating the group itself, then add rules.",
      "what_it_does": "Displays the Terraform configuration for creating an AWS Security Group. The group is associated with a VPC and tagged for identification. No traffic rules are defined yet - that comes in the next steps.",
      "next_step": "Next, we will add ingress (inbound) rules to allow HTTP, HTTPS, and SSH traffic.",
      "cleanup": false
    },
    {
      "name": "Step 2: Add Ingress Rules",
      "command": "cat << 'TFEOF'\n# security_group_rules.tf - Ingress (Inbound) Rules\n\n# Allow HTTP from anywhere (for public web traffic)\nresource \"aws_security_group_rule\" \"allow_http\" {\n  type              = \"ingress\"\n  from_port         = 80\n  to_port           = 80\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n  security_group_id = aws_security_group.web_server_sg.id\n  description       = \"Allow HTTP inbound from anywhere\"\n}\n\n# Allow HTTPS from anywhere\nresource \"aws_security_group_rule\" \"allow_https\" {\n  type              = \"ingress\"\n  from_port         = 443\n  to_port           = 443\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n  security_group_id = aws_security_group.web_server_sg.id\n  description       = \"Allow HTTPS inbound from anywhere\"\n}\n\n# Allow SSH only from a specific IP range (your office/VPN)\nresource \"aws_security_group_rule\" \"allow_ssh\" {\n  type              = \"ingress\"\n  from_port         = 22\n  to_port           = 22\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"10.0.0.0/8\"]  # Restrict to internal network!\n  security_group_id = aws_security_group.web_server_sg.id\n  description       = \"Allow SSH from internal network only\"\n}\n\n# IMPORTANT: Never use 0.0.0.0/0 for SSH in production!\n# Always restrict SSH access to known IP ranges (VPN, bastion, office).\nTFEOF",
      "description": "Add inbound traffic rules for HTTP, HTTPS, and restricted SSH access",
      "explanation": "Ingress rules control what traffic can reach your instances. We allow HTTP (80) and HTTPS (443) from anywhere since this is a public web server, but restrict SSH (22) to an internal CIDR block. This is a critical security best practice - never expose SSH to the entire internet (0.0.0.0/0) in production.",
      "what_it_does": "Displays three security group ingress rules. HTTP and HTTPS are open to the public internet for web traffic. SSH is restricted to the 10.0.0.0/8 internal network range, following the principle of least privilege for administrative access.",
      "next_step": "Next, we will configure egress (outbound) rules to control what traffic can leave the instances.",
      "cleanup": false
    },
    {
      "name": "Step 3: Add Egress Rules",
      "command": "cat << 'TFEOF'\n# security_group_egress.tf - Egress (Outbound) Rules\n\n# Allow HTTPS outbound (for API calls, package updates)\nresource \"aws_security_group_rule\" \"allow_https_out\" {\n  type              = \"egress\"\n  from_port         = 443\n  to_port           = 443\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n  security_group_id = aws_security_group.web_server_sg.id\n  description       = \"Allow HTTPS outbound for API calls\"\n}\n\n# Allow DNS outbound\nresource \"aws_security_group_rule\" \"allow_dns_udp_out\" {\n  type              = \"egress\"\n  from_port         = 53\n  to_port           = 53\n  protocol          = \"udp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n  security_group_id = aws_security_group.web_server_sg.id\n  description       = \"Allow DNS resolution outbound\"\n}\n\n# Allow PostgreSQL to RDS within VPC\nresource \"aws_security_group_rule\" \"allow_postgres_out\" {\n  type                     = \"egress\"\n  from_port                = 5432\n  to_port                  = 5432\n  protocol                 = \"tcp\"\n  source_security_group_id = aws_security_group.rds_sg.id\n  security_group_id        = aws_security_group.web_server_sg.id\n  description              = \"Allow PostgreSQL to RDS instances\"\n}\n\n# Production best practice: Replace the default \"allow all\" egress\n# with specific rules. This limits blast radius if instance is compromised.\n# An attacker cannot exfiltrate data to arbitrary destinations.\nTFEOF",
      "description": "Define explicit outbound traffic rules instead of allowing all egress",
      "explanation": "By default, security groups allow all outbound traffic. In production, you should replace this with explicit egress rules. This limits what a compromised instance can communicate with - it can reach HTTPS endpoints and DNS, and connect to RDS on port 5432, but nothing else. Note the use of source_security_group_id for RDS access, which is more secure than CIDR blocks.",
      "what_it_does": "Displays restrictive egress rules that only allow HTTPS outbound (for AWS API calls and updates), DNS resolution, and PostgreSQL connections to the RDS security group. This follows defense-in-depth principles by limiting outbound traffic.",
      "next_step": "Next, we will create an IAM Role that EC2 instances can assume.",
      "cleanup": false
    },
    {
      "name": "Step 4: Create an IAM Role",
      "command": "cat << 'TFEOF'\n# iam_role.tf - IAM Role with Trust Policy\n\nresource \"aws_iam_role\" \"web_server_role\" {\n  name = \"web-server-role\"\n\n  # Trust policy - defines WHO can assume this role\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        }\n        # Optional: Add conditions for extra security\n        # Condition = {\n        #   StringEquals = {\n        #     \"aws:SourceAccount\" = \"123456789012\"\n        #   }\n        # }\n      }\n    ]\n  })\n\n  tags = {\n    Name        = \"web-server-role\"\n    Environment = \"production\"\n    ManagedBy   = \"terraform\"\n  }\n}\n\n# Trust Policy vs Permission Policy:\n# - Trust Policy: WHO can assume the role (defined in assume_role_policy)\n# - Permission Policy: WHAT the role can do (attached separately)\n# Think of it as: Trust = authentication, Permission = authorization\nTFEOF",
      "description": "Create an IAM Role with a trust policy allowing EC2 to assume it",
      "explanation": "IAM Roles provide temporary credentials to AWS services. The trust policy (assume_role_policy) defines which entities can assume the role - here we allow EC2 instances. This is much more secure than embedding access keys in your application. The role itself has no permissions yet; we will attach a policy in the next step.",
      "what_it_does": "Displays the Terraform configuration for an IAM Role. The assume_role_policy uses a JSON trust document that allows the EC2 service to assume this role via STS (Security Token Service). EC2 instances with this role get temporary, auto-rotating credentials.",
      "next_step": "Next, we will create an IAM Policy that defines what permissions this role grants.",
      "cleanup": false
    },
    {
      "name": "Step 5: Create an IAM Policy",
      "command": "cat << 'TFEOF'\n# iam_policy.tf - Least Privilege IAM Policy\n\nresource \"aws_iam_policy\" \"web_server_policy\" {\n  name        = \"web-server-policy\"\n  description = \"Least privilege policy for web server instances\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"AllowS3ReadSpecificBucket\"\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObject\",\n          \"s3:ListBucket\"\n        ]\n        Resource = [\n          \"arn:aws:s3:::my-app-assets-prod\",\n          \"arn:aws:s3:::my-app-assets-prod/*\"\n        ]\n      },\n      {\n        Sid    = \"AllowCloudWatchLogs\"\n        Effect = \"Allow\"\n        Action = [\n          \"logs:CreateLogGroup\",\n          \"logs:CreateLogStream\",\n          \"logs:PutLogEvents\",\n          \"logs:DescribeLogStreams\"\n        ]\n        Resource = \"arn:aws:logs:*:*:log-group:/app/web-server:*\"\n      },\n      {\n        Sid    = \"AllowCloudWatchMetrics\"\n        Effect = \"Allow\"\n        Action = [\n          \"cloudwatch:PutMetricData\"\n        ]\n        Resource = \"*\"\n        Condition = {\n          StringEquals = {\n            \"cloudwatch:namespace\" = \"WebServer/Custom\"\n          }\n        }\n      }\n    ]\n  })\n\n  tags = {\n    Name      = \"web-server-policy\"\n    ManagedBy = \"terraform\"\n  }\n}\n\n# Least Privilege Checklist:\n# 1. Specify exact actions needed (not s3:* but s3:GetObject)\n# 2. Scope resources to specific ARNs (not * but exact bucket)\n# 3. Use conditions to further restrict (namespace, source IP, etc)\n# 4. Separate read and write into different statements\n# 5. Review and audit regularly with IAM Access Analyzer\nTFEOF",
      "description": "Write an IAM Policy following the principle of least privilege",
      "explanation": "This policy grants only the minimum permissions the web server needs: reading objects from one specific S3 bucket, writing logs to a specific CloudWatch log group, and publishing custom metrics to a specific namespace. Every action is scoped to specific resources with conditions where possible. This is the gold standard for IAM - never use wildcards (*) for both actions and resources.",
      "what_it_does": "Displays a least-privilege IAM policy with three permission statements. S3 access is limited to read-only on a specific bucket. CloudWatch Logs access is scoped to a single log group. CloudWatch Metrics uses a condition to restrict to a specific namespace. No administrative or broad permissions are granted.",
      "next_step": "Next, we will attach this policy to the IAM role.",
      "cleanup": false
    },
    {
      "name": "Step 6: Attach Policy to Role",
      "command": "cat << 'TFEOF'\n# iam_attachments.tf - Policy Attachment and Instance Profile\n\n# Attach our custom policy to the role\nresource \"aws_iam_role_policy_attachment\" \"web_server_custom\" {\n  role       = aws_iam_role.web_server_role.name\n  policy_arn = aws_iam_policy.web_server_policy.arn\n}\n\n# Optionally attach AWS managed policies for common needs\n# (Only if absolutely necessary - prefer custom policies)\nresource \"aws_iam_role_policy_attachment\" \"ssm_managed\" {\n  role       = aws_iam_role.web_server_role.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\"\n}\n# SSM allows secure shell access without SSH - no need to open port 22!\n\n# WARNING: Never attach these broad policies in production:\n# - arn:aws:iam::aws:policy/AdministratorAccess\n# - arn:aws:iam::aws:policy/PowerUserAccess\n# - arn:aws:iam::aws:policy/AmazonS3FullAccess\nTFEOF",
      "description": "Attach the custom IAM policy and optional managed policies to the role",
      "explanation": "Roles and policies are separate resources that are linked via attachments. This separation allows you to reuse policies across multiple roles and manage permissions independently. We attach our custom least-privilege policy and optionally the SSM managed policy (which enables Session Manager for secure shell access without SSH). Always prefer custom policies over AWS managed ones for tighter control.",
      "what_it_does": "Displays the policy attachment resources that link our custom policy and the AWS SSM managed policy to the web server role. The SSM policy enables AWS Systems Manager access, which is a more secure alternative to SSH since it does not require opening port 22.",
      "next_step": "Next, we will create an instance profile so EC2 instances can use this role.",
      "cleanup": false
    },
    {
      "name": "Step 7: Create Instance Profile",
      "command": "cat << 'TFEOF'\n# instance_profile.tf - EC2 Instance Profile\n\n# Instance Profile wraps the IAM Role for use with EC2\nresource \"aws_iam_instance_profile\" \"web_server_profile\" {\n  name = \"web-server-profile\"\n  role = aws_iam_role.web_server_role.name\n\n  tags = {\n    Name      = \"web-server-profile\"\n    ManagedBy = \"terraform\"\n  }\n}\n\n# Usage in an EC2 instance:\n# resource \"aws_instance\" \"web\" {\n#   ami                  = \"ami-0c55b159cbfafe1f0\"\n#   instance_type        = \"t3.micro\"\n#   iam_instance_profile = aws_iam_instance_profile.web_server_profile.name\n#   vpc_security_group_ids = [aws_security_group.web_server_sg.id]\n#   ...\n# }\n\n# The EC2 instance will automatically receive temporary credentials\n# via the Instance Metadata Service (IMDS). Your application uses\n# the AWS SDK which auto-discovers these credentials - no config needed!\nTFEOF",
      "description": "Create an IAM Instance Profile to assign the role to EC2 instances",
      "explanation": "An Instance Profile is a container for an IAM Role that allows EC2 instances to assume it. You cannot directly assign a role to EC2 - you must wrap it in an instance profile. When the EC2 instance launches with this profile, the AWS SDK automatically discovers credentials from the Instance Metadata Service (IMDS) without any manual configuration.",
      "what_it_does": "Displays the instance profile resource and shows how it would be referenced in an EC2 instance resource. The profile wraps the IAM role and is assigned to the instance via the iam_instance_profile argument. The instance then automatically receives temporary credentials.",
      "next_step": "Next, we will review the complete security setup and see how all pieces connect.",
      "cleanup": false
    },
    {
      "name": "Step 8: Review Complete Security Setup",
      "command": "echo '=== Complete Security Architecture ==='\necho ''\necho 'NETWORK LAYER (Security Groups):'\necho '  Inbound:'\necho '    [Internet] --HTTP/443--> [Web Server SG] ---> EC2'\necho '    [Internet] --HTTPS/443-> [Web Server SG] ---> EC2'\necho '    [Internal] --SSH/22----> [Web Server SG] ---> EC2'\necho '  Outbound:'\necho '    EC2 --HTTPS/443--> [Internet] (API calls, updates)'\necho '    EC2 --DNS/53-----> [Internet] (name resolution)'\necho '    EC2 --PG/5432----> [RDS SG]   (database access)'\necho ''\necho 'IDENTITY LAYER (IAM):'\necho '  EC2 Instance'\necho '    --> Instance Profile: web-server-profile'\necho '      --> IAM Role: web-server-role'\necho '        --> Custom Policy: web-server-policy'\necho '            - S3: Read from my-app-assets-prod bucket'\necho '            - CloudWatch Logs: Write to /app/web-server'\necho '            - CloudWatch Metrics: Publish to WebServer/Custom'\necho '        --> Managed Policy: AmazonSSMManagedInstanceCore'\necho '            - SSM Session Manager access (replaces SSH)'\necho ''\necho 'SECURITY BEST PRACTICES APPLIED:'\necho '  [x] SSH restricted to internal network only'\necho '  [x] Explicit egress rules (no allow-all outbound)'\necho '  [x] IAM Role instead of access keys'\necho '  [x] Least privilege - specific actions and resources'\necho '  [x] Conditions on CloudWatch metrics namespace'\necho '  [x] SSM for secure access without SSH'\necho '  [x] All resources tagged for audit trail'",
      "description": "Review the complete security architecture showing how all components connect",
      "explanation": "This overview shows the two security layers working together: Security Groups handle network-level access control (what traffic can reach or leave the instance), while IAM handles identity-level access control (what AWS services the instance can interact with). Together they implement defense-in-depth - even if one layer is misconfigured, the other still provides protection.",
      "what_it_does": "Prints a summary diagram of the complete security architecture. It shows the network flow through security group rules and the IAM permission chain from instance to profile to role to policies. It also lists all the security best practices applied in this scenario.",
      "next_step": "You have completed the security setup. Run the cleanup step to remove simulated files.",
      "cleanup": false
    },
    {
      "name": "Step 9: Cleanup",
      "command": "echo 'Cleaning up scenario 05-security-groups-and-iam-roles...'\necho 'In a real environment, you would run:'\necho '  terraform destroy -auto-approve'\necho ''\necho 'This would remove:'\necho '  - aws_security_group.web_server_sg (and all rules)'\necho '  - aws_iam_role.web_server_role'\necho '  - aws_iam_policy.web_server_policy'\necho '  - aws_iam_role_policy_attachment.web_server_custom'\necho '  - aws_iam_role_policy_attachment.ssm_managed'\necho '  - aws_iam_instance_profile.web_server_profile'\necho ''\necho 'Cleanup complete!'",
      "description": "Remove all simulated resources created during this scenario",
      "explanation": "In production, terraform destroy removes all resources managed by your Terraform state in dependency order. Terraform knows to detach policies before deleting roles, and remove rules before deleting security groups. Always review the destroy plan before confirming in production environments.",
      "what_it_does": "Displays the cleanup commands and lists all resources that would be destroyed. In this simulation, no actual AWS resources were created, so this is informational only.",
      "next_step": "Scenario complete! You now understand how to secure AWS infrastructure with Security Groups and IAM Roles.",
      "cleanup": true
    }
  ]
}
