# Helm Chart Dependencies Explanation

This guide explains how Helm manages chart dependencies (subcharts), how to declare them in Chart.yaml, and how to override subchart values from the parent chart. You'll understand the complete lifecycle of dependency management.

---

## üéØ What are Helm Chart Dependencies?

**Chart dependencies** (also called **subcharts**) are Helm charts that your chart depends on. Instead of manually deploying a database or other services, you can declare them as dependencies and Helm will manage them together with your application.

### Why Use Dependencies?

**Without dependencies (manual approach):**
```bash
# Install database separately
helm install my-db bitnami/postgresql

# Install your app
helm install my-app ./app-chart

# Manually coordinate values, names, etc.
```

**With dependencies (declarative approach):**
```bash
# Install everything together
helm install my-app ./app-chart
# ‚úÖ Deploys app + database
# ‚úÖ Managed as single release
# ‚úÖ Values coordinated automatically
```

**Benefits:**
- ‚úÖ **Single deployment** - One command deploys everything
- ‚úÖ **Version locking** - Pin specific dependency versions
- ‚úÖ **Value inheritance** - Override dependency config from parent
- ‚úÖ **Lifecycle management** - Upgrade/rollback affects all components
- ‚úÖ **Portability** - Share complete application stack as one chart

---

## üìÅ Chart Directory Structure with Dependencies

```
myapp/
‚îú‚îÄ‚îÄ Chart.yaml           # Declares dependencies
‚îú‚îÄ‚îÄ values.yaml          # Parent + subchart value overrides
‚îú‚îÄ‚îÄ Chart.lock           # Locked dependency versions (generated)
‚îú‚îÄ‚îÄ charts/              # Downloaded dependencies (generated)
‚îÇ   ‚îî‚îÄ‚îÄ postgresql-16.4.0.tgz
‚îú‚îÄ‚îÄ templates/           # Parent chart's templates
‚îÇ   ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ service.yaml
‚îÇ   ‚îî‚îÄ‚îÄ _helpers.tpl
‚îî‚îÄ‚îÄ .helmignore
```

### Key Files

**Chart.yaml** - Declares dependencies:
```yaml
dependencies:
  - name: postgresql
    version: "~16.4.0"
    repository: https://charts.bitnami.com/bitnami
```

**charts/** - Stores downloaded subcharts (generated by `helm dependency update`)

**Chart.lock** - Locks exact versions (like package-lock.json, generated)

---

## üìÑ Chart.yaml with Dependencies

### Full Example

```yaml
apiVersion: v2
name: myapp
description: A sample application with a PostgreSQL database dependency
type: application
version: 0.1.0
appVersion: "1.0.0"

dependencies:
  - name: postgresql
    version: "~16.4.0"
    repository: https://charts.bitnami.com/bitnami
    condition: postgresql.enabled
```

### Field-by-Field Breakdown

#### apiVersion: v2

**What it is:** Helm chart API version

**Options:**
- `v2` - Helm 3 (current, recommended)
- `v1` - Helm 2 (deprecated)

**Why v2:**
- Required for dependency management features
- Supports dependency conditions and tags
- Required for Helm 3

#### type: application

**What it is:** Defines chart purpose

**Options:**
- `application` - Deploys workloads (default)
- `library` - Provides reusable templates only (no deployment)

**Why application:**
- We're deploying a real application
- Library charts can't be installed directly

#### dependencies

**What it is:** List of charts this chart depends on

**Structure:**
```yaml
dependencies:
  - name: <chart-name>
    version: <version-constraint>
    repository: <chart-repo-url>
    condition: <values-path>  # Optional
    tags: [<tag>]             # Optional
    alias: <custom-name>      # Optional
```

### Dependency Fields Explained

#### name: postgresql

**What it is:** The name of the dependency chart

**Must match:** The chart name in the repository

**Usage:** This becomes the key in values.yaml for overrides:
```yaml
postgresql:  # ‚Üê name from Chart.yaml
  auth:
    password: "secret"
```

#### version: "~16.4.0"

**What it is:** Version constraint for the dependency

**Constraint Types:**

| Constraint | Meaning | Example | Matches |
|------------|---------|---------|---------|
| `16.4.0` | Exact version | `16.4.0` | Only 16.4.0 |
| `~16.4.0` | Patch updates | `~16.4.0` | 16.4.0, 16.4.1, 16.4.9 (not 16.5.0) |
| `^16.4.0` | Minor updates | `^16.4.0` | 16.4.0, 16.5.0, 16.9.0 (not 17.0.0) |
| `>=16.4.0 <17.0.0` | Range | `>=16.4.0 <17.0.0` | 16.4.0 to 16.9.9 |
| `*` | Any version | `*` | Latest available |

**Best practices:**

‚úÖ **Production:**
```yaml
version: "16.4.0"  # Exact version for reproducibility
```

‚úÖ **Development:**
```yaml
version: "~16.4.0"  # Allow patch updates for bug fixes
```

‚ùå **Avoid:**
```yaml
version: "*"  # Non-deterministic, can break unexpectedly
```

#### repository: https://charts.bitnami.com/bitnami

**What it is:** URL of the Helm chart repository

**Common repositories:**

| Repository | URL | Description |
|------------|-----|-------------|
| **Bitnami** | `https://charts.bitnami.com/bitnami` | Production-ready charts (most popular) |
| **Helm Stable** (archived) | `https://charts.helm.sh/stable` | Legacy, no longer maintained |
| **Artifact Hub** | Various | Central hub for finding charts |
| **Private/Internal** | `https://charts.mycompany.com` | Company-specific charts |

**Local dependencies:**
```yaml
repository: "file://../other-chart"  # Relative path
```

**OCI registries:**
```yaml
repository: "oci://ghcr.io/myorg/charts"  # OCI-based registry
```

#### condition: postgresql.enabled

**What it is:** A values path that enables/disables this dependency

**How it works:**
```yaml
# In values.yaml
postgresql:
  enabled: true  # ‚Üê Controls if dependency is installed
```

**When enabled: false:**
- Dependency chart is **NOT installed**
- `charts/postgresql-*.tgz` still downloaded (but not deployed)
- Useful for optional dependencies

**Example use cases:**
```yaml
# Development (use local database)
postgresql:
  enabled: false

# Production (use external RDS)
postgresql:
  enabled: false
  externalDatabase:
    host: "prod-db.us-east-1.rds.amazonaws.com"
```

**Multiple conditions:**
```yaml
condition: postgresql.enabled, database.enabled
# Enabled if EITHER value is true
```

#### tags (optional)

**What it is:** Group dependencies by tag, enable/disable groups

**Example:**
```yaml
dependencies:
  - name: postgresql
    version: "16.4.0"
    repository: https://charts.bitnami.com/bitnami
    tags:
      - database
  - name: redis
    version: "18.0.0"
    repository: https://charts.bitnami.com/bitnami
    tags:
      - cache
      - database
```

**In values.yaml:**
```yaml
tags:
  database: true  # Enables postgresql AND redis
  cache: true     # Enables redis
```

**When to use:**
- Multiple related dependencies
- Environment-specific configurations (dev vs prod)
- Feature flags

#### alias (optional)

**What it is:** Custom name for the dependency (overrides `name`)

**Example:**
```yaml
dependencies:
  - name: postgresql
    version: "16.4.0"
    repository: https://charts.bitnami.com/bitnami
    alias: primary-db  # ‚Üê Custom name

  - name: postgresql
    version: "16.4.0"
    repository: https://charts.bitnami.com/bitnami
    alias: secondary-db  # ‚Üê Can use same chart twice!
```

**In values.yaml:**
```yaml
primary-db:    # ‚Üê Use alias, not 'postgresql'
  auth:
    database: "primary"

secondary-db:  # ‚Üê Different config for second instance
  auth:
    database: "secondary"
```

**Use cases:**
- Deploy same chart multiple times with different configs
- Better naming for clarity (e.g., `app-database` instead of `postgresql`)

---

## üìÑ values.yaml with Subchart Overrides

### Full Example

```yaml
# values.yaml
# Parent chart values and subchart overrides

# --------------------
# Application settings (parent chart)
# --------------------
replicaCount: 1

image:
  repository: nginx
  tag: "1.25-alpine"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

resources:
  requests:
    cpu: 50m
    memory: 64Mi
  limits:
    cpu: 100m
    memory: 128Mi

# Application environment variables
env:
  - name: DATABASE_HOST
    value: "myapp-postgresql"  # ‚Üê Service name of subchart
  - name: DATABASE_PORT
    value: "5432"
  - name: DATABASE_NAME
    value: "appdb"
  - name: DATABASE_USER
    value: "appuser"

# --------------------
# PostgreSQL subchart overrides
# --------------------
postgresql:
  enabled: true

  auth:
    postgresPassword: "supersecret"
    username: "appuser"
    password: "appsecret"
    database: "appdb"

  primary:
    resources:
      requests:
        cpu: 50m
        memory: 128Mi
      limits:
        cpu: 250m
        memory: 256Mi

    persistence:
      size: 1Gi

    podSecurityContext:
      fsGroup: 1001
    containerSecurityContext:
      runAsUser: 1001
```

### Parent Chart Values

#### Application Settings

```yaml
replicaCount: 1
image:
  repository: nginx
  tag: "1.25-alpine"
service:
  type: ClusterIP
  port: 80
```

**These values:**
- Apply to the **parent chart's** templates
- Are accessed via `.Values.replicaCount`, `.Values.image.repository`, etc.
- Do **NOT** affect the subchart

#### env (Application Environment Variables)

```yaml
env:
  - name: DATABASE_HOST
    value: "myapp-postgresql"  # ‚Üê IMPORTANT!
  - name: DATABASE_PORT
    value: "5432"
  - name: DATABASE_NAME
    value: "appdb"
  - name: DATABASE_USER
    value: "appuser"
```

**DATABASE_HOST breakdown:**

**Format:** `<release-name>-<dependency-name>`

**Example:**
- Release name: `myapp`
- Dependency name: `postgresql`
- Service name: `myapp-postgresql`

**Why this matters:**
```bash
# Inside your app pod:
psql -h myapp-postgresql -U appuser -d appdb
# ‚Üë This hostname resolves via Kubernetes DNS
```

**Full DNS name:**
```
myapp-postgresql.helm-scenarios.svc.cluster.local
# <service>.<namespace>.svc.cluster.local
```

**If using alias:**
```yaml
# Chart.yaml
dependencies:
  - name: postgresql
    alias: primary-db

# values.yaml
env:
  - name: DATABASE_HOST
    value: "myapp-primary-db"  # ‚Üê Uses alias
```

### Subchart Value Overrides

#### postgresql (Top-Level Key)

```yaml
postgresql:  # ‚Üê Must match dependency name (or alias)
  # All values under here are passed to postgresql subchart
```

**How it works:**
1. Helm reads parent `values.yaml`
2. Extracts `postgresql` section
3. Merges with PostgreSQL chart's default `values.yaml`
4. Renders PostgreSQL templates with merged values

**Precedence (highest to lowest):**
```
Parent chart's postgresql: {...}  # values.yaml (highest)
‚Üì
--set flags                        # helm install --set postgresql.auth.password=...
‚Üì
PostgreSQL chart defaults          # Dependency's values.yaml (lowest)
```

#### postgresql.enabled

```yaml
postgresql:
  enabled: true
```

**Purpose:** Controls dependency installation (set in Chart.yaml condition)

**Use cases:**

**Enable in dev (local database):**
```yaml
# values-dev.yaml
postgresql:
  enabled: true
```

**Disable in prod (external RDS):**
```yaml
# values-prod.yaml
postgresql:
  enabled: false

externalDatabase:
  host: "prod-db.us-east-1.rds.amazonaws.com"
  port: 5432
  username: "appuser"
  database: "appdb"
```

#### postgresql.auth

```yaml
postgresql:
  auth:
    postgresPassword: "supersecret"  # Superuser password
    username: "appuser"              # App user
    password: "appsecret"            # App user password
    database: "appdb"                # App database
```

**What this creates:**

| User | Password | Database | Permissions |
|------|----------|----------|-------------|
| `postgres` | `supersecret` | all | Superuser |
| `appuser` | `appsecret` | `appdb` | Owner of `appdb` |

**Why two users:**
- **postgres**: Administrative tasks, backups, schema migrations
- **appuser**: Application runtime (least privilege)

**Security best practices:**

‚ùå **Never hardcode secrets in values.yaml:**
```yaml
auth:
  password: "appsecret"  # BAD - committed to Git
```

‚úÖ **Use external secrets:**
```yaml
auth:
  existingSecret: "postgres-secrets"  # Reference Kubernetes Secret
```

‚úÖ **Override at install time:**
```bash
helm install myapp ./myapp \
  --set postgresql.auth.password=$(openssl rand -base64 32)
```

‚úÖ **Use sealed secrets, SOPS, or Vault:**
```bash
helm install myapp ./myapp -f <(sops -d secrets.yaml)
```

#### postgresql.primary

```yaml
postgresql:
  primary:  # Primary/read-write instance configuration
    resources: {...}
    persistence: {...}
    podSecurityContext: {...}
```

**What is primary:**
- In a single-instance setup: the only database instance
- In HA setup: the read-write master (with replicas)

**Alternative configurations:**

**High availability with replicas:**
```yaml
postgresql:
  architecture: replication  # master + replicas
  replication:
    numSynchronousReplicas: 1
    synchronousCommit: "on"
  readReplicas:
    replicaCount: 2
```

#### postgresql.primary.resources

```yaml
primary:
  resources:
    requests:
      cpu: 50m        # Minimum guaranteed: 5% of 1 core
      memory: 128Mi   # Minimum guaranteed: 134 MB
    limits:
      cpu: 250m       # Maximum allowed: 25% of 1 core
      memory: 256Mi   # Maximum allowed: 268 MB
```

**Why these values:**
- ‚úÖ **Suitable for Kind cluster** - Won't exhaust local resources
- ‚úÖ **PostgreSQL minimum** - Enough for basic operation
- ‚úÖ **Burst capacity** - Limits are 2-5√ó requests

**Production recommendations:**

**Small application (< 1000 users):**
```yaml
requests:
  cpu: 250m
  memory: 512Mi
limits:
  cpu: 1000m
  memory: 1Gi
```

**Medium application (1000-10000 users):**
```yaml
requests:
  cpu: 1000m
  memory: 2Gi
limits:
  cpu: 2000m
  memory: 4Gi
```

**Large application (> 10000 users):**
```yaml
requests:
  cpu: 2000m
  memory: 8Gi
limits:
  cpu: 4000m
  memory: 16Gi
```

#### postgresql.primary.persistence

```yaml
primary:
  persistence:
    size: 1Gi  # PersistentVolume size
```

**What this does:**
- Creates a PersistentVolumeClaim (PVC)
- Mounts persistent storage for database data
- Survives pod restarts/rescheduling

**Default behavior (Bitnami PostgreSQL chart):**
```yaml
persistence:
  enabled: true              # Use persistent storage
  storageClass: ""           # Use cluster default StorageClass
  accessModes:
    - ReadWriteOnce          # Single node access
  size: 8Gi                  # Default 8GB
```

**Production considerations:**

**Size calculation:**
```
Size = (Expected data) √ó 1.5 (growth) + (WAL logs) + (safety margin)

Example:
- Expected data: 10 GB
- Growth (50%): 5 GB
- WAL logs: 2 GB
- Safety: 3 GB
Total: 20 GB ‚Üí use size: 25Gi
```

**StorageClass selection:**
```yaml
persistence:
  storageClass: "fast-ssd"  # Use specific StorageClass
```

**Disable persistence (testing only):**
```yaml
persistence:
  enabled: false  # Data lost on pod restart!
```

#### postgresql.primary.podSecurityContext

```yaml
primary:
  podSecurityContext:
    fsGroup: 1001  # Group ID for volume ownership
  containerSecurityContext:
    runAsUser: 1001  # User ID to run PostgreSQL as
```

**What this does:**
- Runs PostgreSQL as non-root user (UID 1001)
- Sets file ownership to group 1001

**Why non-root:**
- ‚úÖ **Security best practice** - Principle of least privilege
- ‚úÖ **Regulatory compliance** - Many standards require non-root
- ‚úÖ **Limit blast radius** - Reduces impact of container escape

**Pod Security Standards:**

| Standard | runAsNonRoot | allowPrivilegeEscalation |
|----------|--------------|--------------------------|
| **Privileged** | Any | Any |
| **Baseline** | Optional | Must be false |
| **Restricted** | Must be true | Must be false |

Our configuration: **Baseline** compliant

---

## üîÑ Dependency Management Commands

### helm dependency update

**Purpose:** Download or update dependencies to `charts/` directory

**Syntax:**
```bash
helm dependency update <chart-path>
```

**Example:**
```bash
cd myapp/
helm dependency update .
```

**What it does:**
1. Reads `Chart.yaml` dependencies
2. Downloads each dependency from its repository
3. Saves tarballs to `charts/` directory
4. Generates/updates `Chart.lock` with exact versions

**Output:**
```
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "bitnami" chart repository
Update Complete. ‚éàHappy Helming!‚éà
Saving 1 charts
Downloading postgresql from repo https://charts.bitnami.com/bitnami
Deleting outdated charts
```

**Resulting files:**
```
myapp/
‚îú‚îÄ‚îÄ Chart.lock          # NEW or UPDATED
‚îî‚îÄ‚îÄ charts/
    ‚îî‚îÄ‚îÄ postgresql-16.4.0.tgz  # NEW or UPDATED
```

### helm dependency build

**Purpose:** Rebuild `charts/` from `Chart.lock` (if it exists)

**Syntax:**
```bash
helm dependency build <chart-path>
```

**Difference from `update`:**

| Command | Uses Chart.lock | Updates Chart.lock | Downloads Latest |
|---------|-----------------|-------------------|------------------|
| **update** | No | Yes | Yes |
| **build** | Yes (if exists) | No | No (uses locked versions) |

**Use `update` when:**
- First time setting up dependencies
- Want to update to newer versions
- Changed `Chart.yaml` dependencies

**Use `build` when:**
- `Chart.lock` exists and you want exact versions
- CI/CD pipeline (reproducible builds)
- Team member syncing dependencies

**Example workflow:**
```bash
# Developer 1: Add dependency, update
helm dependency update ./myapp
git add Chart.yaml Chart.lock charts/
git commit -m "Add PostgreSQL dependency"
git push

# Developer 2: Pull changes, build from lock
git pull
helm dependency build ./myapp  # Uses exact versions from Chart.lock
```

### helm dependency list

**Purpose:** Show all dependencies and their status

**Syntax:**
```bash
helm dependency list <chart-path>
```

**Example output:**
```
NAME          VERSION    REPOSITORY                              STATUS
postgresql    ~16.4.0    https://charts.bitnami.com/bitnami      ok
```

**Status meanings:**
- `ok` - Downloaded and up-to-date
- `missing` - Declared but not downloaded (run `helm dependency update`)
- `unpacked` - Dependency unpacked in `charts/` (not .tgz)

### Cleaning Dependencies

**Remove all downloaded dependencies:**
```bash
rm -rf charts/ Chart.lock
helm dependency update .
```

**Why clean:**
- Free disk space
- Force re-download (troubleshoot corruption)
- Remove old dependencies after Chart.yaml changes

---

## üì¶ Chart.lock File

### What is Chart.lock?

**Purpose:** Lock exact dependency versions (like package-lock.json, Gemfile.lock)

**Generated by:** `helm dependency update`

**Example:**
```yaml
dependencies:
- name: postgresql
  repository: https://charts.bitnami.com/bitnami
  version: 16.4.2  # ‚Üê Exact version locked
digest: sha256:a3f8b...
generated: "2024-01-15T10:00:00.123456Z"
```

**Why it exists:**
- ‚úÖ **Reproducible builds** - Same versions every time
- ‚úÖ **Team consistency** - Everyone uses same dependency versions
- ‚úÖ **Prevent surprises** - Won't get breaking changes from `~16.4.0` unexpectedly

**Should you commit it:**

‚úÖ **YES, commit Chart.lock:**
- Ensures team uses same versions
- CI/CD builds are deterministic
- Production deploys are reproducible

‚ùå **Don't commit charts/:**
- Large tarball files
- Can be regenerated from Chart.lock
- Add to `.gitignore`:
  ```gitignore
  charts/*.tgz
  ```

---

## üéØ Subchart Access Patterns

### Accessing Parent Values from Subchart

**Not possible by default** - Subcharts can't access parent values.

**Workaround: global values**

**In parent values.yaml:**
```yaml
global:
  environment: production
  region: us-east-1

postgresql:
  auth:
    password: "secret"
```

**In subchart templates:**
```yaml
# postgresql/templates/deployment.yaml
env:
  - name: ENVIRONMENT
    value: {{ .Values.global.environment }}  # ‚Üê Accessible!
```

**Global values are shared across all charts (parent + subcharts)**

### Accessing Subchart Values from Parent

**Access subchart resources via Service DNS:**

```yaml
# Parent deployment template
env:
  - name: DATABASE_HOST
    value: "{{ .Release.Name }}-postgresql"  # Service name
  - name: DATABASE_PORT
    value: "5432"
```

**Template functions:**
```yaml
# Check if subchart is enabled
{{- if index .Values "postgresql" "enabled" }}
# Subchart is enabled
{{- end }}
```

---

## üêõ Troubleshooting Dependencies

### Error: "chart requires kubeVersion"

```
Error: chart requires kubeVersion: >=1.23.0 which is incompatible with Kubernetes v1.21.0
```

**Solution 1:** Upgrade cluster:
```bash
kind delete cluster
kind create cluster --image kindest/node:v1.28.0
```

**Solution 2:** Use older dependency version:
```yaml
dependencies:
  - name: postgresql
    version: "13.0.0"  # Older version with lower k8s requirement
```

### Error: "dependency is missing"

```
Error: found in Chart.yaml, but missing in charts/ directory: postgresql
```

**Solution:**
```bash
helm dependency update ./myapp
```

### Error: "failed to download"

```
Error: Failed to download "postgresql" at version "~16.4.0"
```

**Check 1: Repository added?**
```bash
helm repo list
# If missing:
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update
```

**Check 2: Version exists?**
```bash
helm search repo bitnami/postgresql --versions
```

### Dependencies installed but app can't connect

**Check 1: Service name correct?**
```bash
kubectl get svc -n helm-scenarios
# Look for: <release-name>-<dependency-name>
```

**Check 2: Credentials correct?**
```bash
# Get secret
kubectl get secret myapp-postgresql -n helm-scenarios -o yaml

# Decode password
kubectl get secret myapp-postgresql -n helm-scenarios -o jsonpath='{.data.password}' | base64 -d
```

**Check 3: Database ready?**
```bash
kubectl get pods -n helm-scenarios
# postgresql pod should be Running and Ready (1/1)

kubectl logs <postgresql-pod> -n helm-scenarios
# Check for "database system is ready to accept connections"
```

### Subchart values not applying

**Problem:**
```yaml
# values.yaml
postgres:  # ‚ùå WRONG KEY
  auth:
    password: "secret"
```

**Solution: Use exact dependency name:**
```yaml
postgresql:  # ‚úÖ Matches Chart.yaml dependency name
  auth:
    password: "secret"
```

**Verify:**
```bash
helm template myapp ./myapp | grep -A 10 "kind: Secret"
# Check if password appears in rendered output
```

---

## üéì Best Practices

### Dependency Management

‚úÖ **Pin exact versions in production:**
```yaml
version: "16.4.2"  # Not "~16.4.0"
```

‚úÖ **Commit Chart.lock, ignore charts/:**
```gitignore
# .gitignore
charts/*.tgz
!charts/.gitkeep
```

‚úÖ **Use conditions for optional dependencies:**
```yaml
dependencies:
  - name: postgresql
    condition: postgresql.enabled
```

‚úÖ **Document dependency requirements:**
```yaml
# README.md
## Dependencies
- PostgreSQL 16.x (for data storage)
- Redis 7.x (for caching, optional)
```

### Value Overrides

‚úÖ **Use specific overrides, not blind copies:**
```yaml
# Good
postgresql:
  auth:
    password: "secret"
  primary:
    resources:
      requests:
        cpu: 50m

# Bad (overrides too much, breaks on chart updates)
postgresql:
  # ... entire values.yaml from postgresql chart ...
```

‚úÖ **Use global values for cross-cutting concerns:**
```yaml
global:
  environment: production
  region: us-east-1
  imageRegistry: "myregistry.io"
```

‚úÖ **Keep subchart overrides close to parent values:**
```yaml
# values.yaml structure
# 1. Parent chart values
replicaCount: 1
image: ...

# 2. Environment variables (connection to subchart)
env:
  - name: DATABASE_HOST
    value: "myapp-postgresql"

# 3. Subchart overrides
postgresql:
  auth: ...
```

### Security

‚úÖ **Never hardcode secrets:**
```yaml
# Bad
postgresql:
  auth:
    password: "mysecretpassword"  # ‚ùå In Git!

# Good
postgresql:
  auth:
    existingSecret: "postgres-creds"  # ‚úÖ Reference existing Secret
```

‚úÖ **Generate passwords at install time:**
```bash
helm install myapp ./myapp \
  --set postgresql.auth.password=$(openssl rand -base64 32) \
  --set postgresql.auth.postgresPassword=$(openssl rand -base64 32)
```

‚úÖ **Use tools like sealed-secrets, SOPS, Vault:**
```bash
# SOPS encrypted secrets
helm install myapp ./myapp -f <(sops -d secrets.enc.yaml)
```

---

## üîó Further Reading

- **Helm Dependencies Documentation**: https://helm.sh/docs/helm/helm_dependency/
- **Helm Chart Best Practices**: https://helm.sh/docs/chart_best_practices/dependencies/
- **Bitnami PostgreSQL Chart**: https://github.com/bitnami/charts/tree/main/bitnami/postgresql
- **SemVer Version Constraints**: https://semver.org/
- **Kubernetes PersistentVolumes**: https://kubernetes.io/docs/concepts/storage/persistent-volumes/

---

*This guide provides a comprehensive understanding of Helm chart dependencies. Mastering dependencies enables building complex, multi-component applications that deploy reliably and consistently!*
